# **Наследование vs композиция**

[Содержание](/CONTENTS.md#содержание)

## **Junior Level**

Наследование и композиция — это два фундаментальных подхода к организации кода в объектно-ориентированном
программировании, и выбор между ними определяет, насколько гибкой, понятной и удобной для поддержки будет ваша система.

Основное различие лежит в типе отношений, которые они моделируют:

* **Наследование** описывает отношение **«является»** (is-a). Например, `Dog` (Собака) наследует от `Animal` (Животное),
  потому что собака *является* конкретным видом животного. Это позволяет `Dog` автоматически получить общие для всех
  животных свойства и методы (например, `eat()` или `sleep()`), а также добавить свои уникальные (`bark()`).
* **Композиция** описывает отношение **«имеет»** (has-a). Класс `Car` (Автомобиль) не является двигателем, но он *имеет*
  его как составную часть. Двигатель — это независимый компонент, с которым автомобиль взаимодействует через четко
  определенный интерфейс.

**Ключевое правило современной разработки: предпочитайте композицию наследованию.** Наследование создает жесткую,
статическую связь, подобную родственной. Изменения в «родительском» классе могут неожиданно «сломать» всех его
«потомков». Композиция же строит более гибкие, договорные отношения: вы можете заменить «двигатель» на другой, не
переделывая всю «машину». Для тестирования это преимущество критично — компоненты, переданные через композицию, легко
подменить на заглушки (mocks), что позволяет тестировать классы изолированно.

[Содержание](/CONTENTS.md#содержание)

## **Middle Level**

### **Детали и тонкости наследования в Python**

1. **Механизм и порядок разрешения методов (MRO)**: Python поддерживает множественное наследование. Чтобы управлять
   потенциальным хаосом при поиске методов, используется строгий **MRO (Method Resolution Order)**, вычисляемый по
   алгоритму C3 (`ClassName.__mro__`). Этот порядок гарантирует, что каждый класс в иерархии будет проверен только один
   раз и предсказуемо.

2. **Инструмент `super()` и кооперативное наследование**: `super()` — это не просто вызов метода родителя. В условиях
   MRO он делегирует выполнение **следующему классу в цепочке**. Это позволяет нескольким классам-предкам (например,
   `Mixin`-ам) кооперативно участвовать в выполнении одного метода (например, `__init__`), не мешая друг другу.

3. **Наследование как потенциальное нарушение инкапсуляции**: Это ключевая критика наследования. Дочерний класс получает
   доступ к защищённым (`_protected`) членам родителя, что создает хрупкую, скрытую зависимость от его внутренней
   реализации. Тестировать такой класс сложно, так как для понимания его поведения необходимо глубоко знать детали
   работы родителя.

4. **Множественное наследование и Mixins**: Python разрешает множественное наследование, что часто используется для *
   *Mixins** — небольших классов, добавляющих конкретную функциональность (например, `JSONSerializableMixin`). Mixin не
   предназначен для использования отдельно. При их применении важно проектировать имена методов так, чтобы избежать
   конфликтов, разрешаемых через MRO.

5. **Абстрактные классы (ABC)**: Модуль `abc` позволяет создавать формальные «чертежи» — классы, объявляющие
   обязательные методы (через `@abstractmethod`). Они заставляют наследников соблюдать контракт, явно формализуя
   отношение «является».

### **Детали и тонкости композиции в Python**

1. **Композиция vs Агрегация: управление жизненным циклом**:
    * **Композиция (сильная связь)**: Компонент (например, `Heart` для `Human`) не существует отдельно. Он создаётся и
      уничтожается вместе с объектом-владельцем (обычно в `__init__`).
    * **Агрегация (слабая связь)**: Компонент (например, `Driver` для `Car`) существует независимо и передаётся объекту
      извне (как аргумент). Их жизненные циклы разделены.

2. **Композиция и структурная типизация (Протоколы)**: Вместо жесткого наследования от абстрактного класса для
   достижения полиморфизма в Python всё чаще используют **композицию с протоколами** (`typing.Protocol`). Объекту не
   нужно объявлять «я наследник `Reader`» — достаточно просто реализовать метод `read()`. Это резко снижает связанность.
   В тестах можно подставить любой объект с нужным методом, не строя сложных иерархий.

3. **Делегирование как явная форма композиции**: Паттерн **Делегирование** — это когда внешний объект (делегатор) явно
   передает выполнение задачи внутреннему объекту (делегату). В Python его можно элегантно реализовать через
   `__getattr__`, автоматически перенаправляя вызовы. Это основа для объеков-обёрток (адаптеров, прокси), которые дают
   полный контроль над взаимодействием и являются идеальной точкой для внедрения моков в тестах.

4. **Динамическое поведение**: Композиция позволяет менять поведение объекта во время выполнения программы, заменяя его
   компоненты. Этот принцип лежит в основе многих паттернов, таких как **Стратегия** (Strategy), где алгоритм можно
   «подменить на лету».

### **Сравнительный анализ для проектирования и тестирования**

* **Гибкость и связность**: Наследование фиксирует отношения на этапе компиляции, приводя к высокой связности.
  Композиция/агрегация определяют поведение во время выполнения, обеспечивая слабую связность и большую гибкость.

* **Тестируемость**: Класс, построенный на композиции, легко тестировать изолированно. Его зависимости — это просто
  аргументы, которые можно подменить. Тестирование глубокой иерархии наследования требует создания сложных фикстур и
  мокирования родительских методов, что увеличивает сложность тестов.

* **Проблема хрупкого базового класса**: Это главный риск наследования. Даже безопасное на вид изменение во внутренней
  логике родителя может сломать работу непредусмотревшего этого наследника. В больших проектах отследить такие побочные
  эффекты крайне трудно.

* **Борьба со сложностью архитектуры**: Глубокие иерархии наследования имеют тенденцию разрастаться и усложняться.
  Композиция предлагает альтернативную парадигму: строить сложную систему не через вертикальное ветвление, а через
  горизонтальную сборку из небольших, независимых и легко заменяемых компонентов. Это прямой путь к более
  поддерживаемому и надежному коду.

[Содержание](/CONTENTS.md#содержание)

## **Senior Level**

## Базовая структура объектов CPython

В CPython все объекты наследуют от базовой структуры `PyObject`, которая имитирует наследование через композицию в C.
Это видно в заголовочном файле `Include/object.h`.

```c
// Include/object.h: базовая структура всех Python объектов
#define PyObject_HEAD                   PyObject ob_base;

struct _object {
    // Счетчик ссылок (может быть разбит на части для 64-битных систем)
    union {
#if SIZEOF_VOID_P > 4
        PY_INT64_T ob_refcnt_full;
        struct {
# if PY_BIG_ENDIAN
            uint16_t ob_flags;     // Флаги объекта
            uint16_t ob_overflow;  // Переполнение refcnt
            uint32_t ob_refcnt;    // Основной счетчик ссылок
# else
            uint32_t ob_refcnt;    // Основной счетчик ссылок
            uint16_t ob_overflow;  // Переполнение refcnt
            uint16_t ob_flags;     // Флаги объекта
# endif
        };
#else
        Py_ssize_t ob_refcnt;          // Простой счетчик ссылок
#endif
    };
    PyTypeObject *ob_type;             // Указатель на тип объекта
};
```

Каждый Python-объект в памяти начинается с "шапки" — счетчика ссылок (сколько мест держит ссылку
на объект) и указателя на его тип. Это как паспорт объекта: "кто я и сколько на меня ссылок". Любая конкретная
структура (число, строка, список) начинается с этой шапки, а потом идут свои поля. Благодаря этому любой указатель на
объект можно безопасно привести к `PyObject*` — первые байты всегда одинаковые.

## PyTypeObject — сердце наследования

Типы в CPython — это объекты `PyTypeObject`, которые содержат слоты (vtable) для методов. Наследование — это копирование
и переопределение этих слотов.

```c
// Objects/typeobject.c: фрагмент инициализации типа
typedef struct {
    int slot;              // Номер слота (tp_new, tp_call и т.д.)
    void *pfunc;           // Указатель на C-функцию
} PyType_Slot;

// PyTypeObject содержит сотни таких слотов
// Ключевые для наследования:
PyTypeObject {
    PyObject_HEAD           // Наследует от PyObject
    Py_ssize_t tp_basicsize; // Размер базовой части объекта
    Py_ssize_t tp_itemsize;  // Размер для VarObject
    unsigned long tp_flags;  // Флаги типа
    PyObject *tp_bases;      // Кортеж базовых классов (!!!)
    PyObject *tp_base;       // Прямой базовый класс
    PyObject *tp_dict;       // Словарь атрибутов типа
    PyObject *tp_mro;        // Method Resolution Order
    // ... сотни слотов методов: tp_new, tp_init, tp_call ...
};
```

`PyTypeObject` — это "рецепт" для создания объектов определенного типа. Он хранит список базовых
классов (`tp_bases`) и порядок поиска методов (`tp_mro`). Когда создается новый класс, CPython копирует слоты из
родителей, разрешает конфликты по MRO и создает новый тип. Это не C++ наследование — это ручное копирование таблиц
методов.

## Инициализация наследования в PyType_Ready()

Функция `PyType_Ready()` вычисляет MRO, наследует слоты и подготавливает тип. Вот ключевой фрагмент.

```c
// Objects/typeobject.c: упрощенный фрагмент PyType_Ready()
static int
type_ready(PyTypeObject *type) {
    // 1. Берем базовые классы
    PyObject *bases = lookup_tp_bases(type);  // Кортеж родителей
    
    // 2. Вычисляем MRO (порядок разрешения методов)
    if (type->tp_mro == NULL) {
        type->tp_mro = mro_internal(type);    // C3-линеаризация
        if (type->tp_mro == NULL) {
            return -1;
        }
    }
    
    // 3. Наследуем слоты методов от родителей
    for (Py_ssize_t i = 0; i < PyTuple_GET_SIZE(bases); i++) {
        PyTypeObject *base = PyTuple_GET_ITEM(bases, i);
        inherit_slots(type, base);            // Копируем слоты
    }
    
    // 4. Разрешаем конфликты по MRO
    resolve_slots(type);
    
    // 5. Устанавливаем флаги готовности
    type_add_flags(type, Py_TPFLAGS_READY);
    return 0;
}
```

При создании класса `PyType_Ready()` делает три вещи: 1) строит MRO (очередь "от кого наследовать
методы"), 2) копирует методы из родителей в свою таблицу слотов, 3) разрешает конфликты (если метод есть у нескольких
родителей — берет по приоритету MRO). После этого тип "готов" и объекты можно создавать.

## Композиция через указатели на типы

Композиция в CPython — это когда объект содержит указатели на другие типы, а не наследует их структуры. Пример:
`PyFloatObject`.

```c
// Objects/floatobject.c: Float содержит PyObject_HEAD + свои поля
typedef struct {
    PyObject_HEAD                // Наследование "слева"
    double ob_fval;              // Свое поле: значение double
} PyFloatObject;

// Использование: любой PyFloat* можно привести к PyObject*
PyFloatObject *f = ...;
PyObject *obj = (PyObject*)f;      // Безопасно!
PyTypeObject *type = obj->ob_type; // Получаем тип float
```

Композиция — это "имеет-a": float "имеет" PyObject в начале + double. Наследование — "является-a":
любой float "является" PyObject. В памяти это одно и то же — первые байты всегда PyObject. Разница в семантике:
наследование дает слоты методов автоматически, композиция — требует явных вызовов.

## MRO (Method Resolution Order) — C3 алгоритм

MRO решает, чей метод вызывать при множественном наследовании. Вычисляется рекурсивно.

```c
// Objects/typeobject.c: упрощенный mro_internal()
static PyObject *
mro_internal(PyTypeObject *type) {
    PyObject *bases = type->tp_bases;     // Список родителей
    PyObject *seqs = PyTuple_New(1 + PyTuple_GET_SIZE(bases));
    
    // Собираем MRO всех родителей
    for (Py_ssize_t i = 0; i < PyTuple_GET_SIZE(bases); i++) {
        PyTypeObject *base = PyTuple_GET_ITEM(bases, i);
        PyObject *parent_mro = lookup_tp_mro(base);
        PyTuple_SET_ITEM(seqs, i+1, Py_NewRef(parent_mro));
    }
    
    // C3-линеаризация: решает порядок с учетом приоритетов
    PyObject *mro = merge_mros(seqs);     // Алгоритм C3
    return mro;
}
```

MRO — это "очередь родителей": сначала сам класс, потом родители слева направо, исключая уже
использованных. Алгоритм C3 гарантирует, что родители сохраняют свой порядок. При вызове метода CPython идет по этой
очереди до первого совпадения: `type->tp_call`, `base1->tp_call`, `base2->tp_call`....

## __slots__ и ограничения множественного наследования

`__slots__` конфликтует с наследованием из-за фиксированных смещений в памяти.

```c
// Objects/typeobject.c: проверка слотов при наследовании
static int
check_slots(PyTypeObject *type) {
    // Если несколько родителей с __slots__, layouts конфликтуют
    for (Py_ssize_t i = 0; i < PyTuple_GET_SIZE(type->tp_bases); i++) {
        PyTypeObject *base = PyTuple_GET_ITEM(type->tp_bases, i);
        if (base->tp_dictoffset && type->tp_dictoffset &&
            base->tp_dictoffset != type->tp_dictoffset) {
            PyErr_SetString(PyExc_TypeError,
                "multiple parents with conflicting __slots__");
            return -1;
        }
    }
    return 0;
}
```

`__slots__` фиксирует места атрибутов в памяти (экономит память, убирает `__dict__`). При
наследовании смещения должны совпадать, иначе дескрипторы слотов "смотрят не туда". Композиция решает проблему — просто
держишь объект внутри без наследования структур.

## Кэш атрибутов и версии типов

CPython кэширует поиск атрибутов через `tp_version_tag`. Изменение базовых классов инвалидирует кэш рекурсивно.

```c
// Objects/typeobject.c: инвалидация при изменении иерархии
void PyType_Modified(PyTypeObject *type) {
    BEGIN_TYPE_LOCK();                    // Глобальная блокировка типов
    type_modified_unlocked(type);         // Рекурсивно по подклассам
    END_TYPE_LOCK();
}

static void type_modified_unlocked(PyTypeObject *type) {
    // Сбрасываем версию кэша
    set_version_unlocked(type, 0);
    
    // Рекурсивно инвалидируем подклассы
    PyObject *subclasses = lookup_tp_subclasses(type);
    for each subclass in subclasses {
        type_modified_unlocked(subclass);
    }
}
```

Каждый тип имеет "версию". При поиске `obj.x` CPython проверяет кэш по версии типа. Изменение
родителей → смена версии → инвалидация кэша для всего поддерева. Это дорого, поэтому наследование иерархий в runtime —
редкость.

## Итоговое сравнение под капотом

| Аспект        | Наследование                  | Композиция                          |
|---------------|-------------------------------|-------------------------------------|
| **Память**    | PyObject_HEAD + поля          | PyObject_HEAD + указатель на объект |
| **Методы**    | Автокопирование слотов по MRO | Ручной вызов `self.child.method()`  |
| **Атрибуты**  | Поиск по MRO, кэш с версиями  | Прямой доступ через указатель       |
| **Slots**     | Конфликты layouts             | Нет проблем                         |
| **Изменение** | Инвалидация всего поддерева   | Локальное                           |

Наследование быстрее для статичных иерархий (автоматическое копирование слотов), композиция гибче (без конфликтов
слотов, локальные изменения).

- [Содержание](/CONTENTS.md#содержание)