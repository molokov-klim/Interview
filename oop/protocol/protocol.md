# **Protocol**

## **Junior Level*

Представьте, что вы описываете не конкретный предмет, а его роль. Например, "то, что можно включить". Под это описание
подходит и лампа, и компьютер, и телевизор — у всех есть кнопка "включить". Вам неважно, что это за устройство внутри;
важно, что оно поддерживает операцию "включения".

В Python **Протокол (Protocol)** — это именно такое формальное описание роли или поведения. Он говорит: "Если у объекта
есть вот такие методы и атрибуты, то он автоматически считается подходящим для определенной цели, даже если он не был
изначально для этого предназначен". Это продвинутая, "официальная" версия принципа утиной типизации ("если ходит как
утка и крякает как утка, то это утка"). В отличие от Abstract Base Class (ABC), где класс должен явно заявить "я
наследуюсь от этого чертежа", протокол работает на уровне "если ты имеешь эти черты, то ты соответствуешь".

[Содержание](/CONTENTS.md#содержание)

## **Middle Level**

Технически `Protocol` — это конструкция системы типизации, определенная в PEP 544 и доступная в модуле `typing`. Его
ключевые аспекты:

1. **Структурная, а не номинативная типизация:** Класс соответствует протоколу, если его **структура** (набор методов и
   атрибутов с правильными сигнатурами) совпадает с протоколом. Ему не нужно явно наследоваться от протокола. Это
   фундаментальное отличие от ABC, где требуется явное номинативное объявление (наследование или регистрация).

2. **Синтаксис и `@runtime_checkable`:** Протокол определяется как класс, наследующийся от `typing.Protocol`. Его методы
   часто помечаются как абстрактные, используя `...` (ellipsis) в теле. По умолчанию протоколы используются **только
   статическими анализаторами типов** (mypy, pyright). Чтобы позволить проверку соответствия протоколу во время
   выполнения (`isinstance(obj, MyProtocol)`), протокол необходимо декорировать `@typing.runtime_checkable`. Однако
   такая проверка ограничена: она проверяет только **наличие** указанных атрибутов, но не их сигнатуры или типы.

3. **Generic и вариативность:** Протоколы могут быть параметризованы (Generic), что позволяет описывать типы, зависящие
   от других типов (например, `Iterable[T]`). Они также поддерживают ковариантность и контравариантность через параметры
   `covariant=True`/`contravariant=True`, что критично для точного описания отношений между сложными типами.

4. **Встроенные протоколы:** Модуль `typing` и `collections.abc` предоставляют множество встроенных протоколов:
   `SupportsInt`, `SupportsBytes`, `ContextManager`, `Iterable`, `Sized` и др. Их использование в аннотациях делает код
   гораздо более выразительным и безопасным.

[Содержание](/CONTENTS.md#содержание)

## **Senior Level**

`Protocol` в CPython — это чистый Python‑код в `Lib/typing.py`: специальный базовый класс c метаклассом
`typing._ProtocolMeta`, который помечает класс как протокольный (структурный) и запоминает множество его членов для
рантайм‑проверок `isinstance`/`issubclass` при включённом `@runtime_checkable`. Никакой спецподдержки в байткоде или
интерпретаторе нет, всё на уровне обычных классов/метаклассов.

## Базовая реализация Protocol в typing.py

В `Lib/typing.py` `Protocol` определён примерно так (упрощённо):

- Класс `Protocol` наследует от `Generic` и использует `_ProtocolMeta` как метакласс:

  ```python
  class Protocol(metaclass=_ProtocolMeta):
      pass
  ```

- `_ProtocolMeta` сам наследует от `abc.ABCMeta` (или `type` в старых версиях), переопределяя `__instancecheck__`/
  `__subclasscheck__` и `__new__`.
- При создании класса‑протокола `class P(Protocol): ...` управление идёт в `_ProtocolMeta.__new__`.

`_ProtocolMeta.__new__(mcls, name, bases, namespace, **kwargs)` делает:

1. Создаёт класс через базовый метакласс (`abc.ABCMeta.__new__`/`type.__new__`).
2. Помечает класс как протокол, устанавливая флаги:

    - `cls._is_protocol = True`;
    - `cls.__protocol_attrs__ = frozenset(<имена членов>)`.

3. Список протокольных членов вычисляется сбором всех атрибутов, объявленных в теле класса и его базовых протоколах,
   исключая служебные (`__mro__`, `__dict__` и т.п.).

Это всё — обычный Python‑метакласс: `class` компилируется как вызов `ProtocolMeta.__new__`/`__init__`, как и для любого
метакласса.

## Сбор членов протокола

Внутри `_ProtocolMeta.__new__` используется helper вроде `_get_protocol_attrs(cls)`:

- Берётся `cls.__dict__` и `__mro__` (кроме `Protocol` и `Generic`).
- Отбираются имена, у которых:
    - нет префикса `'__'` или явно разрешены (`__call__` и т.п.);
    - значение не является `typing.ClassVar`/`Final` и не помечено как приватное.
- Результат — `frozenset({'method1', 'attr2', ...})` — это интерфейс протокола.

Это множество не используется интерпретатором, а нужно только для `@runtime_checkable` и утилит
`typing_extensions.get_protocol_members`.

## runtime_checkable и __instancecheck__/__subclasscheck__

По умолчанию `Protocol` **не** должен использоваться с `isinstance`/`issubclass` — это только для статического анализа.
Декоратор `@typing.runtime_checkable` меняет поведение:

- `runtime_checkable(proto_cls)` оборачивает класс, проверяет, что это протокол (`_is_protocol=True`), и ставит ему флаг
  `_is_runtime_protocol = True`.

`_ProtocolMeta.__instancecheck__(cls, obj)` реализует:

1. Если `not getattr(cls, "_is_runtime_protocol", False)` — вызывает обычный `abc.ABCMeta.__instancecheck__` (по
   наследованию) → `False`/`TypeError`.
2. Иначе проверяет объект структурно:

    - Для каждого имени в `cls.__protocol_attrs__`:
        - через `getattr(obj, name, _marker)` проверяет наличие;
        - для методов/функций — только наличие, без точной проверки сигнатур на рантайме.

3. Если все имена есть → `True`, иначе `False`.

`_ProtocolMeta.__subclasscheck__(cls, sub)` для runtime‑протоколов делает аналогичный анализ по `dir(sub)`/MRO, но опять
же полностью в `typing.py`, без участия VM.

Сам `isinstance(x, P)` в VM вызывает `PyObject_IsInstance` → `cls.__instancecheck__`, т.е. всё поведение под контролем
`_ProtocolMeta`.

## Generic Protocol и параметры типов

`Protocol` часто комбинируется с `Generic`:

```python
class P(Protocol[T]):
    def f(self, x: T) -> T: ...
```

На уровне реализации:

- `Protocol` наследует от `Generic`, а `_ProtocolMeta` наследует от `typing._GenericAlias`‑совместимого метакласса,
  поэтому `P[int]` создаёт `typing._GenericAlias(P, (int,))`.
- При `P[int]` вызывается `Protocol.__class_getitem__`, унаследованный от `Generic`, который создаёт alias‑объект и не
  меняет поведение рантайм‑проверок; параметры типов хранятся в `__args__`/`__origin__` alias’а.

Для рантайма это всего лишь ещё один generic alias, без логики в байткоде.

## Ограничения на конструктор и наследование

`_ProtocolMeta.__call__` *не* запрещает инстанцирование протоколов (в отличие от `ABCMeta`) — протоколы используются как
обычные классы, но для статического анализа важен только их интерфейс.

Однако `typing` накладывает ограничения при наследовании/параметризации:

- В `Protocol.__mro__` не допускаются конфликтующие базы (миксы с обычными классами, не основанными на Protocol) —
  `typing` проверяет это в `__init_subclass__`/`_check_protocol`.
- При субскрипции (`Protocol[...]`) `_ProtocolMeta.__getitem__` проверяет, что все параметры — `TypeVar` (для объявления
  generic‑протокола), а не конкретные типы.

Эти проверки — обычные Python‑вычисления в `typing.py`, без участия VM.

## typing_extensions.Protocol

В старых версиях CPython большинство логики протоколов жило в `typing_extensions.Protocol`, а позже мигрировало в stdlib
`typing.Protocol`.

- `typing_extensions.Protocol` имеет свой metaclass `_ProtocolMeta` с почти идентичным кодом (иногда даже бэкпортит
  патчи из будущих версий CPython, например поведение `__init__` в 3.11).
- Реальный рантайм‑поведение зависит от того, какой именно класс стоит в MRO (stdlib vs extensions); при смешивании
  обоих в MRO возможны несостыковки, но это всё решается в чистом Python‑коде, без изменений интерпретатора.

***

Итого, `Protocol` в CPython — это обычные Python‑классы с метаклассом `_ProtocolMeta`, который при создании класса
собирает множество имён членов и, при `@runtime_checkable`, реализует структурные `isinstance`/`issubclass` через
переопределение `__instancecheck__`/`__subclasscheck__`. Никакого спецбайткода, дополнительных флагов в `PyTypeObject`
или логики в `ceval.c` под протоколы нет.

- [Содержание](/CONTENTS.md#содержание)