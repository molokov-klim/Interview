# **Композиция и агрегация**

## **Junior Level*

Композиция и агрегация — это два способа создания отношений между объектами в объектно-ориентированном программировании.
Обе описывают ситуацию, когда один объект содержит в себе другой, но с критически важным различием в силе связи и
управлении жизненным циклом.

Представьте, что вы строите дом. **Композиция** — это как комната в доме. Комната не существует отдельно от дома. Когда
дом сносят, комната исчезает вместе с ним. Объект-владелец (дом) полностью контролирует жизнь объекта-части (комнаты). *
*Агрегация** — это как мебель в доме. Стол, стул, диван существуют независимо от дома. Их занесли в дом, а потом могут
вынести в другой дом или на склад. Объект-владелец (дом) использует объект-часть (мебель), но не управляет его рождением
и смертью.

В разработке композиция означает, что при уничтожении основного объекта уничтожаются и все его составные части.
Агрегация означает, что объекты собраны вместе, но могут жить самостоятельно. Для QA инженера понимание этого различия
помогает проектировать тестовые фикстуры и моки, правильно управлять их жизненным циклом и понимать, какие зависимости
нужно создавать заново, а какие можно переиспользовать между тестами.

[Содержание](/CONTENTS.md#содержание)

## **Middle Level**

С технической точки зрения, композиция и агрегация реализуются через **атрибуты класса**, но с разной семантикой
создания и владения.

1. **Реализация:**
    * **Композиция (Composition):** Объект-часть создается **внутри** конструктора (или иного метода) объекта-владельца.
      Владелец полностью инкапсулирует создание и, как правило, не предоставляет публичных методов для замены этой
      части. Часть реализуется как внутренний, приватный атрибут.
    * **Агрегация (Aggregation):** Объект-часть создается **вне** объекта-владельца и передается ему в качестве
      аргумента (чаще всего в конструктор). Владелец сохраняет ссылку на эту часть, но не управляет ее созданием.
      Объект-часть может быть общим (разделяемым) ресурсом.

2. **Жизненный цикл:**
    * При **композиции** жизненный цикл части жестко привязан к жизненному циклу целого. Когда объект-владелец
      удаляется (например, сборщиком мусора), удаляется и объект-часть, если на него больше нет ссылок.
    * При **агрегации** жизненные циклы независимы. Удаление владельца не влечет удаление части, так как на нее могут
      оставаться ссылки из других объектов.

3. **Для AQA:**
    * **Фикстуры в Pytest:** Композиция часто используется для создания сложных, вложенных фикстур, которые существуют
      только в рамках одной тестовой сессии или модуля и автоматически очищаются. Агрегация похожа на фикстуры с
      областью видимости `session` или `package`, которые создаются один раз и переиспользуются многими тестами.
    * **Тестовые данные:** Понимание, когда создавать новый экземпляр тестовых данных для каждого кейса (композиция), а
      когда использовать общий, предсозданный набор данных (агрегация), критично для скорости и изоляции тестов.
    * **Page Object:** Внутри Page Object может существовать композиция из элементов (например, `Button`, `InputField`),
      которые не имеют смысла вне контекста этой страницы. И агрегация — например, общий `Header` или `Footer`, которые
      могут быть переданы в несколько Page Object.

4. **Отличия от наследования:** И композиция, и агрегация — это альтернативы наследованию, предпочитаемые в современном
   дизайне ("предпочитай композицию наследованию"). Они обеспечивают большую гибкость и слабую связанность.

[Содержание](/CONTENTS.md#содержание)

## **Senior Level**

## Базовые структуры композиции в CPython

Композиция в CPython реализуется через **встраивание структур** (embedding) — `PyObject_HEAD` + поля + другие
`PyObject`. Агрегация — через **указатели** на объекты. Разница в управлении памятью и временем жизни.

```c
// Include/object.h: базовые макросы для композиции
#define PyObject_HEAD                   PyObject ob_base;  // Шапка: refcnt + type
#define PyObject_VAR_HEAD               PyVarObject ob_base; // Шапка + размер

struct _object {                       // PyObject — минимальный объект
    union {                            // Счетчик ссылок (refcnt)
#if SIZEOF_VOID_P > 4
        PY_INT64_T ob_refcnt_full;     // 64-битный refcnt
        struct {
# if PY_BIG_ENDIAN
            uint16_t ob_flags;         // Флаги объекта
            uint16_t ob_overflow;      // Переполнение refcnt
            uint32_t ob_refcnt;        // Основной refcnt
# else
            uint32_t ob_refcnt;        // Основной refcnt
            uint16_t ob_overflow;      // Переполнение refcnt
            uint16_t ob_flags;         // Флаги объекта
# endif
        };
#else
        Py_ssize_t ob_refcnt;          // 32-битный refcnt
#endif
    };
    PyTypeObject *ob_type;             // Указатель на тип (vtable)
};
```

`PyObject_HEAD` — это **обязательная "шапка"** в начале **каждого** Python-объекта (8-16 байт). Она содержит: 1) *
*refcnt** (сколько ссылок держит объект живым), 2) **ob_type** (указатель на таблицу методов типа). Любая структура типа
начинается с этой шапки. Композиция = шапка + свои поля + другие шапки.

## Пример композиции: PyTupleObject (строгая композиция)

Кортеж содержит **встроенный массив PyObject*** — классическая композиция "имеет-A".

```c
// Include/tupleobject.h + Objects/tupleobject.c
typedef struct {
    PyObject_VAR_HEAD                // Шапка PyObject + ob_size (кол-во элементов)
    PyObject *ob_item[1];            // Массив объектов (гибкий размер!)
} PyTupleObject;

// Реальная структура в памяти: PyObject_HEAD + Py_ssize_t ob_size + PyObject** об_item
// Размер выделяется: sizeof(PyTupleObject) + (size-1)*sizeof(PyObject*)
```

Кортеж `(1, "a", [])` в памяти — **один большой блок**: шапка кортежа + число элементов (3) + **3 указателя** на объекты
1, "a", []. Это **композиция**: кортеж **владеет** массивом указателей. Когда refcnt кортежа → 0, **все указатели
остаются жить** (их refcnt не трогаем).

## Пример агрегации: PyDictObject (слабая композиция)

Словарь содержит **указатели** на хэш-таблицу PyDictKeysObject — агрегация.

```c
// Objects/dictobject.c: PyDictObject (Python 3.9+)
typedef struct {
    PyObject_HEAD                    // Шапка словаря
    Py_ssize_t ma_used;              // Кол-во используемых слотов
    PyDictKeysObject *ma_keys;       // УКАЗАТЕЛЬ на отдельный объект ключей!!!
    PyObject **ma_values;            // Указатель на массив значений (опционально)
} PyDictObject;

typedef struct {
    Py_ssize_t dk_size;              // Размер хэш-таблицы
    PyDictUnicodeEntry *dk_entries;  // Массив записей (ключ+хэш)
    vectorcallfunc vectorcall;       // Методы для vectorcall
} PyDictKeysObject;
```

Словарь `{"a": 1}` — **два объекта**: 1) PyDictObject (шапка + указатель на ключи), 2) PyDictKeysObject (отдельная
хэш-таблица). Это **агрегация**: словарь **ссылается** на таблицу ключей, но **не владеет** ею. Таблица ключей может
использоваться **несколькими** словарями (shared keys optimization).

## Создание составных объектов: PyTuple_New()

Композиция создается **атомарно** — выделяется память под всю структуру сразу.

```c
// Objects/tupleobject.c: PyTuple_New()
PyObject *
PyTuple_New(Py_ssize_t size) {
    PyTupleObject *op;                 // Указатель на новый кортеж
    Py_ssize_t nbytes;                 // Общий размер в байтах
    
    if (size < 0) {                    // Проверка отрицательного размера
        PyErr_BadInternalCall();
        return NULL;
    }
    
    // Вычисляем размер: шапка + (size-1)*sizeof(PyObject*)
    nbytes = size * sizeof(PyObject *) + sizeof(PyTupleObject) - sizeof(PyObject *);
    
    // Выделяем память атомарно
    op = PyObject_GC_NewVar(PyTupleObject, &PyTuple_Type, size);
    if (op == NULL)                    // Ошибка выделения
        return NULL;
        
    // Инициализируем все указатели NULL (zero-filling)
    for (Py_ssize_t i = 0; i < size; i++)
        op->ob_item[i] = NULL;         // Каждый слот = NULL
    
    PyObject_GC_Track(op);             // Регистрируем в GC
    return (PyObject *) op;
}
```

`tuple(1,2,3)` → CPython **одним malloc()** выделяет **весь блок** (шапка + 3 указателя). Потом заполняет указатели
PyLong(1), PyLong(2), PyLong(3). **Композиция = единый блок памяти**. Когда refcnt → 0, **один free()** освобождает
всё.

## Разница в деструкторах: tp_dealloc

Композиция освобождает **свои** поля, агрегация — **НЕ трогает** подчиненные объекты.

```c
// Objects/tupleobject.c: tp_dealloc для PyTuple_Type
static void
tuple_dealloc(PyTupleObject *op) {
    Py_ssize_t len = Py_SIZE(op);      // Длина кортежа
    PyObject **items = op->ob_item;    // Указатель на массив
    
    PyObject_GC_UnTrack(op);           // Убираем из GC
    Py_TRASHCAN_SAFE_BEGIN(op)         // Защита от рекурсии
    
    // НЕ освобождаем ob_item[i]! Это агрегированные объекты
    // Просто обнуляем указатели (для отладки)
    while (--len >= 0) {
        Py_CLEAR(items[len]);          // Снижаем refcnt элементов
    }
    
    Py_TYPE(op)->tp_free((PyObject*)op); // free() всей структуры
    Py_TRASHCAN_SAFE_END(op)
}
```

Кортеж умирает → **НЕ трогает** содержимое (1,2,3 живут дальше), только **снижает их refcnt** и **освобождает свой блок
**. Словарь при смерти **НЕ трогает** ma_keys (агрегация). **Композиция** бы трогала встроенные объекты.

## __slots__ как экстремальная композиция

`__slots__` создает **фиксированную композицию** без `__dict__` — экономит память.

```c
// Objects/typeobject.c: обработка __slots__ в PyType_Ready()
static int
slotptr_cmp(PyObject *slot1, PyObject *slot2) {
    // Сортируем слоты по алфавиту для детерминизма
    return PyUnicode_Compare(slot1, slot2);
}

static PyObject *
collect_slots(PyTypeObject *type) {
    PyObject *slots = PyObject_GetAttrString((PyObject*)type, "__slots__");
    if (!slots) return NULL;
    
    // Сортируем и вычисляем смещения атрибутов
    Py_ssize_t nslots = PyList_GET_SIZE(slots);
    for (Py_ssize_t i = 0; i < nslots; i++) {
        PyObject *name = PyList_GET_ITEM(slots, i);
        PyMemberDef *member = create_member(name);  // Создаем дескриптор
        // member->offset = смещение в памяти экземпляра
    }
    
    type->tp_basicsize += nslots * sizeof(PyObject*); // Фиксируем размер
    return slots;
}
```

`__slots__ = ['x', 'y']` → CPython создает **фиксированные поля** сразу после PyObject_HEAD:
`[PyObject_HEAD | PyObject* x | PyObject* y]`. **Нет `__dict__`**, нет хэш-таблицы. **Чистая композиция** с известным
layout'ом памяти.

## Сравнение композиции и агрегации под капотом

| Аспект          | Композиция (встраивание)   | Агрегация (указатели)            |
|-----------------|----------------------------|----------------------------------|
| **Память**      | Единый malloc/free         | Несколько malloc (dict + keys)   |
| **Время жизни** | Владелец управляет всем    | Подчиненные живут независимо     |
| **Размер**      | sizeof(HEAD) + поля + HEAD | sizeof(HEAD) + sizeof(PyObject*) |
| **GC**          | Рекурсивно все поля        | Только указатели (не владеет)    |
| **Shared**      | Невозможно                 | Возможно (dict keys)             |

**Композиция** = "встроить структуру целиком", **агрегация** = "указатель на чужой объект". В CPython **tuple =
композиция** (встроенный массив), **dict = агрегация** (отдельные keys/values).

- [Содержание](/CONTENTS.md#содержание)