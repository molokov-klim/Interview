================================================================================================================================

# Типы данных в Python

### Философия и общая характеристика

Python — язык с **динамической сильной типизацией**. Это означает:

1. **Динамическая типизация**: Тип переменной определяется в момент присваивания значения и может меняться в ходе
   выполнения программы.
2. **Сильная типизация**: Неявные преобразования типов ограничены, большинство операций проверяют совместимость типов и
   вызывают исключения при несоответствии (TypeError).
3. **Утиная типизация** (Duck typing): Фокус на поведении объекта, а не на его классе. "Если что-то ходит как утка и
   крякает как утка, то это утка".

Все в Python — объекты, и каждый объект имеет:

- **Идентификатор** (id) — уникальный адрес в памяти
- **Тип** (type) — определяет возможные операции и структуру данных
- **Значение** (value)

### Категории типов данных

#### 1. По изменяемости (Mutability)

**Неизменяемые (Immutable) типы**:

- Числа: `int`, `float`, `complex`
- Последовательности: `str`, `tuple`, `bytes`, `frozenset`
- Специальный: `NoneType` (объект None), `bool`

**Изменяемые (Mutable) типы**:

- Коллекции: `list`, `dict`, `set`, `bytearray`
- Пользовательские классы (по умолчанию)
- Прочие: `array`, `deque`, `Counter` и т.д.

**Ключевое различие**: При изменении неизменяемого объекта создается новый объект, а изменяемый объект модифицируется на
месте.

#### Общая структура объектов (CPython)

Каждый объект в CPython начинается с двух заголовочных полей:

1. **`PyObject_HEAD`**:
    - `Py_ssize_t ob_refcnt` — счетчик ссылок (для управления памятью)
    - `PyTypeObject *ob_type` — указатель на объект-тип

2. **`PyObject_VAR_HEAD`** (для объектов переменной длины):
    - Заголовок PyObject_HEAD
    - `Py_ssize_t ob_size` — количество элементов

#### Особенности конкретных типов

**Целые числа (int)**:

- До Python 3: разделение на `int` и `long`
- С Python 3: единый тип `int` произвольной точности
- Маленькие числа (-5 до 256) кэшируются (синглтоны)
- Внутреннее представление — массив "цифр" (обычно 30-битных) в системе счисления base=2³⁰
- Операции: быстрые для маленьких чисел, медленные для больших

**Числа с плавающей точкой (float)**:

- Реализация через С-тип `double` (IEEE 754, 64 бита)
- Особенности: неточности представления, `float('nan')`, `float('inf')`

**Строки (str)**:

- Unicode-строки (начиная с Python 3)
- Кодировка по умолчанию: UTF-8 (внутренне может использовать Latin-1, UCS-2, UCS-4 в зависимости от содержимого)

**Списки (list)**:

- Динамический массив (не связный список!)
- Стратегия роста: при заполнении выделяется новый массив большего размера (обычно на ~12.5%)
- Амортизированная сложность O(1) для append
- Внутренне: массив указателей на Python-объекты

**Словари (dict)**:

- Хэш-таблица с открытой адресацией
- Компактное представление (с Python 3.6): два массива — индексы и записи
- Коэффициент заполнения: ~2/3, затем рехэширование
- Сохранение порядка вставки (с Python 3.7)

**Кортежи (tuple)**:

- Неизменяемые списки
- Кэшируются при создании (если содержат только неизменяемые элементы)
- Могут использоваться как ключи словаря (если все элементы хэшируемы)

### Система типов и метатипы

**type** — это метакласс, экземплярами которого являются сами классы:

- `type(obj)` возвращает класс объекта
- `type(type)` возвращает `type` (сам на себя)

**Иерархия наследования**:
Все классы наследуются от `object` (прямо или косвенно)

```
object
├── type (метакласс)
├── BaseException
├── int, float, str, list, dict, tuple, set, ...
└── пользовательские классы
```

## Лучшие практики

1. Используйте кортежи для констант, списки для изменяемых данных
2. Проверяйте типы через isinstance(), а не type()
3. Применяйте type hints для документирования и статического анализа
4. Для поиска элементов используйте множества (O(1) вместо O(n))
5. Избегайте квадратичных операций со строками, используйте join()

================================================================================================================================

# *args и **kwargs в Python

`*args` и `**kwargs` — это специальные синтаксические конструкции в Python, которые позволяют функциям принимать
произвольное количество аргументов. Это ключевой механизм для создания гибких и универсальных функций, декораторов,
классов и других конструкций.

## Синтаксис и базовое назначение

- `*args` (арги) — собирает **позиционные аргументы** в кортеж (tuple)
- `**kwargs` (кварги) — собирает **именованные (ключевые) аргументы** в словарь (dict)

Названия `args` и `kwargs` — это конвенция, но не требование языка. Важны именно символы `*` и `**`.

## Механизм работы "под капотом"

### 1. Распаковка (Unpacking) и упаковка (Packing)

Фундаментально, `*` и `**` — это операторы распаковки/упаковки:

- **При определении функции** (`def func(*args, **kwargs)`) — это **упаковка** (packing)
- **При вызове функции** (`func(*iterable, **dict)`) — это **распаковка** (unpacking)

### 2. Компиляция и байт-код

Когда Python компилирует функцию с `*args` или `**kwargs`:

1. **Аргументы по умолчанию** обрабатываются первыми и сохраняются в `__defaults__` или `__kwdefaults__`
2. **`*args`** создает специальный слот в объекте кода функции, который указывает, что все "лишние" позиционные
   аргументы должны быть собраны в кортеж
3. **`**kwargs`** создает слот для сбора лишних ключевых аргументов в словарь
4. В байт-коде это реализуется через инструкции:
    - `LOAD_FAST` для обычных аргументов
    - `BUILD_TUPLE` для `*args`
    - `BUILD_MAP` для `**kwargs`

### 3. Порядок аргументов в сигнатуре функции

Строгий порядок в определении функции (после Python 3):

1. Позиционные аргументы (обычные)
2. `*args` (собирает оставшиеся позиционные)
3. Аргументы, доступные только по ключу (keyword-only arguments)
4. `**kwargs` (собирает оставшиеся именованные)

Пример: `def func(a, b, *args, c, d=10, **kwargs)`

## Детали реализации

### Для `*args`:

1. **Тип данных**: Всегда `tuple` (неизменяемая последовательность)
2. **Расположение в памяти**: При вызове функции Python создает новый кортеж, даже если передан пустой набор аргументов
3. **Итерация**: Поскольку это кортеж, итерация по нему происходит быстрее, чем по списку
4. **Важно**: `*args` всегда создает **поверхностную копию** переданных аргументов

### Для `**kwargs`:

1. **Тип данных**: Всегда `dict`
2. **Ключи**: Должны быть строками (string), так как имена параметров в Python — всегда строки
3. **Порядок**: До Python 3.6 порядок ключей не сохранялся, с Python 3.7+ порядок соответствует порядку передачи (
   благодаря новой реализации dict)
4. **Хэширование**: Все ключи проходят через встроенную функцию `hash()` для быстрого поиска

## Особенности и нюансы

### 1. Взаимодействие с декораторами

`*args` и `**kwargs` — основа большинства декораторов:

```python
def decorator(func):
    def wrapper(*args, **kwargs):
        # что-то делаем до вызова
        result = func(*args, **kwargs)  # распаковка аргументов
        # что-то делаем после вызова
        return result

    return wrapper
```

Это позволяет декоратору работать с любой функцией, независимо от её сигнатуры.

### 2. Метаклассы и наследование

При наследовании классов, метод `__init_subclass__` получает `**kwargs`, содержащий все ключевые аргументы, переданные
при определении класса. Это используется для регистрации подклассов, конфигурирования и т.д.

### 3. Функции высшего порядка

Функции, которые принимают другие функции как аргументы (например, `map`, `filter`, декораторы), часто используют
`*args` и `**kwargs` для передачи аргументов оборачиваемой функции.

### 4. Переопределение методов

При переопределении методов в классах-наследниках часто используется `super().__init__(*args, **kwargs)` для передачи
всех аргументов родительскому классу без явного их перечисления.

## Специальные случаи и продвинутые техники

### 1. Аргументы, доступные только по ключу (keyword-only arguments)

После `*args` (или просто звездочки `*`) в сигнатуре функции все последующие аргументы становятся доступными только по
ключу:

```python
def func(a, b, *, c, d):  # c и d — keyword-only
    pass
```

Это полезно для повышения читаемости кода и предотвращения ошибок.

### 2. Аннотации типов с `*args` и `**kwargs`

В Python 3.5+ появилась поддержка аннотаций:

```python
from typing import Any


def func(*args: Any, **kwargs: Any) -> None:
    pass
```

Более точные аннотации:

```python
from typing import Union


def func(*args: Union[int, str], **kwargs: str) -> None:
    pass
```

### 3. `inspect` модуль

Модуль `inspect` позволяет анализировать сигнатуры функций:

```python
import inspect

sig = inspect.signature(func)
params = sig.parameters
```

Это используется в фреймворках типа FastAPI для автоматического парсинга аргументов, в тестовых фреймворках для фикстур
и т.д.

### 4. Производительность

- **Накладные расходы**: Использование `*args` и `**kwargs` добавляет небольшие накладные расходы на создание
  кортежа/словаря
- **Оптимизация**: Для критичных к производительности мест лучше использовать фиксированное количество аргументов
- **Кэширование аргументов**: В CPython есть оптимизации для кэширования объектов кортежей и словарей, что уменьшает
  overhead при частых вызовах

## Ограничения и потенциальные проблемы

1. **Потеря информации о сигнатуре**: Функции с `*args, **kwargs` скрывают свою реальную сигнатуру, что усложняет
   интроспекцию и автодополнение в IDE
2. **Ошибки типов**: Статические анализаторы типов (mypy) могут не всегда корректно проверять такие функции
3. **Безопасность**: При использовании `**kwargs` для передачи в другие функции (например, в ORM-запросы) нужно быть
   осторожным с инъекциями
4. **Читаемость**: Чрезмерное использование ухудшает читаемость и понимание кода

## Лучшие практики

1. **Документировать ожидаемые аргументы** в docstring, даже если используется `*args/**kwargs`
2. **Валидировать критические аргументы** внутри функции
3. **Использовать аннотации типов** для улучшения статического анализа
4. **Предпочитать явные аргументы**, когда сигнатура стабильна и известна
5. **Резервировать `*args/**kwargs`** для действительно универсальных случаев или для передачи в обернутые функции

================================================================================================================================

# Хеш-таблица

Хэш-таблица (hash table) — это фундаментальная структура данных, реализующая абстрактный тип данных «ассоциативный
массив» (или «словарь»). Она позволяет хранить пары «ключ-значение» и обеспечивает в среднем константное время O(1) для
операций вставки, удаления и поиска, что делает её одной из самых эффективных структур для этих задач.

В контексте Python хэш-таблицы являются «двигателем» для двух ключевых встроенных типов данных: `dict` (словарь) и
`set` (множество). Их внутренняя реализация глубоко оптимизирована и является одной из сильных сторон языка.

### Принцип работы (общая теория)

1. **Хэш-функция:** Ключ передаётся в хэш-функцию, которая преобразует его в целое число — хэш-код. Идеальная
   хэш-функция для хэш-таблицы должна быть детерминированной (один и тот же ключ всегда даёт один и тот же хэш), быстрой
   в вычислении и равномерно распределять ключи по диапазону возможных значений.
2. **Индексирование:** Полученный хэш-код (часто большое число) преобразуется в индекс слота (ячейки) в массиве
   фиксированного размера (хэш-таблице) с помощью операции, обычно это взятие остатка от деления на размер массива.
3. **Хранение:** По вычисленному индексу в массиве хранится значение (или ссылка на него). В случае Python, в слоте
   хранится не просто значение, а целая запись, содержащая и хэш ключа, и ссылку на ключ, и ссылку на значение.

### Реализация в Python «под капотом»

Python использует модифицированную версию алгоритма открытой адресации (open addressing), в частности, вариант,
известный как **«двойное хэширование»** (perturbation scheme).

#### 1. Хэш-функция и требование к ключам

* В Python за вызов хэш-функции отвечает встроенная функция `__hash__()`. Для любого объекта, который должен быть
  ключом (в `dict` или элементом `set`), должен быть реализован магический метод `__hash__()`.
* **Критическое требование:** Объект должен быть **неизменяемым** (в смысле хэшируемости) на протяжении всей жизни. Если
  хэш объекта изменится после того, как он был помещён в таблицу, он окажется в неверном слоте и станет недоступен.
  Поэтому неизменяемые типы (`int`, `float`, `str`, `tuple`, `frozenset`) хэшируемы, а изменяемые (`list`, `dict`,
  `set`) — нет (но есть исключения, например, пользовательские классы по умолчанию хэшируемы по их `id`).
* Метод `__eq__()` используется для проверки равенства ключей при разрешении коллизий. Связь между `__hash__` и `__eq__`
  строгая: равные объекты **обязаны** иметь равные хэши. Обратное неверно (коллизия хэшей не означает равенство
  объектов).

#### 2. Внутренняя структура словаря

Начиная с Python 3.6 (и официально с Python 3.7), словари сохраняют **порядок добавления элементов**. Это стало
возможным благодаря изменению внутренней организации.

* **Новая, компактная модель (3.6+):** Используются **два массива**.
    1. **`indices` (плотный):** Массив целых чисел (размером ~2/3 от размера хэш-таблицы). Это, по сути, индексы для
       второго массива. Исходный хэш ключа преобразуется в индекс именно в этом массиве. Значение в `indices[i]`
       указывает на слот во втором массиве.
    2. **`entries` (плотный):** Массив структур, хранящих ключ, значение и полный хэш ключа (для ускорения перебора и
       разрешения коллизий). Элементы добавляются в этот массив последовательно, что и обеспечивает сохранение порядка.

  **Процесс поиска:**
    1. Вычисляется хэш ключа.
    2. Берется младшие биты хэша для вычисления индекса `i` в массиве `indices`.
    3. По значению `indices[i]` находится запись в массиве `entries`.
    4. Если запись содержит наш ключ (проверка по хэшу и `__eq__`), возвращается её значение.
    5. Если нет (коллизия), запускается схема «возмущения» (perturb): старшие биты хэша используются для вычисления
       нового индекса, и процесс повторяется.

  **Преимущества новой модели:**
    * **Экономия памяти:** Массив `indices` хранит только инты, а все данные — в плотном массиве `entries`. Удаление не
      создает «дыр» (dummy entries) в основном хранилище.
    * **Локализация данных:** `entries` является плотным массивом, что дружественно к кэшу процессора при итерации.
    * **Сохранение порядка:** Плотный массив `entries` заполняется последовательно.

#### 3. Разрешение коллизий

Python использует **открытую адресацию (open addressing)** с «возмущением» (perturbation), что является формой двойного
хэширования. В отличие от метода цепочек (chaining), где в каждом слоте хранится список элементов, здесь при коллизии
алгоритм ищет следующий свободный слот в том же массиве `indices` по детерминированной схеме.

* При поиске или вставке, если вычисленный слот в `indices` занят другим ключом, значение хэша «возмущается» (сдвигается
  и комбинируется с исходным) для получения нового пробного индекса. Это повторяется до нахождения пустого слота (для
  вставки) или искомого ключа.
* Удаление элементов в такой схеме нетривиально. Просто очистить слот нельзя — это сломает цепочку проб для последующих
  ключей. Поэтому слот помечается специальным значением, что указывает алгоритму проб продолжать поиск при коллизиях.

#### 4. Динамическое изменение размера и фактор загрузки

* Для поддержания эффективности хэш-таблица должна оставаться разреженной. **Коэффициент загрузки (load factor)** — это
  отношение занятых слотов к общему количеству слотов.
* В Python коэффициент загрузки обычно поддерживается на уровне **~2/3**. Когда он превышен, происходит *
  *рехэширование (rehashing)**: выделяется новый массив `indices` большего размера (обычно в 2-4 раза), и все
  существующие записи пересчитываются и перемещаются в новую таблицу. Это дорогая операция O(n), но, будучи
  амортизированной по многим вставкам, она позволяет сохранять среднюю сложность O(1).

#### 5. Множества (set и frozenset)

* Внутренне `set` реализован почти так же, как `dict`, но без массива для значений. Каждая запись хранит только ключ (он
  же элемент множества) и его хэш. Многие оптимизации (компактная организация, разрешение коллизий) идентичны.

### Следует знать

1. **Производительность:** Понимание, что операции со словарями и множествами имеют **амортизированную O(1)**, критично
   для написания эффективного кода и тестов. Например, проверка принадлежности элемента множеству (`x in my_set`) — одна
   из самых быстрых операций.
2. **Порядок элементов:** Начиная с Python 3.7, порядок ключей в словаре гарантированно соответствует порядку вставки.
   Этим можно и нужно пользоваться в тестах, но важно помнить, что поведение в версиях до 3.6 иное.
3. **Хэшируемость:** При создании пользовательских классов, которые планируется использовать как ключи в словарях или
   элементы множеств, необходимо корректно определять `__hash__` и `__eq__`. Несоблюдение контракта между ними приведёт
   к некорректной работе структуры.
4. **Зависимость от хэш-функции:** В редких случаях возможны **атаки на отказ в обслуживании (HashDoS)**, когда
   злонамеренно подобранные ключи вызывают катастрофическое количество коллизий, деградируя производительность до O(n).
   Современные версии Python (с 3.3+) используют рандомизированную хэш-функцию для строк и некоторых других типов,
   которая активируется переменной окружения `PYTHONHASHSEED`, чтобы нивелировать эту угрозу.
5. **Отладка и профилирование:** Знание о рехэшировании помогает понять «пики» потребления памяти и времени при активной
   вставке элементов. Если конечный размер словаря известен заранее, его можно создать с помощью `dict.fromkeys()` или
   передав примерный размер в конструктор, чтобы избежать многократных дорогостоящих операций рехэширования.

## Лучшие практики

1. Только неизменяемые ключи - строки, числа, кортежи, frozenset
2. Используй .get() вместо [] для безопасного доступа, проверяй через in
3. Set для проверки наличия - O(1) вместо O(n) у списка
4. Сохраняй порядок вставки (Python 3.7+)
5. Инициализируй с размером если известен, избегай частого рехэширования

================================================================================================================================

# Встроенные функции в Python

## Определение

Встроенные функции (built-in functions) — это функции, которые доступны в Python без необходимости импорта каких-либо
модулей. Они являются частью ядра языка и предоставляют базовые операции для работы с данными, управления выполнением
программы, взаимодействия с интерпретатором и других задач. Эти функции включают в себя такие распространённые операции,
как вывод информации (`print()`), преобразование типов (`int()`, `str()`), работа с коллекциями (`len()`, `sum()`),
итерации (`range()`, `enumerate()`), а также более специализированные, например, для компиляции кода (`compile()`) или
доступа к системным настройкам (`locals()`, `globals()`).

## Внутренняя реализация (под капотом)

### Реализация в CPython

Большинство встроенных функций реализованы на языке C в исходном коде CPython (стандартной реализации Python). Они
находятся в файлах, таких как `Python/bltinmodule.c` и `Objects/` (для функций, связанных с конкретными типами данных).
Это обеспечивает высокую производительность, так как они выполняются на уровне интерпретатора, минуя накладные расходы
Python-кода. Например, функция `len()` для стандартных коллекций (списков, строк) обращается напрямую к полю структуры
объекта C, что выполняется за константное время O(1).

### Модуль `__builtins__`

Встроенные функции хранятся в модуле `__builtins__`, который автоматически загружается при запуске интерпретатора. Этот
модуль является частью пространства имён, и его содержимое доступно глобально в любой точке программы. При вызове
функции, например `abs()`, интерпретатор ищет её в `__builtins__` через механизм разрешения имён (LEGB — Local,
Enclosing, Global, Built-in).

### Оптимизации и связь с объектной моделью

Многие встроенные функции тесно интегрированы с объектной моделью Python. Например, `iter()` вызывает метод `__iter__`
объекта, а `next()` — метод `__next__`. Это позволяет функциям работать с любыми пользовательскими типами, реализующими
соответствующие протоколы. Некоторые функции, такие как `isinstance()` или `issubclass()`, напрямую взаимодействуют с
метаклассами и иерархией классов, проверяя отношения типов на уровне C-структур.

### Динамическая природа и интроспекция

Функции типа `type()`, `callable()` или `hasattr()` используют внутренние API Python для анализа объектов в runtime. Они
обращаются к метаданным объектов (например, к словарю `__dict__` или флагам типа), что позволяет реализовать
интроспекцию без необходимости компиляции.

## Особенности

### Производительность

Благодаря реализации на C, встроенные функции обычно выполняются быстрее, чем их аналоги, написанные на чистом Python.
Однако для сложных операций (например, `map()` или `filter()`) в современных версиях Python рекомендуется использовать
генераторы или списковые включения, которые могут быть более эффективными по памяти и читаемости.

### Неизменяемость и переопределение

Хотя встроенные функции изначально неизменяемы, их можно переопределить в локальной области видимости (например,
присвоить `len = my_function`), что считается антипаттерном, так как нарушает читаемость и может привести к ошибкам.
Важно избегать таких переопределений, особенно в больших проектах.

### Область видимости

Встроенные функции всегда доступны, даже если их имя было переопределено в глобальной или локальной области. Однако если
переопределение произошло, доступ к оригинальной функции возможен через импорт модуля `builtins` (например,
`import builtins; builtins.len`).

### Функции для метапрограммирования

Некоторые встроенные функции, такие как `eval()`, `exec()` и `compile()`, позволяют выполнять динамически генерируемый
код. Их использование требует осторожности из-за рисков безопасности (инъекции кода) и сложности отладки. В контексте
AQA их следует применять только в тестовых сценариях, где необходима динамическая генерация проверок.

### Интеграция с системой типов

Функции `isinstance()` и `issubclass()` поддерживают проверку против абстрактных базовых классов (ABC) из модуля
`collections.abc`, что способствует реализации контрактов типов (type hints) и улучшает надёжность кода.

## Лучшие практики

### Использование для улучшения читаемости

Встроенные функции делают код более лаконичным и выразительным. Например, `enumerate()` вместо ручного управления
индексом в цикле, или `zip()` для параллельной итерации. Это особенно важно в тестовом коде (AQA), где читаемость
напрямую влияет на поддержку тестов.

### Избегание излишней сложности

Хотя функции типа `map()` и `filter()` мощны, их часто заменяют на списковые включения (list comprehensions), которые
более понятны для простых преобразований. В тестах предпочтение отдаётся явным и простым конструкциям, чтобы
минимизировать риск ошибок.

### Безопасность при работе с динамическим кодом

При использовании `eval()` или `exec()` в тестовых фреймворках (например, для генерации параметризованных тестов)
необходимо валидировать входные данные и ограничивать контекст выполнения. Лучше использовать альтернативы, такие как
`ast.literal_eval()` для безопасного вычисления литералов.

### Тестирование встроенных функций

Хотя сами встроенные функции являются частью языка и обычно не требуют тестирования, в AQA-контексте важно проверять,
как они взаимодействуют с пользовательским кодом. Например, убедиться, что пользовательские классы корректно реализуют
протоколы для `len()` или `iter()`, используя модульное тестирование.

### Оптимизация производительности

В высоконагруженных тестовых сценариях (например, нагрузочное тестирование) стоит учитывать, что встроенные функции на C
работают быстрее. Однако для обработки больших данных в тестах лучше использовать генераторы (`range()` вместо списков)
для экономии памяти.

### Использование type hints

Применение встроенных функций в сочетании с аннотациями типов (например, `isinstance()` для проверки типов в runtime)
улучшает надёжность тестового кода. Это особенно актуально для Python 3.9+, где встроены generic-коллекции (например,
`list[str]`).

================================================================================================================================

# Декораторы

#### **Определение**

Декораторы — это мощный паттерн метапрограммирования в Python, который позволяет динамически изменять или расширять
поведение функций, методов или классов без модификации их исходного кода. Декоратор — это вызываемый объект (функция или
класс), который принимает другой вызываемый объект в качестве аргумента, оборачивает его и возвращает новый вызываемый
объект с модифицированным поведением. Синтаксически декораторы применяются с использованием символа `@` перед
определением функции или класса.

#### **Внутренняя реализация (под капотом)**

1. **Механизм замыканий и пространства имён**:
    - При встрече декоратора `@decorator` интерпретатор Python выполняет операцию:
      `decorated_func = decorator(original_func)`. Это происходит на этапе компиляции модуля, а не во время выполнения.
    - Декоратор создает замыкание (closure), сохраняя ссылку на оригинальную функцию и переменные из внешней области
      видимости. Это реализуется через атрибут `__closure__` объекта-функции, который содержит cell-объекты с
      захваченными значениями.

2. **Дескрипторы и протокол вызова**:
    - Декораторы классов используют механизм дескрипторов. При применении декоратора к классу вызывается
      `decorator(cls)`, и результат присваивается имени класса.
    - Для методов классов декораторы взаимодействуют с дескриптором `function`. Когда декоратор применяется к методу, он
      фактически оборачивает функцию-дескриптор.

3. **Преобразование AST (Abstract Syntax Tree)**:
    - На этапе компиляции Python преобразует декораторы в серию вызовов. Например,
      `@decorator1 @decorator2 def f(): ...` превращается в `f = decorator1(decorator2(f))`.
    - В байт-коде это отражается как последовательность инструкций `LOAD_NAME` (декоратор) и `CALL_FUNCTION`.

4. **Многоуровневая обертка и functools.wraps**:
    - Стандартный модуль `functools` предоставляет декоратор `wraps`, который копирует метаданные оригинальной функции (
      `__name__`, `__doc__`, `__module__`) в обертку. Это достигается через обновление атрибутов `__wrapped__` и
      `__dict__` объекта-функции.
    - Без `wraps` теряется информация для интроспекции, что критично для фреймворков тестирования.

5. **Кэширование и параметризованные декораторы**:
    - Параметризованные декораторы (например, `@decorator(arg)`) работают через двухуровневую структуру: внешняя функция
      принимает аргументы и возвращает собственно декоратор.
    - Внутренне это создает дополнительные уровни вложенности функций, что может влиять на производительность и
      трассировку стека.

6. **Нативные декораторы для методов классов**:
    - При декорировании методов используется дескриптор `staticmethod`/`classmethod`. Например, `@classmethod`
      преобразует функцию в связанный метод, устанавливая атрибут `__isabstractmethod__` при необходимости.

#### **Особенности**

1. **Время применения**: Нативные декораторы выполняются один раз при определении функции/класса (на этапе импорта
   модуля), а не при каждом вызове. Это важно для кэширования данных или регистрации компонентов.

2. **Сохранение сигнатуры**: Нативные декораторы могут нарушать сигнатуру функции, что приводит к проблемам при
   использовании `inspect.signature` или систем типизации (Type Hints). Для сохранения сигнатуры используется
   `inspect. Signature` или библиотеки типа `decorator` из PyPI.

3. **Стек декораторов**: Применение нескольких декораторов (`@decor1 @decor2`) создает вложенные обертки. Порядок
   выполнения: от нижнего к верхнему (декоратор, ближайший к функции, выполняется первым).

4. **Декораторы классов**: Позволяют изменять атрибуты класса, добавлять методы, регистрировать классы в реестрах.
   Альтернатива метаклассам для простых сценариев.

5. **Асинхронные декораторы**: Для декорирования асинхронных функций (`async def`) требуется использовать `async def`
   внутри декоратора или библиотеки типа `asyncio`. Иначе теряется возможность `await`.

6. **Декораторы с состоянием**: Через замыкания или атрибуты функции (`func.__my_state__`) можно сохранять состояние
   между вызовами, что используется в кэширующих декораторах (например, `functools.lru_cache`).

7. **Влияние на производительность**: Каждый декоратор добавляет уровень вызовов, что может замедлить выполнение. Для
   критичных к производительности участков стоит минимизировать вложенность декораторов.

#### **Лучшие практики**

1. **Использование `functools.wraps`**:
    - Всегда применяйте `@functools.wraps(original_func)` в декораторах для сохранения метаданных. Это критично для
      логирования, отладки и работы фреймворков (например, pytest использует `__name__` для идентификации тестов).

2. **Декораторы в тестировании**:
    - В AQA декораторы активно используются для управления тестами: `@pytest.fixture`, `@unittest.skip`,
      `@pytest.mark.parametrize`. При написании кастомных декораторов важно обеспечить совместимость с этими
      фреймворками.
    - Декораторы для логирования действий теста или измерения времени выполнения должны быть ненавязчивыми и не влиять
      на результат теста.

3. **Параметризация и конфигурируемость**:
    - Для гибкости создавайте параметризованные декораторы (например, `@retry(attempts=3)`). Используйте фабрику
      декораторов: внешняя функция принимает параметры, возвращает декоратор.
    - Конфигурацию (например, таймауты) выносите в аргументы декоратора, а не в замыкания.

4. **Декораторы для изоляции тестов**:
    - Декораторы типа `@mock.patch` (из `unittest.mock`) подменяют объекты на время теста. Важно понимать область их
      действия: декоратор применяется к функции, а не к классу.
    - Для мокирования в рамках всего класса используйте `@mock.patch.object` или фикстуры уровня класса.

5. **Тестирование самих декораторов**:
    - Декораторы как часть кода должны быть покрыты тестами. Тестируйте их поведение с разными типами функций (
      синхронные, асинхронные, методы классов).
    - Проверяйте сохранение сигнатуры и метаданных.

6. **Избегание побочных эффектов**:
    - Декораторы не должны выполнять тяжелые вычисления при декорировании (на этапе импорта). Инициализацию переносите в
      первый вызов или используйте lazy-подход.
    - Не полагайтесь на глобальное состояние в декораторах — это усложняет тестирование.

7. **Работа с типами (Type Hints)**:
    - Для Python 3.9+ используйте `typing.TypeVar` и `typing.ParamSpec` (PEP 612) для создания типизированных
      декораторов, сохраняющих информацию о сигнатуре. Это улучшает поддержку в IDE и статических анализаторах.

8. **Декораторы как регистраторы**:
    - В AQA фреймворках декораторы часто используются для регистрации тестовых случаев (например,
      `@testcase(priority='high')`). Реализуйте такой декоратор через добавление атрибутов функции (
      `func.__test_priority = 'high'`).

9. **Обработка исключений**:
    - Декораторы для повторных попыток (`@retry`) или обработки ошибок должны корректно пробрасывать исключения и не
      маскировать оригинальные трассировки стека. Используйте `raise from` или `traceback` модуль.

10. **Документирование декораторов**:
    - В docstring декоратора указывайте его назначение, параметры и влияние на функцию. Особенно важно для декораторов,
      изменяющих поведение (например, изменяющих аргументы).

================================================================================================================================

