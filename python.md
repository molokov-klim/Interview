================================================================================================================================

# Типы данных в Python

### Философия и общая характеристика

Python — язык с **динамической сильной типизацией**. Это означает:

1. **Динамическая типизация**: Тип переменной определяется в момент присваивания значения и может меняться в ходе
   выполнения программы.
2. **Сильная типизация**: Неявные преобразования типов ограничены, большинство операций проверяют совместимость типов и
   вызывают исключения при несоответствии (TypeError).
3. **Утиная типизация** (Duck typing): Фокус на поведении объекта, а не на его классе. "Если что-то ходит как утка и
   крякает как утка, то это утка".

Все в Python — объекты, и каждый объект имеет:

- **Идентификатор** (id) — уникальный адрес в памяти
- **Тип** (type) — определяет возможные операции и структуру данных
- **Значение** (value)

### Категории типов данных

#### 1. По изменяемости (Mutability)

**Неизменяемые (Immutable) типы**:

- Числа: `int`, `float`, `complex`
- Последовательности: `str`, `tuple`, `bytes`, `frozenset`
- Специальный: `NoneType` (объект None), `bool`

**Изменяемые (Mutable) типы**:

- Коллекции: `list`, `dict`, `set`, `bytearray`
- Пользовательские классы (по умолчанию)
- Прочие: `array`, `deque`, `Counter` и т.д.

**Ключевое различие**: При изменении неизменяемого объекта создается новый объект, а изменяемый объект модифицируется на
месте.

#### Общая структура объектов (CPython)

Каждый объект в CPython начинается с двух заголовочных полей:

1. **`PyObject_HEAD`**:
    - `Py_ssize_t ob_refcnt` — счетчик ссылок (для управления памятью)
    - `PyTypeObject *ob_type` — указатель на объект-тип

2. **`PyObject_VAR_HEAD`** (для объектов переменной длины):
    - Заголовок PyObject_HEAD
    - `Py_ssize_t ob_size` — количество элементов

#### Особенности конкретных типов

**Целые числа (int)**:

- До Python 3: разделение на `int` и `long`
- С Python 3: единый тип `int` произвольной точности
- Маленькие числа (-5 до 256) кэшируются (синглтоны)
- Внутреннее представление — массив "цифр" (обычно 30-битных) в системе счисления base=2³⁰
- Операции: быстрые для маленьких чисел, медленные для больших

**Числа с плавающей точкой (float)**:

- Реализация через С-тип `double` (IEEE 754, 64 бита)
- Особенности: неточности представления, `float('nan')`, `float('inf')`

**Строки (str)**:

- Unicode-строки (начиная с Python 3)
- Кодировка по умолчанию: UTF-8 (внутренне может использовать Latin-1, UCS-2, UCS-4 в зависимости от содержимого)

**Списки (list)**:

- Динамический массив (не связный список!)
- Стратегия роста: при заполнении выделяется новый массив большего размера (обычно на ~12.5%)
- Амортизированная сложность O(1) для append
- Внутренне: массив указателей на Python-объекты

**Словари (dict)**:

- Хэш-таблица с открытой адресацией
- Компактное представление (с Python 3.6): два массива — индексы и записи
- Коэффициент заполнения: ~2/3, затем рехэширование
- Сохранение порядка вставки (с Python 3.7)

**Кортежи (tuple)**:

- Неизменяемые списки
- Кэшируются при создании (если содержат только неизменяемые элементы)
- Могут использоваться как ключи словаря (если все элементы хэшируемы)

### Система типов и метатипы

**type** — это метакласс, экземплярами которого являются сами классы:

- `type(obj)` возвращает класс объекта
- `type(type)` возвращает `type` (сам на себя)

**Иерархия наследования**:
Все классы наследуются от `object` (прямо или косвенно)

```
object
├── type (метакласс)
├── BaseException
├── int, float, str, list, dict, tuple, set, ...
└── пользовательские классы
```

## Лучшие практики

1. Используйте кортежи для констант, списки для изменяемых данных
2. Проверяйте типы через isinstance(), а не type()
3. Применяйте type hints для документирования и статического анализа
4. Для поиска элементов используйте множества (O(1) вместо O(n))
5. Избегайте квадратичных операций со строками, используйте join()

================================================================================================================================

# *args и **kwargs в Python

`*args` и `**kwargs` — это специальные синтаксические конструкции в Python, которые позволяют функциям принимать
произвольное количество аргументов. Это ключевой механизм для создания гибких и универсальных функций, декораторов,
классов и других конструкций.

## Синтаксис и базовое назначение

- `*args` (арги) — собирает **позиционные аргументы** в кортеж (tuple)
- `**kwargs` (кварги) — собирает **именованные (ключевые) аргументы** в словарь (dict)

Названия `args` и `kwargs` — это конвенция, но не требование языка. Важны именно символы `*` и `**`.

## Механизм работы "под капотом"

### 1. Распаковка (Unpacking) и упаковка (Packing)

Фундаментально, `*` и `**` — это операторы распаковки/упаковки:

- **При определении функции** (`def func(*args, **kwargs)`) — это **упаковка** (packing)
- **При вызове функции** (`func(*iterable, **dict)`) — это **распаковка** (unpacking)

### 2. Компиляция и байт-код

Когда Python компилирует функцию с `*args` или `**kwargs`:

1. **Аргументы по умолчанию** обрабатываются первыми и сохраняются в `__defaults__` или `__kwdefaults__`
2. **`*args`** создает специальный слот в объекте кода функции, который указывает, что все "лишние" позиционные
   аргументы должны быть собраны в кортеж
3. **`**kwargs`** создает слот для сбора лишних ключевых аргументов в словарь
4. В байт-коде это реализуется через инструкции:
    - `LOAD_FAST` для обычных аргументов
    - `BUILD_TUPLE` для `*args`
    - `BUILD_MAP` для `**kwargs`

### 3. Порядок аргументов в сигнатуре функции

Строгий порядок в определении функции (после Python 3):

1. Позиционные аргументы (обычные)
2. `*args` (собирает оставшиеся позиционные)
3. Аргументы, доступные только по ключу (keyword-only arguments)
4. `**kwargs` (собирает оставшиеся именованные)

Пример: `def func(a, b, *args, c, d=10, **kwargs)`

## Детали реализации

### Для `*args`:

1. **Тип данных**: Всегда `tuple` (неизменяемая последовательность)
2. **Расположение в памяти**: При вызове функции Python создает новый кортеж, даже если передан пустой набор аргументов
3. **Итерация**: Поскольку это кортеж, итерация по нему происходит быстрее, чем по списку
4. **Важно**: `*args` всегда создает **поверхностную копию** переданных аргументов

### Для `**kwargs`:

1. **Тип данных**: Всегда `dict`
2. **Ключи**: Должны быть строками (string), так как имена параметров в Python — всегда строки
3. **Порядок**: До Python 3.6 порядок ключей не сохранялся, с Python 3.7+ порядок соответствует порядку передачи (
   благодаря новой реализации dict)
4. **Хэширование**: Все ключи проходят через встроенную функцию `hash()` для быстрого поиска

## Особенности и нюансы

### 1. Взаимодействие с декораторами

`*args` и `**kwargs` — основа большинства декораторов:

```python
def decorator(func):
    def wrapper(*args, **kwargs):
        # что-то делаем до вызова
        result = func(*args, **kwargs)  # распаковка аргументов
        # что-то делаем после вызова
        return result

    return wrapper
```

Это позволяет декоратору работать с любой функцией, независимо от её сигнатуры.

### 2. Метаклассы и наследование

При наследовании классов, метод `__init_subclass__` получает `**kwargs`, содержащий все ключевые аргументы, переданные
при определении класса. Это используется для регистрации подклассов, конфигурирования и т.д.

### 3. Функции высшего порядка

Функции, которые принимают другие функции как аргументы (например, `map`, `filter`, декораторы), часто используют
`*args` и `**kwargs` для передачи аргументов оборачиваемой функции.

### 4. Переопределение методов

При переопределении методов в классах-наследниках часто используется `super().__init__(*args, **kwargs)` для передачи
всех аргументов родительскому классу без явного их перечисления.

## Специальные случаи и продвинутые техники

### 1. Аргументы, доступные только по ключу (keyword-only arguments)

После `*args` (или просто звездочки `*`) в сигнатуре функции все последующие аргументы становятся доступными только по
ключу:

```python
def func(a, b, *, c, d):  # c и d — keyword-only
    pass
```

Это полезно для повышения читаемости кода и предотвращения ошибок.

### 2. Аннотации типов с `*args` и `**kwargs`

В Python 3.5+ появилась поддержка аннотаций:

```python
from typing import Any


def func(*args: Any, **kwargs: Any) -> None:
    pass
```

Более точные аннотации:

```python
from typing import Union


def func(*args: Union[int, str], **kwargs: str) -> None:
    pass
```

### 3. `inspect` модуль

Модуль `inspect` позволяет анализировать сигнатуры функций:

```python
import inspect

sig = inspect.signature(func)
params = sig.parameters
```

Это используется в фреймворках типа FastAPI для автоматического парсинга аргументов, в тестовых фреймворках для фикстур
и т.д.

### 4. Производительность

- **Накладные расходы**: Использование `*args` и `**kwargs` добавляет небольшие накладные расходы на создание
  кортежа/словаря
- **Оптимизация**: Для критичных к производительности мест лучше использовать фиксированное количество аргументов
- **Кэширование аргументов**: В CPython есть оптимизации для кэширования объектов кортежей и словарей, что уменьшает
  overhead при частых вызовах

## Ограничения и потенциальные проблемы

1. **Потеря информации о сигнатуре**: Функции с `*args, **kwargs` скрывают свою реальную сигнатуру, что усложняет
   интроспекцию и автодополнение в IDE
2. **Ошибки типов**: Статические анализаторы типов (mypy) могут не всегда корректно проверять такие функции
3. **Безопасность**: При использовании `**kwargs` для передачи в другие функции (например, в ORM-запросы) нужно быть
   осторожным с инъекциями
4. **Читаемость**: Чрезмерное использование ухудшает читаемость и понимание кода

## Лучшие практики

1. **Документировать ожидаемые аргументы** в docstring, даже если используется `*args/**kwargs`
2. **Валидировать критические аргументы** внутри функции
3. **Использовать аннотации типов** для улучшения статического анализа
4. **Предпочитать явные аргументы**, когда сигнатура стабильна и известна
5. **Резервировать `*args/**kwargs`** для действительно универсальных случаев или для передачи в обернутые функции

================================================================================================================================

# Хеш-таблица

Хэш-таблица (hash table) — это фундаментальная структура данных, реализующая абстрактный тип данных «ассоциативный
массив» (или «словарь»). Она позволяет хранить пары «ключ-значение» и обеспечивает в среднем константное время O(1) для
операций вставки, удаления и поиска, что делает её одной из самых эффективных структур для этих задач.

В контексте Python хэш-таблицы являются «двигателем» для двух ключевых встроенных типов данных: `dict` (словарь) и
`set` (множество). Их внутренняя реализация глубоко оптимизирована и является одной из сильных сторон языка.

### Принцип работы (общая теория)

1. **Хэш-функция:** Ключ передаётся в хэш-функцию, которая преобразует его в целое число — хэш-код. Идеальная
   хэш-функция для хэш-таблицы должна быть детерминированной (один и тот же ключ всегда даёт один и тот же хэш), быстрой
   в вычислении и равномерно распределять ключи по диапазону возможных значений.
2. **Индексирование:** Полученный хэш-код (часто большое число) преобразуется в индекс слота (ячейки) в массиве
   фиксированного размера (хэш-таблице) с помощью операции, обычно это взятие остатка от деления на размер массива.
3. **Хранение:** По вычисленному индексу в массиве хранится значение (или ссылка на него). В случае Python, в слоте
   хранится не просто значение, а целая запись, содержащая и хэш ключа, и ссылку на ключ, и ссылку на значение.

### Реализация в Python «под капотом»

Python использует модифицированную версию алгоритма открытой адресации (open addressing), в частности, вариант,
известный как **«двойное хэширование»** (perturbation scheme).

#### 1. Хэш-функция и требование к ключам

* В Python за вызов хэш-функции отвечает встроенная функция `__hash__()`. Для любого объекта, который должен быть
  ключом (в `dict` или элементом `set`), должен быть реализован магический метод `__hash__()`.
* **Критическое требование:** Объект должен быть **неизменяемым** (в смысле хэшируемости) на протяжении всей жизни. Если
  хэш объекта изменится после того, как он был помещён в таблицу, он окажется в неверном слоте и станет недоступен.
  Поэтому неизменяемые типы (`int`, `float`, `str`, `tuple`, `frozenset`) хэшируемы, а изменяемые (`list`, `dict`,
  `set`) — нет (но есть исключения, например, пользовательские классы по умолчанию хэшируемы по их `id`).
* Метод `__eq__()` используется для проверки равенства ключей при разрешении коллизий. Связь между `__hash__` и `__eq__`
  строгая: равные объекты **обязаны** иметь равные хэши. Обратное неверно (коллизия хэшей не означает равенство
  объектов).

#### 2. Внутренняя структура словаря

Начиная с Python 3.6 (и официально с Python 3.7), словари сохраняют **порядок добавления элементов**. Это стало
возможным благодаря изменению внутренней организации.

* **Новая, компактная модель (3.6+):** Используются **два массива**.
    1. **`indices` (плотный):** Массив целых чисел (размером ~2/3 от размера хэш-таблицы). Это, по сути, индексы для
       второго массива. Исходный хэш ключа преобразуется в индекс именно в этом массиве. Значение в `indices[i]`
       указывает на слот во втором массиве.
    2. **`entries` (плотный):** Массив структур, хранящих ключ, значение и полный хэш ключа (для ускорения перебора и
       разрешения коллизий). Элементы добавляются в этот массив последовательно, что и обеспечивает сохранение порядка.

  **Процесс поиска:**
    1. Вычисляется хэш ключа.
    2. Берется младшие биты хэша для вычисления индекса `i` в массиве `indices`.
    3. По значению `indices[i]` находится запись в массиве `entries`.
    4. Если запись содержит наш ключ (проверка по хэшу и `__eq__`), возвращается её значение.
    5. Если нет (коллизия), запускается схема «возмущения» (perturb): старшие биты хэша используются для вычисления
       нового индекса, и процесс повторяется.

  **Преимущества новой модели:**
    * **Экономия памяти:** Массив `indices` хранит только инты, а все данные — в плотном массиве `entries`. Удаление не
      создает «дыр» (dummy entries) в основном хранилище.
    * **Локализация данных:** `entries` является плотным массивом, что дружественно к кэшу процессора при итерации.
    * **Сохранение порядка:** Плотный массив `entries` заполняется последовательно.

#### 3. Разрешение коллизий

Python использует **открытую адресацию (open addressing)** с «возмущением» (perturbation), что является формой двойного
хэширования. В отличие от метода цепочек (chaining), где в каждом слоте хранится список элементов, здесь при коллизии
алгоритм ищет следующий свободный слот в том же массиве `indices` по детерминированной схеме.

* При поиске или вставке, если вычисленный слот в `indices` занят другим ключом, значение хэша «возмущается» (сдвигается
  и комбинируется с исходным) для получения нового пробного индекса. Это повторяется до нахождения пустого слота (для
  вставки) или искомого ключа.
* Удаление элементов в такой схеме нетривиально. Просто очистить слот нельзя — это сломает цепочку проб для последующих
  ключей. Поэтому слот помечается специальным значением (в старой схеме — `DUMMY`), что указывает алгоритму проб
  продолжать поиск при коллизиях.

#### 4. Динамическое изменение размера и фактор загрузки

* Для поддержания эффективности хэш-таблица должна оставаться разреженной. **Коэффициент загрузки (load factor)** — это
  отношение занятых слотов к общему количеству слотов.
* В Python коэффициент загрузки обычно поддерживается на уровне **~2/3**. Когда он превышен, происходит *
  *рехэширование (rehashing)**: выделяется новый массив `indices` большего размера (обычно в 2-4 раза), и все
  существующие записи пересчитываются и перемещаются в новую таблицу. Это дорогая операция O(n), но, будучи
  амортизированной по многим вставкам, она позволяет сохранять среднюю сложность O(1).

#### 5. Множества (set и frozenset)

* Внутренне `set` реализован почти так же, как `dict`, но без массива для значений. Каждая запись хранит только ключ (он
  же элемент множества) и его хэш. Многие оптимизации (компактная организация, разрешение коллизий) идентичны.

### Импликации для Senior AQA

1. **Производительность:** Понимание, что операции со словарями и множествами имеют **амортизированную O(1)**, критично
   для написания эффективного кода и тестов. Например, проверка принадлежности элемента множеству (`x in my_set`) — одна
   из самых быстрых операций.
2. **Порядок элементов:** Начиная с Python 3.7, порядок ключей в словаре гарантированно соответствует порядку вставки.
   Этим можно и нужно пользоваться в тестах, но важно помнить, что поведение в версиях до 3.6 иное.
3. **Хэшируемость:** При создании пользовательских классов, которые планируется использовать как ключи в словарях или
   элементы множеств, необходимо корректно определять `__hash__` и `__eq__`. Несоблюдение контракта между ними приведёт
   к некорректной работе структуры.
4. **Зависимость от хэш-функции:** В редких случаях возможны **атаки на отказ в обслуживании (HashDoS)**, когда
   злонамеренно подобранные ключи вызывают катастрофическое количество коллизий, деградируя производительность до O(n).
   Современные версии Python (с 3.3+) используют рандомизированную хэш-функцию для строк и некоторых других типов,
   которая активируется переменной окружения `PYTHONHASHSEED`, чтобы mitigate эту угрозу.
5. **Отладка и профилирование:** Знание о рехэшировании помогает понять «пики» потребления памяти и времени при активной
   вставке элементов. Если конечный размер словаря известен заранее, его можно создать с помощью `dict.fromkeys()` или
   передав примерный размер в конструктор, чтобы избежать многократных дорогостоящих операций рехэширования.

Таким образом, хэш-таблица в Python — это не просто абстрактная концепция, а высокооптимизированный механизм, лежащий в
основе критически важных структур данных. Понимание её работы «под капотом» позволяет писать более эффективный, надёжный
и предсказуемый код, а также грамотно проектировать и анализировать тесты, особенно когда речь идет о
производительности.

================================================================================================================================

