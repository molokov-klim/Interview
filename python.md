# Типы данных в Python

## Типы данных в Python

### Философия и общая характеристика

Python — язык с **динамической сильной типизацией**. Это означает:

1. **Динамическая типизация**: Тип переменной определяется в момент присваивания значения и может меняться в ходе
   выполнения программы.
2. **Сильная типизация**: Неявные преобразования типов ограничены, большинство операций проверяют совместимость типов и
   вызывают исключения при несоответствии (TypeError).
3. **Утиная типизация** (Duck typing): Фокус на поведении объекта, а не на его классе. "Если что-то ходит как утка и
   крякает как утка, то это утка".

Все в Python — объекты, и каждый объект имеет:

- **Идентификатор** (id) — уникальный адрес в памяти
- **Тип** (type) — определяет возможные операции и структуру данных
- **Значение** (value)

### Категории типов данных

#### 1. По изменяемости (Mutability)

**Неизменяемые (Immutable) типы**:

- Числа: `int`, `float`, `complex`, `bool`
- Последовательности: `str`, `tuple`, `bytes`, `frozenset`
- Специальный: `NoneType` (объект None)

**Изменяемые (Mutable) типы**:

- Коллекции: `list`, `dict`, `set`, `bytearray`
- Пользовательские классы (по умолчанию)
- Прочие: `array`, `deque`, `Counter` и т.д.

**Ключевое различие**: При изменении неизменяемого объекта создается новый объект, а изменяемый объект модифицируется на
месте.

#### 2. По назначению и структуре

**Скалярные типы**:

- `int` — целые числа произвольной точности
- `float` — числа с плавающей точкой двойной точности (IEEE 754)
- `complex` — комплексные числа
- `bool` — булевы значения (наследник int: True=1, False=0)
- `NoneType` — специальный тип для отсутствия значения

**Последовательности (Sequences)**:

- `str` — Unicode-строки
- `list` — динамический массив
- `tuple` — неизменяемый список
- `bytes`/`bytearray` — бинарные данные
- `range` — диапазон целых чисел

**Отображения (Mappings)**:

- `dict` — хэш-таблица ключ-значение
- Подтипы: `defaultdict`, `OrderedDict`, `Counter`

**Множества (Sets)**:

- `set` — изменяемое множество
- `frozenset` — неизменяемое множество

**Бинарные последовательности**:

- `bytes` — неизменяемые
- `bytearray` — изменяемые
- `memoryview` — представление памяти

### Внутреннее устройство "под капотом"

#### Общая структура объектов (CPython)

Каждый объект в CPython начинается с двух заголовочных полей:

1. **`PyObject_HEAD`**:
    - `Py_ssize_t ob_refcnt` — счетчик ссылок (для управления памятью)
    - `PyTypeObject *ob_type` — указатель на объект-тип

2. **`PyObject_VAR_HEAD`** (для объектов переменной длины):
    - Заголовок PyObject_HEAD
    - `Py_ssize_t ob_size` — количество элементов

#### Особенности конкретных типов

**Целые числа (int)**:

- До Python 3: разделение на `int` и `long`
- С Python 3: единый тип `int` произвольной точности
- Маленькие числа (-5 до 256) кэшируются (синглтоны)
- Внутреннее представление — массив "цифр" (обычно 30-битных) в системе счисления base=2³⁰
- Операции: быстрые для маленьких чисел, медленные для больших (алгоритмы Карацубы, Шёнхаге-Штрассена)

**Числа с плавающей точкой (float)**:

- Реализация через С-тип `double` (IEEE 754, 64 бита)
- Особенности: неточности представления, `float('nan')`, `float('inf')`
- Специальные значения: `NaN`, `+Inf`, `-Inf`

**Строки (str)**:

- Unicode-строки (начиная с Python 3)
- Кодировка по умолчанию: UTF-8 (внутренне может использовать Latin-1, UCS-2, UCS-4 в зависимости от содержимого)
- Нематериализованные представления (PEP 393)
- Интернирование строк: автоматическое для коротких строк и строк, являющихся идентификаторами
- Оптимизации: строковый пул, кэширование хэшей

**Списки (list)**:

- Динамический массив (не связный список!)
- Начальный размер: обычно 0 или небольшой
- Стратегия роста: при заполнении выделяется новый массив большего размера (обычно на ~12.5%)
- Амортизированная сложность O(1) для append
- Внутренне: массив указателей на Python-объекты

**Словари (dict)**:

- Хэш-таблица с открытой адресацией
- Компактное представление (с Python 3.6): два массива — индексы и записи
- Коэффициент заполнения: ~2/3, затем рехэширование
- Сохранение порядка вставки (с Python 3.7)

**Кортежи (tuple)**:

- Неизменяемые списки
- Кэшируются при создании (если содержат только неизменяемые элементы)
- Могут использоваться как ключи словаря (если все элементы хэшируемы)

### Система типов и метатипы

**type** — это метакласс, экземплярами которого являются сами классы:

- `type(obj)` возвращает класс объекта
- `type(type)` возвращает `type` (сам на себя)

**Иерархия наследования**:
Все классы наследуются от `object` (прямо или косвенно)

```
object
├── type (метакласс)
├── BaseException
├── int, float, str, list, dict, tuple, set, ...
└── пользовательские классы
```

### Аннотации типов и статический анализ

**PEP 484** ввел аннотации типов:

- Синтаксис: `def func(arg: Type) -> ReturnType:`
- Модуль `typing`: `List`, `Dict`, `Optional`, `Union`, `Any`, `Callable`, `TypeVar`, `Generic`
- **Только для статического анализа**, не влияют на выполнение
- **mypy**, **pyright**, **pyre** — статические анализаторы типов

**Новые возможности**:

- **PEP 526**: Аннотации переменных
- **PEP 544**: Протоколы (структурная типизация)
- **PEP 585**: Параметризация стандартных коллекций
- **PEP 604**: Синтаксис Union: `int | str`

### Специальные аспекты для AQA

#### 1. Проверка типов в тестах

- `isinstance(obj, type)` vs `type(obj) == type`
- `issubclass(cls, base)`
- Утиная типизация: проверка наличия методов (`hasattr`, `callable`)

#### 2. Моки и стабы

- `unittest.mock.Mock`/`MagicMock` могут имитировать любой тип
- `spec` и `spec_set` для ограничения атрибутов
- Автоспецификация (autospec) для сохранения сигнатуры

#### 3. Сериализация и десериализация

- `pickle` сохраняет типы объектов
- `json` преобразует в базовые типы (str, int, float, list, dict, bool, None)
- Пользовательские сериализаторы должны учитывать типы

#### 4. Генерация тестовых данных

- Библиотеки: `hypothesis`, `faker`
- Учет типов для параметризованных тестов
- Генерация edge cases для разных типов

#### 5. Тестирование производительности

- Профилирование использования памяти разными типами
- Замеры времени операций для разных типов
- Оптимизации через выбор правильных типов

#### 6. Статический анализ в CI/CD

- Интеграция mypy в пайплайн
- Кастомные правила для типов
- Валидация аннотаций в кодовой базе

### Продвинутые темы

#### 1. Дескрипторы протоколов

- `__len__`, `__getitem__` для последовательностей
- `__iter__`, `__next__` для итераторов
- `__enter__`, `__exit__` для контекстных менеджеров

#### 2. Абстрактные базовые классы (ABC)

- Модуль `collections.abc`: `Iterable`, `Sequence`, `Mapping`, `Set`
- Регистрация виртуальных подклассов
- Проверка реализации протоколов

#### 3. Слоты (`__slots__`)

- Оптимизация памяти
- Ограничение динамических атрибутов
- Влияние на сериализацию и наследование

#### 4. Протокол буферизации

- `memoryview`, `array`, `bytes`
- Zero-copy операции для больших данных

#### 5. Метапрограммирование типов

- Классы-дженерики (`Generic[T]`)
- TypeVar с ограничениями
- Перегрузка функций (`@overload`)

### Особенности тестирования типов

1. **Тестирование граничных значений**:
    - Максимальные/минимальные значения для int
    - Особые значения float (NaN, Inf)
    - Пустые и максимально большие коллекции

2. **Тестирование приведения типов**:
    - Явное (`int(x)`, `str(x)`)
    - Неявное (арифметические операции)
    - Потеря точности

3. **Тестирование сериализации**:
    - Сохранение типов через pickle
    - Преобразования в JSON и обратно
    - Кастомные сериализаторы

4. **Тестирование производительности**:
    - Сравнение разных типов для одной задачи
    - Профилирование использования памяти
    - Оптимизация через выбор типов

5. **Интеграция со статическими анализаторами**:
    - Валидация типов в тестах
    - Генерация тестов на основе аннотаций
    - Проверка покрытия типов

### Практические рекомендации для Senior AQA

1. **Понимать внутреннее устройство** для эффективной отладки
2. **Использовать аннотации типов** для самодокументирования и статического анализа
3. **Тестировать не только happy path**, но и некорректные типы
4. **Учитывать мутабельность** при создании фикстур и моков
5. **Профилировать использование типов** в критических участках
6. **Интегрировать статический анализ** в процесс разработки
7. **Использовать продвинутые возможности** (дженерики, протоколы) для создания гибких тестовых фреймворков

Глубокое понимание системы типов Python позволяет не только писать более надежный и эффективный код, но и создавать
комплексные тестовые стратегии, охватывающие все аспекты поведения программы, от корректности типов до
производительности и использования памяти.

================================================================================================================================

# *args и **kwargs в Python

`*args` и `**kwargs` — это специальные синтаксические конструкции в Python, которые позволяют функциям принимать
произвольное количество аргументов. Это ключевой механизм для создания гибких и универсальных функций, декораторов,
классов и других конструкций. Понимание их работы на глубоком уровне критично для Senior Python разработчика и AQA.

## Синтаксис и базовое назначение

- `*args` (арги) — собирает **позиционные аргументы** в кортеж (tuple)
- `**kwargs` (кварги) — собирает **именованные (ключевые) аргументы** в словарь (dict)

Названия `args` и `kwargs` — это конвенция, но не требование языка. Важны именно символы `*` и `**`.

## Механизм работы "под капотом"

### 1. Распаковка (Unpacking) и упаковка (Packing)

Фундаментально, `*` и `**` — это операторы распаковки/упаковки:

- **При определении функции** (`def func(*args, **kwargs)`) — это **упаковка** (packing)
- **При вызове функции** (`func(*iterable, **dict)`) — это **распаковка** (unpacking)

### 2. Компиляция и байт-код

Когда Python компилирует функцию с `*args` или `**kwargs`:

1. **Аргументы по умолчанию** обрабатываются первыми и сохраняются в `__defaults__` или `__kwdefaults__`
2. **`*args`** создает специальный слот в объекте кода функции, который указывает, что все "лишние" позиционные
   аргументы должны быть собраны в кортеж
3. **`**kwargs`** создает слот для сбора лишних ключевых аргументов в словарь
4. В байт-коде это реализуется через инструкции:
    - `LOAD_FAST` для обычных аргументов
    - `BUILD_TUPLE` для `*args`
    - `BUILD_MAP` для `**kwargs`

### 3. Порядок аргументов в сигнатуре функции

Строгий порядок в определении функции (после Python 3):

1. Позиционные аргументы (обычные)
2. `*args` (собирает оставшиеся позиционные)
3. Аргументы, доступные только по ключу (keyword-only arguments)
4. `**kwargs` (собирает оставшиеся именованные)

Пример: `def func(a, b, *args, c, d=10, **kwargs)`

## Детали реализации

### Для `*args`:

1. **Тип данных**: Всегда `tuple` (неизменяемая последовательность)
2. **Расположение в памяти**: При вызове функции Python создает новый кортеж, даже если передан пустой набор аргументов
3. **Итерация**: Поскольку это кортеж, итерация по нему происходит быстрее, чем по списку
4. **Важно**: `*args` всегда создает **поверхностную копию** переданных аргументов

### Для `**kwargs`:

1. **Тип данных**: Всегда `dict`
2. **Ключи**: Должны быть строками (string), так как имена параметров в Python — всегда строки
3. **Порядок**: До Python 3.6 порядок ключей не сохранялся, с Python 3.7+ порядок соответствует порядку передачи (
   благодаря новой реализации dict)
4. **Хэширование**: Все ключи проходят через встроенную функцию `hash()` для быстрого поиска

## Особенности и нюансы

### 1. Взаимодействие с декораторами

`*args` и `**kwargs` — основа большинства декораторов:

```python
def decorator(func):
    def wrapper(*args, **kwargs):
        # что-то делаем до вызова
        result = func(*args, **kwargs)  # распаковка аргументов
        # что-то делаем после вызова
        return result

    return wrapper
```

Это позволяет декоратору работать с любой функцией, независимо от её сигнатуры.

### 2. Метаклассы и наследование

При наследовании классов, метод `__init_subclass__` получает `**kwargs`, содержащий все ключевые аргументы, переданные
при определении класса. Это используется для регистрации подклассов, конфигурирования и т.д.

### 3. Функции высшего порядка

Функции, которые принимают другие функции как аргументы (например, `map`, `filter`, декораторы), часто используют
`*args` и `**kwargs` для передачи аргументов оборачиваемой функции.

### 4. Переопределение методов

При переопределении методов в классах-наследниках часто используется `super().__init__(*args, **kwargs)` для передачи
всех аргументов родительскому классу без явного их перечисления.

## Специальные случаи и продвинутые техники

### 1. Аргументы, доступные только по ключу (keyword-only arguments)

После `*args` (или просто звездочки `*`) в сигнатуре функции все последующие аргументы становятся доступными только по
ключу:

```python
def func(a, b, *, c, d):  # c и d — keyword-only
    pass
```

Это полезно для повышения читаемости кода и предотвращения ошибок.

### 2. Аннотации типов с `*args` и `**kwargs`

В Python 3.5+ появилась поддержка аннотаций:

```python
from typing import Any


def func(*args: Any, **kwargs: Any) -> None:
    pass
```

Более точные аннотации:

```python
from typing import Union


def func(*args: Union[int, str], **kwargs: str) -> None:
    pass
```

### 3. `inspect` модуль

Модуль `inspect` позволяет анализировать сигнатуры функций:

```python
import inspect

sig = inspect.signature(func)
params = sig.parameters
```

Это используется в фреймворках типа FastAPI для автоматического парсинга аргументов, в тестовых фреймворках для фикстур
и т.д.

### 4. Производительность

- **Накладные расходы**: Использование `*args` и `**kwargs` добавляет небольшие накладные расходы на создание
  кортежа/словаря
- **Оптимизация**: Для критичных к производительности мест лучше использовать фиксированное количество аргументов
- **Кэширование аргументов**: В CPython есть оптимизации для кэширования объектов кортежей и словарей, что уменьшает
  overhead при частых вызовах

## Применение в тестировании (AQA контекст)

### 1. Параметризованные тесты

Фреймворки вроде pytest используют `*args` и `**kwargs` для:

- Декоратора `@pytest.mark.parametrize`
- Фикстур с динамическими аргументами
- Плагинов, которые могут добавлять произвольные аргументы в тестовые функции

### 2. Моки и стабы

При создании мок-объектов (например, с `unittest.mock`):

```python
from unittest.mock import Mock

mock = Mock()
mock(*args, **kwargs)  # принимает любые аргументы
mock.assert_called_with(*args, **kwargs)  # проверяет вызов с любыми аргументами
```

### 3. Универсальные тестовые утилиты

Создание вспомогательных функций, которые могут работать с разными сигнатурами:

```python
def retry_on_exception(max_retries=3, exceptions=(Exception,)):
    def decorator(func):
        def wrapper(*args, **kwargs):
            # логика повторных попыток
            pass

        return wrapper

    return decorator
```

### 4. Динамическое создание тестов

Генерация тестовых случаев на лету:

```python
def generate_test(**test_config):
    def test_function(*args, **kwargs):
        # выполнение теста с конфигурацией
        pass

    return test_function
```

### 5. Интеграция с CI/CD и конфигурациями

Чтение тестовых конфигураций из YAML/JSON и преобразование в `**kwargs` для передачи в тестовые функции.

## Ограничения и потенциальные проблемы

1. **Потеря информации о сигнатуре**: Функции с `*args, **kwargs` скрывают свою реальную сигнатуру, что усложняет
   интроспекцию и автодополнение в IDE
2. **Ошибки типов**: Статические анализаторы типов (mypy) могут не всегда корректно проверять такие функции
3. **Безопасность**: При использовании `**kwargs` для передачи в другие функции (например, в ORM-запросы) нужно быть
   осторожным с инъекциями
4. **Читаемость**: Чрезмерное использование ухудшает читаемость и понимание кода

## Лучшие практики для Senior AQA

1. **Документировать ожидаемые аргументы** в docstring, даже если используется `*args/**kwargs`
2. **Валидировать критические аргументы** внутри функции
3. **Использовать аннотации типов** для улучшения статического анализа
4. **Предпочитать явные аргументы**, когда сигнатура стабильна и известна
5. **Резервировать `*args/**kwargs`** для действительно универсальных случаев или для передачи в обернутые функции

Понимание `*args` и `**kwargs` на этом уровне позволяет не только писать более гибкий код, но и глубже понимать работу
Python-экосистемы, фреймворков для тестирования, а также создавать более мощные и универсальные тестовые утилиты и
инфраструктуру.

================================================================================================================================

# Хеш-таблица

Хэш-таблица (hash table) — это фундаментальная структура данных, реализующая абстрактный тип данных «ассоциативный
массив» (или «словарь»). Она позволяет хранить пары «ключ-значение» и обеспечивает в среднем константное время O(1) для
операций вставки, удаления и поиска, что делает её одной из самых эффективных структур для этих задач.

В контексте Python хэш-таблицы являются «двигателем» для двух ключевых встроенных типов данных: `dict` (словарь) и
`set` (множество). Их внутренняя реализация глубоко оптимизирована и является одной из сильных сторон языка.

### Принцип работы (общая теория)

1. **Хэш-функция:** Ключ передаётся в хэш-функцию, которая преобразует его в целое число — хэш-код. Идеальная
   хэш-функция для хэш-таблицы должна быть детерминированной (один и тот же ключ всегда даёт один и тот же хэш), быстрой
   в вычислении и равномерно распределять ключи по диапазону возможных значений.
2. **Индексирование:** Полученный хэш-код (часто большое число) преобразуется в индекс слота (ячейки) в массиве
   фиксированного размера (хэш-таблице) с помощью операции, обычно это взятие остатка от деления на размер массива.
3. **Хранение:** По вычисленному индексу в массиве хранится значение (или ссылка на него). В случае Python, в слоте
   хранится не просто значение, а целая запись, содержащая и хэш ключа, и ссылку на ключ, и ссылку на значение.

### Реализация в Python «под капотом»

Python использует модифицированную версию алгоритма открытой адресации (open addressing), в частности, вариант,
известный как **«двойное хэширование»** (perturbation scheme).

#### 1. Хэш-функция и требование к ключам

* В Python за вызов хэш-функции отвечает встроенная функция `__hash__()`. Для любого объекта, который должен быть
  ключом (в `dict` или элементом `set`), должен быть реализован магический метод `__hash__()`.
* **Критическое требование:** Объект должен быть **неизменяемым** (в смысле хэшируемости) на протяжении всей жизни. Если
  хэш объекта изменится после того, как он был помещён в таблицу, он окажется в неверном слоте и станет недоступен.
  Поэтому неизменяемые типы (`int`, `float`, `str`, `tuple`, `frozenset`) хэшируемы, а изменяемые (`list`, `dict`,
  `set`) — нет (но есть исключения, например, пользовательские классы по умолчанию хэшируемы по их `id`).
* Метод `__eq__()` используется для проверки равенства ключей при разрешении коллизий. Связь между `__hash__` и `__eq__`
  строгая: равные объекты **обязаны** иметь равные хэши. Обратное неверно (коллизия хэшей не означает равенство
  объектов).

#### 2. Внутренняя структура словаря (до Python 3.6 и после)

Начиная с Python 3.6 (и официально с Python 3.7), словари сохраняют **порядок добавления элементов**. Это стало
возможным благодаря изменению внутренней организации.

* **Старая модель (до 3.6):** Один разреженный массив (`PyDictEntry`[8]), где каждая запись могла иметь одно из трёх
  состояний: Active (хранит ключ, хэш, значение), Dummy (удалённая запись — маркер для разрешения коллизий при открытой
  адресации), Empty.
* **Новая, компактная модель (3.6+):** Используются **два массива**.
    1. **`indices` (плотный):** Массив целых чисел (размером ~2/3 от размера хэш-таблицы). Это, по сути, индексы для
       второго массива. Исходный хэш ключа преобразуется в индекс именно в этом массиве. Значение в `indices[i]`
       указывает на слот во втором массиве.
    2. **`entries` (плотный):** Массив структур, хранящих ключ, значение и полный хэш ключа (для ускорения перебора и
       разрешения коллизий). Элементы добавляются в этот массив последовательно, что и обеспечивает сохранение порядка.

  **Процесс поиска:**
    1. Вычисляется хэш ключа.
    2. Берется младшие биты хэша для вычисления индекса `i` в массиве `indices`.
    3. По значению `indices[i]` находится запись в массиве `entries`.
    4. Если запись содержит наш ключ (проверка по хэшу и `__eq__`), возвращается её значение.
    5. Если нет (коллизия), запускается схема «возмущения» (perturb): старшие биты хэша используются для вычисления
       нового индекса, и процесс повторяется.

  **Преимущества новой модели:**
    * **Экономия памяти:** Массив `indices` хранит только инты, а все данные — в плотном массиве `entries`. Удаление не
      создает «дыр» (dummy entries) в основном хранилище.
    * **Локализация данных:** `entries` является плотным массивом, что дружественно к кэшу процессора при итерации.
    * **Сохранение порядка:** Плотный массив `entries` заполняется последовательно.

#### 3. Разрешение коллизий

Python использует **открытую адресацию (open addressing)** с «возмущением» (perturbation), что является формой двойного
хэширования. В отличие от метода цепочек (chaining), где в каждом слоте хранится список элементов, здесь при коллизии
алгоритм ищет следующий свободный слот в том же массиве `indices` по детерминированной схеме.

* При поиске или вставке, если вычисленный слот в `indices` занят другим ключом, значение хэша «возмущается» (сдвигается
  и комбинируется с исходным) для получения нового пробного индекса. Это повторяется до нахождения пустого слота (для
  вставки) или искомого ключа.
* Удаление элементов в такой схеме нетривиально. Просто очистить слот нельзя — это сломает цепочку проб для последующих
  ключей. Поэтому слот помечается специальным значением (в старой схеме — `DUMMY`), что указывает алгоритму проб
  продолжать поиск при коллизиях.

#### 4. Динамическое изменение размера и фактор загрузки

* Для поддержания эффективности хэш-таблица должна оставаться разреженной. **Коэффициент загрузки (load factor)** — это
  отношение занятых слотов к общему количеству слотов.
* В Python коэффициент загрузки обычно поддерживается на уровне **~2/3**. Когда он превышен, происходит *
  *рехэширование (rehashing)**: выделяется новый массив `indices` большего размера (обычно в 2-4 раза), и все
  существующие записи пересчитываются и перемещаются в новую таблицу. Это дорогая операция O(n), но, будучи
  амортизированной по многим вставкам, она позволяет сохранять среднюю сложность O(1).

#### 5. Множества (set и frozenset)

* Внутренне `set` реализован почти так же, как `dict`, но без массива для значений. Каждая запись хранит только ключ (он
  же элемент множества) и его хэш. Многие оптимизации (компактная организация, разрешение коллизий) идентичны.

### Импликации для Senior AQA

1. **Производительность:** Понимание, что операции со словарями и множествами имеют **амортизированную O(1)**, критично
   для написания эффективного кода и тестов. Например, проверка принадлежности элемента множеству (`x in my_set`) — одна
   из самых быстрых операций.
2. **Порядок элементов:** Начиная с Python 3.7, порядок ключей в словаре гарантированно соответствует порядку вставки.
   Этим можно и нужно пользоваться в тестах, но важно помнить, что поведение в версиях до 3.6 иное.
3. **Хэшируемость:** При создании пользовательских классов, которые планируется использовать как ключи в словарях или
   элементы множеств, необходимо корректно определять `__hash__` и `__eq__`. Несоблюдение контракта между ними приведёт
   к некорректной работе структуры.
4. **Зависимость от хэш-функции:** В редких случаях возможны **атаки на отказ в обслуживании (HashDoS)**, когда
   злонамеренно подобранные ключи вызывают катастрофическое количество коллизий, деградируя производительность до O(n).
   Современные версии Python (с 3.3+) используют рандомизированную хэш-функцию для строк и некоторых других типов,
   которая активируется переменной окружения `PYTHONHASHSEED`, чтобы mitigate эту угрозу.
5. **Отладка и профилирование:** Знание о рехэшировании помогает понять «пики» потребления памяти и времени при активной
   вставке элементов. Если конечный размер словаря известен заранее, его можно создать с помощью `dict.fromkeys()` или
   передав примерный размер в конструктор, чтобы избежать многократных дорогостоящих операций рехэширования.

Таким образом, хэш-таблица в Python — это не просто абстрактная концепция, а высокооптимизированный механизм, лежащий в
основе критически важных структур данных. Понимание её работы «под капотом» позволяет писать более эффективный, надёжный
и предсказуемый код, а также грамотно проектировать и анализировать тесты, особенно когда речь идет о
производительности.

