# **Типы данных**

---

## **Junior Level**

Типы данных в Python делятся на **изменяемые** (mutable) и **неизменяемые** (immutable).

**Простые типы:**

- Числа: `int`, `float`, `decimal`, `complex`
- Строки: `str`
- Логические значения: `bool`
- Специальный тип: `NoneType` (единственное значение `None`)

**Коллекции**

- `list` — изменяемая упорядоченная коллекция
- `tuple` — неизменяемая упорядоченная коллекция
- `dict` — изменяемая коллекция пар «ключ-значение» (упорядоченная с Python 3.7)
- `set` / `frozenset` — изменяемое и неизменяемое множества уникальных элементов
- `bytes` / `bytearray` — неизменяемая и изменяемая последовательности байтов

---

## **Middle Level**

Объекты изменяемыех типов можно модифицировать после создания. А любая модификация объекта неизменяемого типа
создаёт новый объект.
Передача изменяемых объектов в функции позволяет модифицировать оригинал
Только неизменяемые объекты могут быть ключами словаря (требуется хэшируемость)
Мутабельность негативно влияет на потокобезопасность и кэширование

### Специфика типов:

`None` — синглтон, обозначающий отсутствие значения
`bool` — подкласс `int`, значения `True` и `False` — синглтоны
`tuple` — неизменяем, но может содержать изменяемые элементы
`set`/`frozenset` — хранят только хэшируемые элементы, реализация аналогична словарям без значений

### Обеспечение иммутабельности пользовательских объектов:

Для пользовательских классов полная иммутабельность невозможна из-за динамической природы языка, но её можно эффективно
эмулировать с помощью dataclasses, namedtuple или переопределения специальных методов. Это особенно полезно в тестовой
автоматизации, где конфигурации и тестовые данные должны оставаться неизменными для предсказуемости.

## Встроенные иммутабельные типы

Используйте tuple вместо list, frozenset вместо set для данных, которые не должны меняться.

- namedtuple из collections даёт именованные поля с иммутабельностью:
  `Point = namedtuple('Point', ['x', 'y']); p = Point(1, 2)` — доступ через p.x, но изменение запрещено.
- Преимущества: хэшируемость (для словарей/множеств), кэширование Python, безопасность в многопоточности.

## Dataclasses с frozen=True

Самый современный способ для Python 3.7+: `@dataclass(frozen=True)` генерирует класс с иммутабельными полями,
перехватывая setattr/delattr исключениями FrozenInstanceError.

```python
from dataclasses import dataclass


@dataclass(frozen=True)
class Config:
    host: str
    port: int
```

Подходит для конфигов в CI/CD или тестовых фреймворках, но создание чуть медленнее обычных dataclasses.

## Ручная иммутабельность

Переопределите __setattr__, __delattr__, используйте __slots__ для экономии памяти и запрета monkey-patching.

```python
class Immutable:
    __slots__ = ['_value']

    def __init__(self, value):
        object.__setattr__(self, '_value', value)

    def __setattr__(self, name, value):
        raise AttributeError(f"'{self.__class__.__name__}' is immutable")

    @property
    def value(self):
        return self._value
```

Это относительно надёжно. Комбинируйте с @property для read-only доступа.

## Практические советы

Избегайте мутабельных вложений (list в tuple) — используйте tuple внутри tuple. Для валидации добавьте Pydantic с
model_config['frozen'] = True.

---

## **Senior Level**

В CPython **все типы данных** наследуют от базовой структуры `PyObject`, которая содержит refcount и указатель на тип.
Каждый тип описывается массивом **слотов** в `PyTypeObject`.
`Include/object.h`, `Include/cpython/object.h`

## Базовый объект (PyObject)

```c
typedef struct _object {
    _PyObject_HEAD_EXTRA       // Платформо-зависимые поля для отладки (PyDebug)
    Py_ssize_t ob_refcnt;      // Счётчик ссылок - при 0 вызывается tp_dealloc
    struct _typeobject *ob_type; // Указатель на PyTypeObject описывающий тип
} PyObject;
```

### Общее

Это **фундаментальная C-структура из ядра CPython**, которая представляет любой объект в Python на самом низком уровне.
Каждый объект в Python — будь то число, строка, список или ваш собственный класс — в памяти выглядит как экземпляр этой
структуры. Она содержит три ключевых компонента: счётчик ссылок (для управления памятью), указатель на тип объекта и
служебные поля для отладки.

### Описание

**Отладочная информация:**

- `_PyObject_HEAD_EXTRA` — это не одно поле, а макрос, который раскрывается в дополнительные платформо-зависимые поля *
  *только в отладочных сборках Python** (когда интерпретатор скомпилирован с флагом `--with-pydebug`). В обычных сборках
  это ничего не добавляет. Используется для отслеживания проблем с памятью.

**Счётчик ссылок:**

- `ob_refcnt` — целое число, которое **считает, сколько переменных или структур указывают на этот объект**. Когда
  счётчик становится 0, Python вызывает функцию `tp_dealloc` (из `PyTypeObject`) для освобождения памяти. Это основной
  механизм управления памятью в CPython (garbage collection через reference counting).

**Указатель на тип:**

- `ob_type` — указатель на структуру `PyTypeObject`, которая описывает тип этого объекта. Это то же самое, что
  возвращает встроенная функция `type(obj)` в Python. Через этот указатель интерпретатор узнаёт, как работать с
  объектом: какие операции он поддерживает, как получить его атрибуты, как его удалить.

### Уточнения

- **Reference counting — это не threading-safe по умолчанию**: В CPython счётчик ссылок работает за счёт глобальной
  блокировки (GIL — Global Interpreter Lock), поэтому многопоточность имеет ограничения. В Python 3.13+ появился режим
  free-threaded, где это иначе.

- **Минимальный размер**: Даже самый простой объект в памяти занимает как минимум столько байт, сколько занимает
  `PyObject` (обычно 16-24 байта на 64-битной системе в зависимости от конфигурации). Это почему в Python много памяти
  уходит на служебную информацию, даже для маленьких объектов.

- **ob_refcnt увеличивается и уменьшается постоянно**: Каждый раз, когда вы присваиваете объект переменной, счётчик
  увеличивается на 1. Когда переменная удаляется или переназначается, счётчик уменьшается на 1. Вы можете проверить это
  функцией `sys.getrefcount(obj)`.

- **Связь с PyTypeObject**: `PyObject` и `PyTypeObject` работают вместе: `PyObject` — это экземпляр, `PyTypeObject` —
  это описание класса. Например, объект `5` имеет `ob_type`, указывающий на `PyTypeObject` для типа `int`.

---

## "Паспорт" каждого типа (PyTypeObject)

```c
typedef struct _typeobject {
    PyVarObject ob_base;       // Тип сам является объектом (можно наследовать)
    
    const char *tp_name;       // Имя типа ("list", "dict", "int")
    Py_ssize_t tp_basicsize;   // Размер в байтах без переменной части
    Py_ssize_t tp_itemsize;    // Размер одного элемента переменной части
    
    destructor tp_dealloc;     // Функция уничтожения (list_dealloc)
    printfunc tp_print;        // Для print()
    reprfunc tp_repr;          // Для repr()
    
    // Протокол чисел
    PyNumberMethods *tp_as_number;  // nb_add, nb_sub, nb_multiply...
    
    // Протокол последовательностей
    PySequenceMethods *tp_as_sequence; // sq_item, sq_ass_slice...
    
    // Протокол маппингов
    PyMappingMethods *tp_as_mapping;  // mp_subscript, mp_ass_subscript
    
    // Поиск атрибутов
    getattrofunc tp_getattro;      // obj.attr
    setattrofunc tp_setattro;      // obj.attr = value
    
    // Дескрипторы (property, method)
    descrgetfunc tp_descr_get;     // __get__
    descrsetfunc tp_descr_set;     // __set__
    
    Py_ssize_t tp_dictoffset;      // Смещение __dict__ (или -1)
    Py_ssize_t tp_weaklistoffset;  // Смещение weakref списка
    
    PyObject *tp_mro;              // Method Resolution Order (tuple типов)
    PyObject *tp_cache;            // Кеш атрибутов (free-threaded)
    unsigned int tp_subclasses;    // Количество живых подклассов
    
    PyObject *tp_dict;             // __dict__ класса
    // ... 100+ слотов
} PyTypeObject;
```

### Общее

Это **внутренняя C-структура из ядра Python**, которая определяет тип объекта на самом низком уровне. Каждый класс и
встроенный тип в Python (list, dict, int, str) представлены в памяти именно такой структурой. Она содержит всю
метаинформацию о типе: имя, размер, методы обработки операций (сложение, индексирование), управление атрибутами и многое
другое. Это фундамент, на котором работает весь механизм объектно-ориентированного программирования в Python.

### Описание

**Базовая информация:**

- `ob_base` — каждый тип сам является объектом (в Python всё является объектом, включая сами типы)
- `tp_name` — строка с именем типа, которая выводится, например, при вызове `type(obj).__name__`
- `tp_basicsize` и `tp_itemsize` — память: базовый размер структуры плюс размер на один элемент для переменных
  контейнеров (список с 10 элементами занимает `basicsize + 10 * itemsize` байт)

**Управление жизненным циклом:**

- `tp_dealloc` — функция уничтожения объекта, вызывается при удалении (соответствует `__del__` на уровне C)
- `tp_print`, `tp_repr` — старый способ для вывода и представления (в Python 3.9+ `tp_print` устарел)

**Протоколы операций** — указатели на структуры с функциями для конкретных операций:

- `tp_as_number` — арифметические операции: `__add__`, `__sub__`, `__mul__` и т.д.
- `tp_as_sequence` — операции последовательностей: `obj[i]`, `obj[i:j]`, `len(obj)`
- `tp_as_mapping` — операции словарей: `obj[key]`, `len(obj)` для словарей

**Управление атрибутами:**

- `tp_getattro` / `tp_setattro` — низкоуровневые функции для доступа к атрибутам (`obj.attr` и `obj.attr = value`)

**Дескрипторы:**

- `tp_descr_get` / `tp_descr_set` — механизм дескрипторов, на котором работают `property`, методы класса, статические
  методы

**Служебная информация:**

- `tp_dictoffset` — смещение в памяти, где находится `__dict__` объекта (словарь атрибутов экземпляра)
- `tp_mro` — кортеж типов в порядке разрешения методов (Method Resolution Order) — порядок поиска атрибутов в иерархии
  наследования
- `tp_dict` — `__dict__` самого класса, где хранятся методы и атрибуты класса

### Уточнения

1. **C-структура, но видна из Python**: Вы не работаете с этой структурой напрямую в коде на Python, но когда пишете
   класс с методами `__add__`, `__getitem__` или `__get__`, Python переводит эти методы в соответствующие C-функции в
   этой структуре для производительности.

2. **tp_print устарел**: В Python 3.9+ поле `tp_print` более не используется. Вывод объектов управляется через `tp_repr`
   и `tp_str`.

3. **100+ слотов**: Код содержит комментарий «... 100+ слотов», что означает в реальной структуре есть множество
   дополнительных полей для специальных случаев, обработки исключений, сериализации и прочего. Здесь показаны только
   самые важные.

4. **Зачем это нужно знать**: Если вы пишете расширения на C для Python или оптимизируете критичные места, понимание
   этой структуры помогает правильно определить поведение типа. Для обычного Python-кода достаточно знать, что она
   существует.

5. **Про free-threaded**: Поле `tp_cache` относится к улучшениям для параллельного выполнения (free-threaded Python),
   актуально для Python 3.13+, для Python 3.9-3.12 на него можно не обращать внимание.

---

## Инициализация типов: PyType_Ready

```c
int PyType_Ready(PyTypeObject *type) {
    if (type->tp_flags & Py_TPFLAGS_READY)  // Уже инициализирован
        return 0;
    
    // Наследуем слоты от базовых классов
    if (type->tp_bases) {
        Py_ssize_t i, nbase = PyTuple_GET_SIZE(type->tp_bases);
        for (i = 0; i < nbase; i++) {
            PyTypeObject *base = (PyTypeObject *)PyTuple_GET_ITEM(type->tp_bases, i);
            if (PyType_Ready(base) < 0)
                return -1;
            
            // Наследуем слоты (tp_as_number, tp_as_sequence...)
            inherit_special(base, type);
        }
    }
    
    // Вычисляем MRO
    if (mro_internal(type) < 0)
        return -1;
        
    // Инициализируем tp_dict
    if (type->tp_dict == NULL) {
        if (PyType_AllocDict(type) < 0)
            return -1;
    }
    
    type->tp_flags |= Py_TPFLAGS_READY;  // Отмечаем готовым
    return 0;
}
```

### Общее

`PyType_Ready` — это ключевая функция CPython, которая **финализирует тип** (класс) перед его использованием.  
Вызывается автоматически при определении класса (`class MyClass:`) или импорте модуля.  
Подготавливает все слоты, наследование и MRO (порядок разрешения методов).

### Описание

- `if (type->tp_flags & Py_TPFLAGS_READY)` — проверяет, уже ли тип инициализирован (избегает повторной работы).

- `if (type->tp_bases)` — цикл по базовым классам:
    - Рекурсивно вызывает `PyType_Ready(base)` для каждого родителя.
    - `inherit_special(base, type)` — копирует слоты (`tp_as_number`, `tp_as_sequence` и др.) из базового класса.

- `mro_internal(type)` — вычисляет **Method Resolution Order** (порядок поиска методов при множественном наследовании).

- `PyType_AllocDict(type)` — создаёт `__dict__` класса, если его нет (словарь атрибутов и методов).

- `type->tp_flags |= Py_TPFLAGS_READY` — помечает тип как полностью готовый к использованию.

### Уточнения

- **Рекурсивная инициализация** гарантирует, что все предки готовы перед дочерним классом.
- `inherit_special()` заполняет протоколы операций (арифметика, индексирование) из ближайшего базового класса.
- MRO критичен для **множественного наследования** — определяет порядок `super()`.
- Вызывается **один раз** за тип — повторные вызовы игнорируются (`Py_TPFLAGS_READY`).
- В Python 3.9+ улучшена производительность за счёт кэширования MRO и оптимизации слотов.

---

## База коллекций (PyVarObject)

```c
typedef struct {
    PyObject ob_base;          // Встроенный PyObject (refcnt + type)
    Py_ssize_t ob_size;        // Количество элементов (длина строки/списка)
} PyVarObject;
```

### Общее

- Это структура данных из исходного кода CPython (стандартной реализации Python, написанной на C).
- Она представляет собой расширенный заголовок для объектов, которые имеют переменную длину (количество элементов).
- Такие типы данных, как списки (`list`), кортежи (`tuple`) и строки (`str`), в памяти начинаются именно с этой
  структуры.

### Описание

- `typedef struct { ... } PyVarObject;` — конструкция языка C, создающая новый тип данных `PyVarObject`, описывающий,
  как объект лежит в оперативной памяти.
- `PyObject ob_base` — поле, внедряющее базовый объект внутрь. Оно содержит два критически важных элемента: счетчик
  ссылок (для сборщика мусора) и указатель на тип данных (класс объекта).
- `Py_ssize_t ob_size` — поле, хранящее количество элементов в объекте (значение, которое возвращает функция `len()`).
  Для списка это число слотов, для строки — количество символов.

### Уточнения

- Благодаря тому, что `ob_base` стоит первым, любой указатель на `PyVarObject` можно безопасно рассматривать как
  указатель на `PyObject`. Это позволяет функциям интерпретатора работать с любыми объектами (фиксированными и
  переменными) одинаково.
- Целые числа (`int`) в Python 3 также реализованы через `PyVarObject`, так как они поддерживают длинную арифметику и
  могут состоять из произвольного количества «цифр» в памяти.
- Доступ к длине объекта происходит за время O(1), так как интерпретатор просто читает значение `ob_size`, не
  пересчитывая элементы каждый раз.

---

## int (PyLongObject)

```c
typedef uint32_t digit;        // 30-битная цифра (2^30 = ~1e9)

typedef struct _longobject {
    PyObject_VAR_HEAD          // PyObject + ob_size (кол-во цифр)
    digit ob_digit[1];         // Массив цифр (размер ob_size)
} PyLongObject;
```

### Общее

`PyLongObject` — это внутренняя структура CPython, представляющая **все целые числа (`int`)** в Python.  
Даже обычное число `42` или огромный `10**1000` — это один и тот же тип объекта `PyLongObject`.  
Главная идея — хранить число не как одно значение, а как **массив “цифр”** в 30 бит, что позволяет поддерживать целые
числа любой длины (длинная арифметика).

### Описание

- `typedef uint32_t digit;` — определяет тип для хранения одной “цифры” числа. Каждая цифра занимает 32 бита, но реально
  используются только 30. Это оставляет запас для удобных вычислений без переполнений.  
  Например, большое число хранится как массив таких 30-битных частей.

- `PyObject_VAR_HEAD` — макрос, который вставляет в структуру стандартные поля из `PyVarObject`:
    - `ob_refcnt` — счётчик ссылок (для управления памятью).
    - `ob_type` — указатель на тип (`int`).
    - `ob_size` — количество “цифр” (`digit`) в числе и знак (если отрицательное, `ob_size` < 0).

- `digit ob_digit[1];` — первый элемент массива, в котором реально хранятся “цифры” числа.  
  Несмотря на размер `[1]`, массив в памяти может быть длиннее — его конечная длина задается `ob_size`.  
  Например, число `12345678901234567890` будет храниться как несколько элементов в этом массиве.

### Уточнения

- Такой подход позволяет Python-числам быть **неограниченно большими**, в отличие от фиксированной разрядности в C (
  `int`, `long`).
- Младшая цифра хранится первой (наименьший порядок) — это **младший разрядный порядок (little-endian)**.
- “30 бит на цифру” выбрано, чтобы при арифметических операциях с двумя цифрами не происходило переполнения 32‑битного
  регистра.
- Для маленьких чисел Python использует **кэш** заранее созданных объектов (от -5 до 256), чтобы не пересоздавать их в
  памяти.

---

## Создание int (PyLongObject)

```c
PyObject *_PyLong_New(Py_ssize_t size) {
    PyLongObject *result;
    
    size = Py_ABS(size);  // Берем модуль размера
    
    // Выделяем память под заголовок + массив цифр
    result = PyObject_MALLOC(sizeof(PyLongObject) + 
                             (size-1) * sizeof(digit));
    if (!result) {
        return PyErr_NoMemory();
    }
    
    // Инициализируем как PyObject
    PyObject_INIT(result, &PyLong_Type);
    Py_SET_SIZE(result, size);  // Устанавливаем ob_size
    result->ob_digit[0] = 0;    // Нулевая цифра
    
    return (PyObject *)result;
}
```

### Общее

`_PyLong_New` — это внутренняя функция CPython, которая **создаёт объект целого числа (`int`) в памяти**.  
Она не вычисляет значение, а лишь выделяет и подготавливает структуру `PyLongObject`, чтобы Python мог потом записать
туда цифры числа.  
Используется внутри интерпретатора при создании или копировании больших чисел.

### Описание

- `PyObject *_PyLong_New(Py_ssize_t size)` — функция принимает количество “цифр” (`digit`), которые нужно
  зарезервировать для будущего числа.  
  Если `size` отрицательное, берётся модуль (`Py_ABS(size)`), т.к. знак хранится отдельно через `ob_size`.

- `PyObject_MALLOC(sizeof(PyLongObject) + (size - 1) * sizeof(digit))` — выделяет память под заголовок (`PyLongObject`)
  и нужное количество “цифр”.  
  В структуре уже есть один элемент `ob_digit[1]`, поэтому добавляется `(size - 1)`.

- `if (!result) return PyErr_NoMemory();` — если память не выделилась, Python выбрасывает ошибку `MemoryError`.

- `PyObject_INIT(result, &PyLong_Type);` — макрос инициализирует базовую часть как `PyObject`, указывая, что это объект
  типа `int`.

- `Py_SET_SIZE(result, size);` — записывает длину числа (количество “цифр”) в `ob_size`.

- `result->ob_digit[0] = 0;` — устанавливает первую “цифру” числа равной нулю (инициализация).

- `return (PyObject *)result;` — возвращает созданный объект, приведённый к общему типу `PyObject *`, как это принято
  для всех Python-объектов.

### Уточнения

- Эта функция только выделяет память — **значение числа формируется позже**, другими функциями (например, при парсинге
  литерала или в арифметике).
- Функция — **внутренняя** (начинается с подчёркивания) и не предназначена для использования из Python‑C API напрямую.
- Используется стандартный **аллокатор Python** (`PyObject_MALLOC`), чтобы система могла отслеживать память GC и
  профилировать выделения.
- Знак числа не устанавливается здесь — он задаётся отдельно через `Py_SET_SIZE()` (положительный или отрицательный).

---

## float (PyFloatObject)

```c
typedef struct {
    PyObject ob_base;      // PyObject (refcnt + type)
    double ob_fval;        // IEEE 754 double-precision значение
} PyFloatObject;
```

### Общее

`PyFloatObject` — это внутренняя структура CPython, представляющая **числа с плавающей запятой (`float`)**.  
Любое число вроде `3.14` или `math.pi` в памяти хранится именно так.  
Простая структура — всего **одно поле со значением** в формате IEEE 754 double.

### Описание

- `PyObject ob_base` — стандартный заголовок:
    - `ob_refcnt` — счётчик ссылок для управления памятью.
    - `ob_type` — указатель на `PyFloat_Type` (тип `float`).

- `double ob_fval` — **реальное значение** числа в формате double (64 бита, ~15 значащих цифр).  
  Это стандарт IEEE 754, который используется во всех современных языках программирования.

### Уточнения

- **Фиксированный размер** — всегда 24 байта на 64-битной системе (PyObject + double).
- **Кэш маленьких float** отсутствует (в отличие от `int`), каждый `3.14` создаёт новый объект.
- **NaN, Inf, -Inf** поддерживаются стандартно через IEEE 754 (`float('nan')`, `float('inf')`).
- Арифметика (`+`, `-`, `*`, `/`) реализована через `tp_as_number` в `PyFloat_Type`.

---

## Создание float (PyFloatObject)

```c
PyObject *PyFloat_FromDouble(double fval) {
    PyFloatObject *op = _PyFloat_New();  // Выделяем PyFloatObject
    if (!op)
        return NULL;
    op->ob_fval = fval;                  // Записываем значение
    return (PyObject *)op;
}

static PyObject *_PyFloat_New(void) {
    PyFloatObject *op = (PyFloatObject*)PyObject_MALLOC(sizeof(PyFloatObject));
    if (!op) {
        return PyErr_NoMemory();
    }
    PyObject_INIT(op, &PyFloat_Type);    // Инициализируем как float
    return (PyObject *)op;
}
```

### Общее

`PyFloat_FromDouble` — основная функция CPython для **создания объекта `float` из C double**.  
Вызывается интерпретатором при литералах `3.14`, вызовах `float()`, математических операциях.  
Создаёт готовый Python-объект с заданным значением.

### Описание

- `PyFloatObject *op = _PyFloat_New();` — вызывает внутреннюю функцию выделения памяти под `PyFloatObject`.
- `_PyFloat_New()` — выделяет память через `PyObject_MALLOC` и инициализирует:
    - `PyObject_INIT(op, &PyFloat_Type)` — устанавливает `ob_refcnt=1`, `ob_type=&PyFloat_Type`.
- `op->ob_fval = fval;` — записывает **значение double** в поле объекта.
- `return (PyObject *)op;` — возвращает как универсальный `PyObject *`.

### Уточнения

- **Нет кэша** для float (в отличие от малых int) — каждый `3.14` создаёт новый объект.
- `PyObject_MALLOC` — специальный аллокатор Python для отслеживания GC.
- Функция **thread-safe** благодаря GIL (Python 3.9+).
- Используется в байткоде (`BINARY_OP` для `+`, `-`, `*`, `/` с float).

---

## decimal (PyDecimalObject)

```c
// decimal.Decimal - пользовательский класс Python, НЕ встроенный тип CPython
// Реализован в Objects/decimalmodule.c как PyTypeObject с C-ускорением

typedef struct {
    PyObject ob_base;           // Стандартный заголовок
    PyObject *digits;           // Массив цифр (список int)
    PyObject *exp;              // Показатель степени 10 (int)
    PyObject *prec;             // Точность (int)
    PyObject *rounding;         // Режим округления
    PyObject *context;          // Контекст вычислений
} PyDecimalObject;
```

### Общее

`decimal.Decimal` — **НЕ встроенный тип CPython**, а **модульный класс** из `decimal` с C-реализацией.  
Предоставляет **десятичную арифметику фиксированной точности** (банковские расчёты, финансы).  
В отличие от `float`, хранит числа как массив цифр + показатель степени.

### Описание

- `PyObject ob_base` — стандартный заголовок (`refcnt`, `type=PyDecimal_Type`).
- `PyObject *digits` — **массив цифр** в десятичной системе (список `int`).
- `PyObject *exp` — **показатель степени** (например, `123E-2` = 1.23).
- `PyObject *prec` — **точность** (максимум цифр для операций).
- `PyObject *rounding` — режим округления (`ROUND_HALF_UP` и др.).
- `PyObject *context` — глобальный контекст вычислений (`getcontext()`).

### Уточнения

- **Полностью управляемый** через `decimal.getcontext()` — точность, округление, исключения.
- Арифметика **десятичная**, не двоичная (никаких ошибок округления как в `float`).
- В CPython ускорен **C-кодом** (`Objects/decimalmodule.c`), но это всё равно Python-класс.
- Используется для **финансовых расчётов** (`0.1 + 0.2 == 0.3` работает правильно).

---

## Создание decimal (PyDecimalObject)

```c
PyObject *PyDecimal_FromString(PyObject *s) {
    PyDecimalObject *result = (PyDecimalObject *)PyObject_MALLOC(sizeof(PyDecimalObject));
    if (!result)
        return PyErr_NoMemory();
    
    PyObject_INIT(result, &PyDecimal_Type);
    
    // Парсим строку в цифры + экспоненту
    result->digits = parse_decimal_digits(s);
    result->exp = parse_exponent(s);
    result->prec = getcontext_prec();
    result->rounding = getcontext_rounding();
    result->context = getcontext_ref();
    
    return (PyObject *)result;
}
```

### Общее

Создание `PyDecimalObject` происходит через **функции модуля `decimal`** (например, `decimal.Decimal('1.23')`).  
Парсит строку в **десятичное представление** (цифры + экспонента) и связывает с глобальным контекстом точности.  
НЕ использует стандартный `_PyXXX_New()` — это модульная логика.

### Описание

- `PyObject_MALLOC(sizeof(PyDecimalObject))` — выделяет память под структуру.
- `PyObject_INIT(result, &PyDecimal_Type)` — инициализирует как `decimal.Decimal`.
- `result->digits = parse_decimal_digits(s)` — **разбирает цифры** из строки (`['1', '2', '3']`).
- `result->exp = parse_exponent(s)` — извлекает **экспоненту** (например, `E-2`).
- `result->prec = getcontext_prec()` — берёт **точность** из `decimal.getcontext()`.
- `result->rounding/context` — копирует настройки контекста округления и вычислений.

### Уточнения

- **Парсинг строковый** — `Decimal('1.23')` разбирается посимвольно, без потери точности.
- **Глобальный контекст** (`getcontext()`) определяет поведение всех операций.
- Создание **медленнее float/int** из-за парсинга и инициализации Python-объектов (`digits`, `exp`).
- В CPython 3.9+ **ускорено C-парсингом**, но остаётся модульным (не встроенный тип).

---

## str (PyUnicodeObject)

```c
typedef struct {
    PyObject_VAR_HEAD       // PyObject + ob_size (длина в символах)
    Py_UCS4 *ob_sval;       // Массив Unicode символов (UCS-4)
    // Или Py_UCS2 *ob_sval для компактных строк
    // Или char *ob_sval для latin-1 строк
} PyUnicodeObject;
```

### Общее

`PyUnicodeObject` — внутренняя структура CPython для **строк (`str`)**.  
Любая строка `s = "hello"` или `s = "привет"` хранится именно так.  
Поддерживает **три формата** хранения (compact, 1-byte, 2-byte, 4-byte) для экономии памяти.

### Описание

- `PyObject_VAR_HEAD` — стандартный заголовок:
    - `ob_refcnt` — счётчик ссылок.
    - `ob_type` — `&PyUnicode_Type`.
    - `ob_size` — **длина строки** в символах (не байтах).

- `Py_UCS4 *ob_sval` — **массив символов Unicode**:
    - `Py_UCS4` (32-bit) — полный Unicode (эмодзи, редкие символы).
    - `Py_UCS2` (16-bit) — BMP символы (большинство текста).
    - `char` (8-bit) — только ASCII/Latin-1.  
      Формат выбирается автоматически по содержимому.

### Уточнения

- **Автоматическая компрессия** — короткие ASCII строки занимают минимум памяти.
- **Interning** — одинаковые строки (`"hello"`) кэшируются как синглтоны (`sys.intern()`).
- **Immutable** — строки неизменяемы, операции `+`, `replace()` создают новые объекты.
- В Python 3.9+ улучшена **кодировка** (PEEPHOLER оптимизирует конкатенацию строк).

---

# Создание str (PyUnicodeObject)

```c
// Include/cpython/unicodeobject.h (Python 3.9+)
typedef struct {
    PyObject_VAR_HEAD
    Py_ssize_t length;      // Длина строки в символах (obsize)
    Py_hash_t hash;         // Кэшированный хэш (0 = не вычислен)
    struct {
        // Компактные Unicode варианты (Python 3.9+)
        Py_UCS1 *str;       // 1-byte ASCII/Latin-1
        Py_UCS2 *str2;      // 2-byte BMP
        Py_UCS4 *str4;      // 4-byte полный Unicode
    } data;
} PyUnicodeObject;

// Создание строки из C-строки (ASCII/Latin-1)
PyObject* PyUnicode_FromString(const char *u) {
    return PyUnicode_DecodeUTF8(u, strlen(u), NULL);
}

// Внутренняя функция создания (упрощённо)
static PyObject* unicode_new(Py_ssize_t length, int kind) {
    PyUnicodeObject *u;
    Py_ssize_t size;
    
    size = length * PyUnicode_KIND_SIZE(kind) + sizeof(PyUnicodeObject);
    u = PyObject_MALLOC(size);
    if (!u) return PyErr_NoMemory();
    
    PyObject_INIT_VAR(u, &PyUnicode_Type, length);
    u->hash = -1;  // Хэш не вычислен
    u->data.any = PyUnicode_DATA(u);  // Указатель на данные
    
    return (PyObject*)u;
}
```

### Общее

PyUnicodeObject — это C-структура CPython для хранения строк str в Python 3.9+. Использует **компактное представление
** (compact unicode): 1/2/4 байта на символ в зависимости от диапазона Unicode. Создание происходит через
PyUnicode_FromString() или внутренние функции вроде unicode_new().

### Описание

- **PyObject_VAR_HEAD**: Наследует refcnt, obtype (PyUnicode_Type), obsize (длина в символах).
- **length**: Количество символов (не байт!).
- **hash**: Кэшированный хэш для быстрого dict/set (-1 = не вычислен).
- **data.any**: Умный union — ASCII (1байт), BMP (2байт), полный Unicode (4байт).
- **unicode_new()**: Выделяет память под PyUnicodeObject + данные, инициализирует через PyObject_INIT_VAR.

### Уточнения

- **Компактность Python 3.9+**: "hello" → 1-byte (Py_UCS1), "привет" → 2-byte (Py_UCS2).
- **PyUnicode_FromString()**: Автоматически выбирает UTF-8 → PyUnicodeObject.
- **Interning**: sys.intern("hello") сохраняет один PyUnicodeObject для одинаковых строк.
- **Immutable**: После создания str нельзя изменить (no setattr!).
- **Memory layout**: PyObject (24байт) + данные сразу следом (O(1) доступ).

---

## dict (PyDictObject)

```c
typedef struct {
    Py_ssize_t ma_used;        // Кол-во ключей (не слотов!)
    uint64_t ma_version_tag;   // Версия для итераторов
    PyDictKeysObject *ma_keys; // Общие ключи
    PyObject **ma_values;      // Массив значений
} PyDictObject;
```

### Общее

`PyDictObject` — это внутренняя структура CPython, которая описывает объект **словаря (`dict`)**.  
Каждый словарь в Python — это хеш-таблица, оптимизированная для быстрого доступа по ключу (`dict[key]`).  
Эта структура управляет ключами, значениями и вспомогательными данными (например, версией для отслеживания изменений при
итерации).

### Описание

- `Py_ssize_t ma_used` — количество **реальных пар ключ–значение**, которые сейчас находятся в словаре.  
  Это не количество выделенных слотов в таблице, а именно количество активных записей, то есть то, что возвращает
  `len(dict)`.

- `uint64_t ma_version_tag` — номер версии словаря.  
  Он увеличивается при каждом изменении (добавление, удаление, обновление).  
  Используется итераторами и кэшем атрибутов, чтобы понимать, что структура изменилась.

- `PyDictKeysObject *ma_keys` — указатель на структуру, содержащую **ключи и хеш-таблицу**.  
  Эта часть может быть общей для нескольких словарей (например, у экземпляров класса с одинаковыми атрибутами).
  PyDictKeysObject содержит массив записей (PyDictKeyEntry), где хранятся:
    - сам ключ (PyObject *key)
    - хэш этого ключа (целое число, рассчитанное при вставке)
    - индекс (или прямое значение), указывающий на место в ma_values.
    - хэш-индекс — таблицу разных размеров, по которой Python быстрo находит нужный элемент по хэшу. Это и есть
      внутренняя хэш-таблица, которая делает словари такими быстрыми при поиске.

- `PyObject **ma_values` — массив указателей на **значения**, соответствующие индексам ключей из `ma_keys`.  
  Если поле равно `NULL`, значит, это «старый» словарь, где и ключи, и значения лежат в одном месте (используется для
  обычных dict).

### Уточнения

- Современная реализация (с Python 3.6) гарантирует **сохранение порядка вставки** благодаря оптимизированной
  хеш-таблице.
- Разделение `ma_keys` и `ma_values` позволяет экономить память при использовании общих ключей (например, в `__dict__` у
  одинаковых объектов одного класса).
- `ma_used` и `ma_version_tag` применяются для корректной работы итераторов: изменение словаря во время обхода вызывает
  ошибку `RuntimeError`.
- Доступ к элементам (`dict[key]`) осуществляется через хеш функции, хранящиеся в `PyDictKeysObject`, а значения
  подтягиваются из `ma_values` по индексу.

---

# Создание dict (PyDictObject)

```c
PyObject *
PyDict_New(void)
{
    /* We don't incref Py_EMPTY_KEYS here because it is immortal. */
    return new_dict(Py_EMPTY_KEYS, NULL, 0, 0);
}

static PyObject *
new_dict(PyDictKeysObject *keys, PyDictValues *values,
         Py_ssize_t used, int free_values_on_failure)
{
    assert(keys != NULL);
    PyDictObject *mp = _Py_FREELIST_POP(PyDictObject, dicts);
    if (mp == NULL) {
        mp = PyObject_GC_New(PyDictObject, &PyDict_Type);
        if (mp == NULL) {
            dictkeys_decref(keys, false);
            if (free_values_on_failure) {
                free_values(values, false);
            }
            return NULL;
        }
    }
    assert(Py_IS_TYPE(mp, &PyDict_Type));
    mp->ma_keys = keys;
    mp->ma_values = values;
    mp->ma_used = used;
    mp->_ma_watcher_tag = 0;
    ASSERT_CONSISTENT(mp);
    _PyObject_GC_TRACK(mp);
    return (PyObject *)mp;
}
```

### Общее

Создание пустого словаря `dict{}` в CPython начинается с вызова `PyDict_New()`. Эта функция создаёт объект
`PyDictObject` с минимальными начальными настройками, используя предсозданную "пустую" структуру ключей `Py_EMPTY_KEYS`.
Словарь получается компактным и готовым к быстрому заполнению без немедленного выделения дополнительной памяти под
записи.

### Описание

`PyDict_New()` вызывает вспомогательную функцию `new_dict()`, передавая ей бессмертный объект `Py_EMPTY_KEYS` (с
`dk_refcnt = PY_SSIZE_T_MIN`, размер 8 слотов, все индексы `DKIX_EMPTY`). Функция `new_dict()` берёт объект из пула
свободных словарей (`_Py_FREELIST_POP`) или создаёт новый через `PyObject_GC_New()`. Инициализируются поля: `ma_keys`
указывает на пустые ключи, `ma_values = NULL` (комбинированная таблица), `ma_used = 0`. Объект помечается для сборщика
мусора и возвращается.

### Уточнения

- `Py_EMPTY_KEYS` — глобальный бессмертный объект с 8 слотами (минимальный размер `PyDict_MINSIZE=8`), все индексы
  заполнены `DKIX_EMPTY(-1)` для быстрого поиска.
- Комбинированная таблица (`ma_values=NULL`) хранит ключи/значения в `dk_entries` структуры `PyDictKeysObject`.
- При первом добавлении элемента словарь вырастет до нужного размера через `dictresize()` с коэффициентом
  `USABLE_FRACTION=2/3`.
- Пул freelists ускоряет создание малых словарей, снижая нагрузку на `malloc()`.

---

## PyDictKeysObject

```c
struct _dictkeysobject {
    Py_ssize_t dk_size;        // Размер хеш-таблицы
    enum dict_keys_kind dk_kind; // DICT_KEYS_UNICODE и т.д.
    union {
        PyDictUnicodeEntry *dk_entries;  // Полная таблица key+value
        PyDictKeyEntry *dk_indices;      // Только индексы
    } dk;
    uint64_t dk_version_tag;
};
```

### Общее

`PyDictKeysObject` (или `_dictkeysobject`) — это внутренняя структура CPython, которая хранит **ключи и хеш-таблицу**
для словарей.  
Она отделена от `PyDictObject` и может быть **общей** для нескольких словарей (экономия памяти).  
Это "сердце" быстрого поиска в `dict[key]`.

### Описание

- `Py_ssize_t dk_size` — размер **хеш-таблицы** (количество слотов, обычно больше `ma_used`).  
  Python резервирует больше места, чтобы избежать частых перехеширований.

- `enum dict_keys_kind dk_kind` — тип структуры ключей:
    - `DICT_KEYS_UNICODE` — оптимизация для строковых ключей (самый частый случай).
    - `DICT_KEYS_GENERAL` — для произвольных хешируемых объектов.

- `union { ... } dk` — **союз** (union) с разными вариантами хранения:
    - `PyDictUnicodeEntry *dk_entries` — **полная таблица** ключ+значение (для "старых" словарей).
    - `PyDictKeyEntry *dk_indices` — **только индексы** для быстрого поиска (современный split table).

- `uint64_t dk_version_tag` — версия ключей (синхронизируется с `ma_version_tag` словаря).

### Уточнения

- **Union** позволяет экономить память: разные словари используют разные форматы в зависимости от содержимого.
- В Python 3.9+ **преобладает split table** (`dk_indices` + отдельные `ma_values`), `dk_entries` используется редко.
- `dk_size` определяет, сколько элементов в `dk_indices[]` для поиска по хэшу (open addressing с probing).
- Общие `ma_keys` используются в `__dict__` экземпляров одного класса — все объекты делят одну таблицу ключей.

---

## list (PyListObject)

```c
typedef struct {
    PyObject_VAR_HEAD         // PyObject + ob_size (длина)
    PyObject **ob_item;       // Указатели на элементы
    Py_ssize_t allocated;     // Выделенная ёмкость (> ob_size)
} PyListObject;
```

### Общее

`PyListObject` — это внутренняя структура CPython, которая описывает объект **списка (`list`)**.  
Когда вы создаёте список вроде `[1, 2, 3]`, в памяти Python создаёт именно такую структуру.  
Она хранит указатели на элементы, информацию о длине и о том, сколько памяти зарезервировано под будущие добавления.

### Описание

- `PyObject_VAR_HEAD` — стандартный заголовок переменных объектов, который добавляет поля:
    - `ob_refcnt` — счётчик ссылок (управление памятью).
    - `ob_type` — ссылка на тип (`list`).
    - `ob_size` — текущее количество элементов в списке (то, что возвращает `len(lst)`).

- `PyObject **ob_item;` — указатель на **массив ссылок** (указателей) на реальные объекты Python.  
  То есть сам список хранит не данные, а только ссылки — например, `[1, "a"]` содержит ссылки на `PyLongObject(1)` и
  `PyUnicodeObject("a")`.

- `Py_ssize_t allocated;` — количество ячеек, реально выделенных под элементы.  
  Оно может быть больше, чем `ob_size`, чтобы ускорить `append()` и не выделять память при каждом добавлении.

### Уточнения

- Разница между `ob_size` и `allocated` помогает Python делать **динамическое расширение** списка (амортизация вставок).
- Список — это не массив примитивов, а **массив указателей на объекты**, поэтому изменение одного списка не трогает
  содержимое других.
- Элементы списка всегда находятся в куче (heap), и список просто хранит ссылки на них.
- При удалении элементов память под массив может быть перераспределена — это управляется внутренними функциями
  `list_resize()`.

---

## Слоты list'а (PyList_Type)

```c
PyTypeObject PyList_Type = {
    PyVarObject_HEAD_INIT(&PyType_Type, 0)  // Наследуем от type
    "list",                    // tp_name
    sizeof(PyListObject),      // tp_basicsize
    0,                         // tp_itemsize (переменная часть в ob_item)
    
    (destructor)list_dealloc,  // tp_dealloc
    0,                         // tp_print
    0,                         // tp_getattr
    0,                         // tp_setattr
    0,                         // tp_reserved
    list_repr,                 // tp_repr -> str(list)
    
    0,                         // tp_as_number
    &list_as_sequence,         // tp_as_sequence <- ВАЖНО!
    0,                         // tp_as_mapping
    (hashfunc)PyObject_HashNotImplemented,  // tp_hash (списки не хешируемы)
};
```

### Общее

`PyList_Type` — это **определение типа `list` на уровне C** внутри интерпретатора CPython.  
Эта структура описывает, как Python должен работать со списками: как их создавать, удалять, представлять в виде строки и
какие операции они поддерживают.  
По сути, это “паспорт” встроенного типа `list`, с которым работает любая функция `type()` и весь механизм ООП Python.

### Описание

- `PyVarObject_HEAD_INIT(&PyType_Type, 0)` — инициализирует заголовок типа.  
  Указывает, что `list` — это **объект типа `type`** (в Python всё — объект, включая классы).  
  Второй параметр `0` — это базовый размер для `_var`-части (переменная длина задаётся отдельно).

- `"list"` — имя типа, которое возвращает `type([]).__name__`.

- `sizeof(PyListObject)` — базовый размер структуры в памяти (заголовок + указатели, без элементов).

- `tp_itemsize = 0` — размер дополнительного элемента в переменных частях структуры не используется, потому что список
  хранит данные через `ob_item` (указатель на отдельный массив).

- `(destructor)list_dealloc` — функция, которая освобождает память списка при удалении (`tp_dealloc`).

- `list_repr` — функция, которая формирует строковое представление (`repr(list)` или `str(list)`).

- `&list_as_sequence` — ссылка на таблицу функций, описывающих поведение списка как **последовательности** (sequence
  protocol).  
  Именно отсюда берутся операции `len(lst)`, `lst[i]`, `lst.append()` и `lst[i:j]`.

- `(hashfunc)PyObject_HashNotImplemented` — указывает, что список **нельзя хешировать** (поэтому `hash([])` вызывает
  ошибку).

### Уточнения

- `PyList_Type` хранится в памяти как **глобальная структура**, доступная интерпретатору для всех операций со списками.
- В ней много других полей, которые здесь не показаны (например, для инициализации, копирования, итераций).
- Протокол `tp_as_sequence` делает список совместимым с универсальными функциями Python, которые работают со всеми
  последовательностями (`tuple`, `str` и др.).
- Поскольку список изменяемый, Python специально запрещает его хеширование, чтобы не нарушать поведение словарей и
  множеств.

---

## Доступ к элементу у list

```c
static PyObject *list_item(PyListObject *self, Py_ssize_t i) {
    if (i < 0 || i >= Py_SIZE(self)) {
        PyErr_SetString(PyExc_IndexError, "list index out of range");
        return NULL;
    }
    Py_INCREF(self->ob_item[i]);   // Увеличиваем refcnt
    return self->ob_item[i];       // Возвращаем элемент
}
```

### Общее

`list_item` — это внутренняя C‑функция, которая реализует поведение **доступа к элементу списка по индексу** — то есть
выражение `lst[i]` в Python.  
Она безопасно проверяет границы индекса и возвращает нужный элемент, корректно управляя счётчиком ссылок (чтобы объект
не был удалён преждевременно).

### Описание

- `if (i < 0 || i >= Py_SIZE(self))` — проверка выхода за границы.  
  Функция `Py_SIZE(self)` возвращает текущее количество элементов (`ob_size` из `PyListObject`).  
  Если индекс меньше нуля или больше последнего элемента, выбрасывается исключение `IndexError`.

- `PyErr_SetString(PyExc_IndexError, "list index out of range");` — создаёт и поднимает стандартное исключение Python,
  полностью аналогичное тому, что видит пользователь.

- `Py_INCREF(self->ob_item[i]);` — увеличивает счётчик ссылок на возвращаемый объект, чтобы гарантировать, что он не
  удалится из памяти, пока Python-код им пользуется.

- `return self->ob_item[i];` — возвращает указатель на объект, находящийся по данному индексу (элемент списка).

### Уточнения

- Проверка диапазона обязательна, потому что в C нет защиты от обращения к памяти за пределами массива — это
  предотвращает падения интерпретатора.
- В Python отрицательные индексы (`lst[-1]`) обрабатываются **на более высоком уровне** — сюда уже приходит вычисленный
  положительный индекс.
- Увеличение `refcount` обеспечивает **безопасность памяти**: даже если элемент будет удалён из списка, ссылка,
  возвращённая из этой функции, останется действительной в пользовательском коде.
- Эта функция является частью реализации **sequence protocol**, который отвечает за операции индексирования и срезов.

---

# bytes (PyBytesObject)

```c
// Файл: Objects/bytesobject.c (CPython 3.9+)
// PyBytesObject - структура bytes
typedef struct {
    PyObject_VAR_HEAD
    char ob_sval[1];  // гибкий массив байтов (об_sval[length])
} PyBytesObject;
```

### Общее

Этот блок кода определяет структуру `PyBytesObject` — внутреннее представление объекта `bytes` в CPython. Она наследует
`PyObject_VAR_HEAD` для базовых полей (refcnt, type, размер) и добавляет гибкий массив `ob_sval[]` для хранения самих
байтов данных сразу после заголовка.

### Описание

`PyObject_VAR_HEAD` расширяется в `PyObject ob_base` (refcnt + obtype) плюс `Py_ssize_t ob_size` (длина в байтах).
`char ob_sval[1]` — это C-трюк с flexible array member: компилятор видит минимум 1 байт, но при выделении памяти (
`PyObject_MALLOC`) добавляется столько байтов, сколько указано в `ob_size`. Байты хранятся компактно: `&obj->ob_sval[0]`
сразу после заголовка.

### Уточнения

- Размер в памяти: 24 байта заголовок (64-бит) + `ob_size` байтов данных.
- Неизменяемый: после создания `ob_sval` не меняется, только refcnt управляет жизнью.
- Python 3.9+: `PyBytes_Type.tp_basicsize = sizeof(PyBytesObject)-1`, чтобы формулы вроде `PyBytesObject_SIZE + length`
  работали правильно.
- Доступ к байтам: `((PyBytesObject*)obj)->ob_sval[i]` или `PyBytes_AS_STRING(obj)`.
- Null-терминирован: `ob_sval[ob_size] = '\0'` для C-строк совместимости.

---

# Создание bytes (PyBytesObject)

```c
// Основной конструктор bytes(string, encoding) или bytes(length)
PyObject *
PyBytes_FromStringAndSize(const char *str, Py_ssize_t size)
{
    PyBytesObject *op;
    
    if (size < 0) {
        PyErr_SetString(PyExc_ValueError, "negative size");
        return NULL;
    }
    
    /* Выделяем память: заголовок + size байтов данных */
    op = (PyBytesObject *)PyObject_MALLOC(size + sizeof(PyBytesObject) - 1);
    if (unlikely(op == NULL))
        return PyErr_NoMemory();
    
    /* Инициализируем: refcnt=1, type=PyBytes_Type, obsize=size */
    PyObject_INIT_VAR(op, &PyBytes_Type, size);
    
    if (str != NULL)
        memcpy(op->ob_sval, str, (size_t)size);
    
    /* Null-терминатор для C-строк */
    op->ob_sval[size] = '\0';
    
    return (PyObject *)op;
}

// bytes() - пустой объект
PyObject *
PyBytes_FromString(const char *str)
{
    return PyBytes_FromStringAndSize(str, strlen(str));
}
```

### Общее

Создание `PyBytesObject` — это выделение памяти под заголовок `PyVarObject` плюс нужное количество байтов данных.
CPython хранит байты компактно сразу после заголовка в поле `ob_sval[]`, делая объект быстрым и экономным по памяти.

### Описание

`PyBytes_FromStringAndSize()` сначала проверяет size ≥ 0, потом выделяет память формулой
`sizeof(PyBytesObject)-1 + size` (минус 1, потому что `ob_sval[1]` уже в структуре). `PyObject_INIT_VAR` устанавливает
refcnt=1, тип `PyBytes_Type` и длину `obsize=size`. Байты копируются в `ob_sval[]`, добавляется `'\0'` для
C-совместимости.

### Уточнения

- `PyObject_VAR_HEAD` расшифровывается в refcnt + obtype + obsize (24 байта на 64-бит).
- `ob_sval[1]` — трюк C: компилятор требует минимум 1 байт, но `MALLOC` даёт столько, сколько нужно.
- Память под bytes не попадает в GC, только refcnt — поэтому `PyObject_MALLOC` вместо `PyObject_GC_New`.
- `PyBytes_Type.tp_basicsize = sizeof(PyBytesObject)-1`, чтобы `PyBytesObject_SIZE` считал правильно.
- Python 3.9+: bytes неизменяемы, как str, но для 0-255 байтов (не unicode).

---

# bytearray (...)

```c
// Файл: Objects/bytearrayobject.c (CPython 3.9+)
// PyByteArrayObject - структура bytearray (изменяемый bytes)
typedef struct {
    PyObject_VAR_HEAD
    Py_ssize_t ob_alloc;  // выделенная ёмкость (capacity)
    char *ob_bytes;       // указатель на изменяемый буфер байтов
} PyByteArrayObject;
```

### **Общее**

- Эта структура описывает внутреннее устройство объекта `bytearray` в CPython (конкретно — его реализацию на языке C в
  исходном коде интерпретатора).
- `bytearray` — это изменяемая последовательность байтов, аналогично `bytes`, но с возможностью изменения содержимого
  без пересоздания объекта.
- Структура используется внутри интерпретатора Python для управления памятью и хранением байтовых данных.

### **Описание**

- `typedef struct { ... } PyByteArrayObject;` — объявление типа структуры в C для представления Python-объекта
  `bytearray`.
- `PyObject_VAR_HEAD` — макрос, который добавляет стандартные служебные поля, общие для всех переменных объектов
  Python (в том числе счётчик ссылок и указатель на тип). Он также хранит текущее количество элементов (`ob_size`).
- `Py_ssize_t ob_alloc;` — размер выделенной под байты памяти (в байтах). Он может быть больше фактической длины
  `bytearray`, чтобы избежать частого перевыделения памяти при росте.
- `char *ob_bytes;` — указатель на область памяти, где физически хранятся байты. Это изменяемый буфер, на который
  ссылается объект `bytearray`.

### **Уточнения**

- `Py_ssize_t` — это знаковый тип, используемый в CPython для хранения размеров и индексов (безопасно заменяет обычный
  `int` при работе с большими объектами).
- `PyObject_VAR_HEAD` обеспечивает совместимость `bytearray` с механизмами Python-объектов — например, с подсчётом
  ссылок и системой типов.
- В отличие от `bytes`, где данные хранятся в неизменяемом массиве, `bytearray` использует `ob_bytes` как изменяемый
  буфер, что позволяет функции вроде `bytearray.append()` работать без пересоздания объекта.

---

# Создание bytearray (PyByteArrayObject)

```c
// Файл: Objects/bytearrayobject.c (CPython 3.9+)
// Основной конструктор bytearray(string) или bytearray(length)
PyObject *
PyByteArray_FromStringAndSize(const char *string, Py_ssize_t len)
{
    PyByteArrayObject *result;
    
    if (len < 0) {
        PyErr_SetString(PyExc_ValueError, "negative count");
        return NULL;
    }
    
    /* Выделяем структуру PyByteArrayObject */
    result = (PyByteArrayObject *)PyObject_MALLOC(sizeof(PyByteArrayObject));
    if (unlikely(result == NULL))
        return PyErr_NoMemory();
    
    /* Инициализируем: refcnt=1, type=PyByteArray_Type, obsize=len */
    PyObject_INIT_VAR(result, &PyByteArray_Type, len);
    
    /* Выделяем отдельный буфер для изменяемых байтов */
    result->ob_alloc = len;
    result->ob_bytes = (char *)PyObject_MALLOC(len ? len : 1);
    if (unlikely(result->ob_bytes == NULL)) {
        PyObject_DEL(result);
        return PyErr_NoMemory();
    }
    
    if (string != NULL)
        memcpy(result->ob_bytes, string, (size_t)len);
    
    return (PyObject *)result;
}

// bytearray() - пустой bytearray
PyObject *
PyByteArray_Dup(PyByteArrayObject *ba)
{
    return PyByteArray_FromStringAndSize(ba->ob_bytes, Py_SIZE(ba));
}
```

### Общее

Создание `PyByteArrayObject` — это выделение структуры плюс отдельного изменяемого буфера байтов. В отличие от `bytes`,
где данные встраиваются в объект, `bytearray` держит `ob_bytes` как указатель на внешнюю память, что позволяет легко
менять размер и содержимое.

### Описание

`PyByteArray_FromStringAndSize()` сначала проверяет len ≥ 0. Выделяет фиксированную структуру `PyByteArrayObject` (24+
байта), инициализирует через `PyObject_INIT_VAR`. Отдельно выделяет буфер `ob_bytes` (минимум 1 байт даже для пустого).
`ob_alloc = len` фиксирует ёмкость, байты копируются, возвращается PyObject*.

### Уточнения

- Два отдельных `PyObject_MALLOC`: структура + данные (независимая жизнь).
- `ob_alloc` отслеживает выделенную ёмкость, `ob_size` — текущую длину (может расти).
- Пустой `bytearray()`: `ob_bytes` указывает на 1 байт, `ob_size=0`, `ob_alloc=0`.
- Python 3.9+: при `append()` проверяется `ob_size < ob_alloc`, иначе realloc большего буфера.
- Очистка: `bytearrayobject_dealloc()` освобождает оба `PyObject_FREE`.

---

# set (PySetObject)

```c
// Файл: Objects/setobject.c (CPython 3.9+)
// PySetObject - структура set (хэш-таблица с уникальными элементами)
typedef struct {
    PyObject_HEAD
    Py_hash_t used;         // количество элементов
    Py_ssize_t fill;        // заполненные слоты
    Py_ssize_t mask;        // размер хэш-таблицы - 1 (2^n - 1)
    PyDictKeysObject *dk;   // общие ключи с dict (compact/ split)
} PySetObject;
```

**Общее**

- Эта структура описывает внутреннее устройство объекта `set` (множества) в CPython.
- `set` хранит уникальные элементы и построен на основе хэш-таблицы, аналогично `dict`, но без значений — у множества
  есть только ключи.
- Структура определяет, как Python управляет памятью, хранит элементы и рассчитывает хэши для быстрой проверки
  принадлежности (`in`) или вставки.

**Описание**

- `typedef struct { ... } PySetObject;` — объявление структуры в языке C, которая представляет объект типа `set` внутри
  интерпретатора.
- `PyObject_HEAD` — стандартный макрос, добавляющий служебную информацию о Python-объекте (счётчик ссылок и указатель на
  тип).
- `Py_hash_t used` — количество активных (реальных) элементов в множестве, то есть тех, что сейчас существуют.
- `Py_ssize_t fill` — общее количество занятых ячеек в хэш-таблице (включает удалённые и активные элементы);
  используется для управления переразмериванием таблицы.
- `Py_ssize_t mask` — маска размера таблицы (`size - 1`), где размер всегда является степенью двойки. Применяется для
  быстрого вычисления позиции элемента через побитовые операции.
- `PyDictKeysObject *dk` — указатель на структуру, общую с реализацией словаря (`dict`), в которой фактически хранится
  хэш-таблица и связанные с ней ключи.

**Уточнения**

- `PyDictKeysObject` используется и для `dict`, и для `set`, что позволяет переиспользовать оптимизированную реализацию
  хранения хэшей и ключей.
- Поскольку `set` хранит только ключи (без значений), часть структуры `PyDictKeysObject`, отвечающая за значения,
  остаётся неиспользованной.
- Поле `mask` определяет диапазон индексов в хэш-таблице: индекс вычисляется как `hash(key) & mask`.
- `used` и `fill` помогают интерпретатору определить, когда требуется увеличить или уплотнить таблицу, чтобы
  поддерживать эффективность операций.

---

# Создание set (PySetObject)

```c
// Файл: Objects/setobject.c (CPython 3.9+)
// set([iterable]) - основной конструктор
PyObject *
PySet_New(PyObject *iterable)
{
    PySetObject *so;
    Py_ssize_t estimate;
    
    /* Оцениваем начальный размер */
    if (iterable == NULL)
        estimate = 0;
    else {
        estimate = PyObject_Length(iterable);
        if (estimate < 0)
            return NULL;
    }
    
    /* Выделяем с GC (set участвует в сборке мусора) */
    so = PyObject_GC_New(PySetObject, &PySet_Type);
    if (so == NULL)
        return NULL;
    
    so->used = 0;        // элементов пока нет
    so->fill = 0;        // слотов заполнено
    so->mask = 0;        // хэш-таблица пустая
    so->dk = NULL;       // ключи пока не созданы
    
    if (estimate > 0) {
        /* Создаём хэш-таблицу подходящего размера */
        if (set_table_resize(so, estimate) < 0) {
            Py_DECREF(so);
            return NULL;
        }
        /* Добавляем все элементы из iterable */
        if (_PySet_Update(so, iterable) < 0) {
            Py_DECREF(so);
            return NULL;
        }
    }
    
    PyObject_GC_Track(so);
    return (PyObject *)so;
}
```

### Общее

Создание `PySetObject` — это построение хэш-таблицы с оценкой начального размера и автоматическим добавлением элементов.
CPython использует GC-объект, чтобы set мог участвовать в цикличной сборке мусора, и общую с `dict` структуру ключей для
экономии памяти.

### Описание

`PySet_New()` сначала узнаёт примерный размер через `PyObject_Length()`. Выделяет `PySetObject` с GC-поддержкой,
обнуляет счётчики. `set_table_resize()` создаёт хэш-таблицу степени двойки большего размера (load factor ~2/3).
`_PySet_Update()` проходит по iterable, хэширует каждый элемент и вставляет с обработкой коллизий. В конце объект
отслеживается GC.

### Уточнения

- `estimate` помогает выбрать размер хэш-таблицы без лишних ресайзов.
- `PyObject_GC_New` вместо `PyObject_MALLOC` — для `tp_traverse` и циклических ссылок.
- Пустой `set()`: все поля 0, `dk=NULL` (compact mode до 5 элементов).
- Python 3.9+: `used` считает только уникальные хэшируемые элементы, дубли пропускаются.
- Не-хэшируемые элементы (list, dict) дают `TypeError: unhashable type`.

---

# frozenset (PySetObject)

```c
// Файл: Objects/setobject.c (CPython 3.9+)
// PySetObject используется для обоих set и frozenset
typedef struct {
    PyObject_HEAD
    Py_hash_t used;         // количество элементов
    Py_ssize_t fill;        // заполненные слоты  
    Py_ssize_t mask;        // размер хэш-таблицы - 1 (2^n - 1)
    PyDictKeysObject *dk;   // общие ключи с dict
} PySetObject;
```

**Общее**

- Эта структура описывает внутреннее устройство объектов `set` и `frozenset` в CPython — оба типа реализованы на одной
  базе.
- Оба представляют собой хэш-таблицу, где хранятся только уникальные элементы, но `set` изменяем, а `frozenset` — нет.
- Цель этой структуры — управлять размещением элементов, их хэшами и оптимизацией доступа (например, при проверке
  «элемент есть в множестве»).

**Описание**

- `PyObject_HEAD` — стандартная часть каждой структуры объекта Python, содержит служебные поля: указатель на тип и
  счётчик ссылок.
- `Py_hash_t used` — текущее количество элементов в множестве (активных записей).
- `Py_ssize_t fill` — количество занятых ячеек в хэш-таблице, включая удалённые и активные элементы; помогает определить
  степень заполнения.
- `Py_ssize_t mask` — используется для вычисления индекса в таблице (`hash & mask`), где `mask = size - 1`, а размер
  всегда равен степени двойки.
- `PyDictKeysObject *dk` — ссылка на общую структуру ключей, используемую и в `dict`; фактически хранит хэш-таблицу, в
  которой лежат ключи (элементы множества).

**Уточнения**

- Хотя `PySetObject` используется и для `set`, и для `frozenset`, разница в поведении достигается флагами и логикой на
  уровне Python API, а не структурой данных.
- `used` и `fill` позволяют определять, когда нужно увеличить или реструктурировать таблицу для поддержания
  производительности.
- Переиспользование `PyDictKeysObject` обеспечивает эффективность и уменьшает дублирование кода между реализациями
  `dict` и `set`.
- Для операций вроде поиска элемента Python использует значение хэша и поле `mask`, что делает доступ к элементам
  множества очень быстрым (амортизированное O(1)).

---

# Создание frozenset (PySetObject)

```c
// Файл: Objects/setobject.c (CPython 3.9+)
// frozenset([iterable]) - конструктор неизменяемого множества
PyObject *
PyFrozenSet_New(PyObject *iterable)
{
    PySetObject *result;
    Py_ssize_t estimate;
    
    /* Оцениваем начальный размер хэш-таблицы */
    if (iterable == NULL)
        estimate = 0;
    else {
        estimate = PyObject_Length(iterable);
        if (estimate < 0)
            return NULL;
    }
    
    /* Выделяем GC-объект с типом frozenset */
    result = PyObject_GC_New(PySetObject, &PyFrozenSet_Type);
    if (result == NULL)
        return NULL;
    
    result->used = 0;    // элементов пока нет
    result->dk = NULL;   // ключи не созданы
    
    if (estimate > 0) {
        /* Создаём хэш-таблицу подходящего размера */
        if (set_table_resize(result, estimate) < 0) {
            Py_DECREF(result);
            return NULL;
        }
        /* Заполняем уникальными элементами */
        if (_PySet_Update(result, iterable) < 0) {
            Py_DECREF(result);
            return NULL;
        }
    }
    
    PyObject_GC_Track(result);
    return (PyObject *)result;
}
```

### Общее

Создание `frozenset` — это построение неизменяемой хэш-таблицы с теми же механизмами, что у `set`, но с типом
`PyFrozenSet_Type`. CPython использует одну структуру `PySetObject` для экономии, блокируя мутации на уровне
`tp_as_sequence` и `tp_as_mapping`.

### Описание

`PyFrozenSet_New()` оценивает размер через `PyObject_Length()`. Выделяет `PySetObject` с GC и типом `PyFrozenSet_Type`.
`set_table_resize()` создаёт хэш-таблицу степени двойки. `_PySet_Update()` добавляет элементы из iterable, автоматически
удаляя дубликаты и проверяя хэшируемость. Объект помечается для GC-отслеживания.

### Уточнения

- `PyFrozenSet_Type` имеет `sq_ass_item = NULL`, `mp_ass_subscript = NULL` — мутации запрещены.
- Хэш вычисляется при создании и кэшируется в `PyDictKeysObject` для использования как dict-ключ.
- Python 3.9+: compact mode для малых frozenset (до 5 элементов без отдельной таблицы).
- Пустой `frozenset()`: все счётчики 0, идеален для дефолтных значений в dict.
- `TypeError` на не-хэшируемых элементах (list, set, dict).

---

# bool (PyBoolObject)

```c
// Файл: Objects/boolobject.c (CPython 3.9+)
// PyBoolObject - True/False (подтипы int)
typedef struct {
    PyLongObject longobj;  // наследует PyLongObject (int)
} PyBoolObject;
```

**Общее**

- Эта структура описывает внутреннее устройство объекта `bool` (`True` и `False`) в CPython.
- В Python тип `bool` является подтипом `int`, поэтому `True` и `False` — это не отдельные базовые типы, а
  специализированные экземпляры целых чисел (`1` и `0` соответственно).
- Структура показывает, что логические значения реализованы на основе уже готового механизма `PyLongObject`.

**Описание**

- `typedef struct { ... } PyBoolObject;` — объявление структуры для объекта `bool`.
- `PyLongObject longobj;` — это встраивание структуры `PyLongObject` (которая описывает `int` в Python). Благодаря этому
  `bool` наследует всю функциональность `int`, включая хранение значений и операции с ними.
- Таким образом, `PyBoolObject` не добавляет новых полей, а лишь определяет новый тип на базе существующего числового
  объекта.

**Уточнения**

- В интерпретаторе Python существуют только два экземпляра `PyBoolObject`: `Py_True` и `Py_False`, они создаются один
  раз при запуске (singleton-объекты).
- Значение поля `longobj` внутри `True` — это `1`, а у `False` — `0`.
- Такое решение экономит память и ускоряет операции, так как логические значения могут использовать ту же арифметическую
  инфраструктуру, что и целые числа.
- При проверке типов `bool` ведёт себя как отдельный тип, но при арифметических операциях — как `int`.

---

# Создание bool (PyBoolObject)

```c
// Файл: Objects/boolobject.c (CPython 3.9+)
// bool(x) - возвращает один из двух глобальных синглтонов
PyObject *
_PyBool_FromLong(long v)
{
    PyObject *result;
    
    if (v == 0) {
        result = Py_NewReference(Py_False);  // увеличивает refcnt False
    }
    else {
        result = Py_NewReference(Py_True);   // увеличивает refcnt True
    }
    
    return result;
}

// Универсальный bool() для Python объектов
PyObject *
PyObject_IsTrue(PyObject *v)
{
    if (v == Py_None)
        Py_RETURN_FALSE;
    if (v == Py_True)
        Py_RETURN_TRUE;
    if (v == Py_False)
        Py_RETURN_FALSE;
    
    return _PyBool_FromLong(PyObject_IsTruthy(v));
}

// Инициализация синглтонов (Python/pythonrun.c)
void _PyBool_Init(void)
{
    Py_True = (PyObject *)_PyLong_New(1L);   // int 1 -> True
    Py_False = (PyObject *)_PyLong_New(0L);  // int 0 -> False
    Py_SET_TYPE(Py_True, &PyBool_Type);
    Py_SET_TYPE(Py_False, &PyBool_Type);
}
```

### Общее

Создание `bool(...)` не создаёт новые объекты — всегда возвращает один из двух глобальных синглтонов `Py_True`/
`Py_False`. Это супероптимизация: экономия памяти, постоянные `id(True)`, мгновенные сравнения `if x is True`.

### Описание

`_PyBool_FromLong()` преобразует C `long` в синглтон: 0 → `Py_False`, иначе → `Py_True` через `Py_NewReference()` (
только +1 к refcnt). `PyObject_IsTrue()` для Python-объектов проверяет специальные случаи (None, True/False) и вызывает
`PyObject_IsTruthy()` (длина>0 для контейнеров). Синглтоны создаются при запуске интерпретатора из int 0/1.

### Уточнения

- `Py_NewReference()` не выделяет память, только `Py_INCREF()`.
- `PyBool_Type` наследует от `PyLong_Type`, поэтому `bool(1) is True`.
- Python 3.9+: `tp_richcompare` оптимизирован для `is True/False`.
- `bool([]) == False` через `PyObject_Length([]) == 0`.
- Синглтоны бессмертны: refcnt никогда не 0, `tp_dealloc` не вызывается.

---

# NoneType (PyNoneObject)

```c
// Файл: Objects/noneobject.c (CPython 3.9+)
// PyNoneObject - единственный объект None
typedef struct {
    PyObject_HEAD
} PyNoneObject;
```

**Общее**

- Эта структура описывает объект `None` в CPython — единственный экземпляр специального значения, обозначающего «ничего»
  или «отсутствие значения».
- `None` существует в единственном экземпляре в программе (singleton), и любая ссылка на `None` указывает на один и тот
  же объект.
- Сам объект не хранит дополнительных данных — он используется только как специальный маркер.

**Описание**

- `typedef struct { ... } PyNoneObject;` — объявление структуры для объекта `None`.
- `PyObject_HEAD` — стандартная часть любой Python-структуры, содержащая служебную информацию: указатель на тип (
  `PyTypeObject *ob_type`) и счётчик ссылок (`Py_ssize_t ob_refcnt`).
- Внутри `PyNoneObject` нет других полей, потому что `None` не содержит данных и не нуждается в дополнительном
  состоянии.

**Уточнения**

- В CPython есть только одна глобальная переменная `Py_None`, представляющая этот объект. Все операции с `None`
  используют именно её.
- `None` имеет собственный тип `NoneType`, который создан один раз и не может порождать новые экземпляры.
- Такое устройство делает проверки вроде `x is None` максимально быстрыми, так как сравниваются указатели, а не
  содержимое.
- Поскольку `None` не хранит значение, а только сам факт «пустоты», структура остаётся минимальной и содержит только
  базовые поля объекта Python.

---

## Создание NoneType (PyNoneObject)

```c
// Файл: Objects/noneobject.c + Python/pythonrun.c (CPython 3.9+)
// Создание единственного None - происходит ОДИН раз при запуске
void
_PyNone_Init(void)
{
    PyNoneObject *none;
    
    none = (PyNoneObject *)PyObject_MALLOC(sizeof(PyNoneObject));
    if (none == NULL)
        Py_FatalError("can't initialize Py_None");
    
    /* Инициализация: refcnt=1, type=PyNone_Type */
    PyObject_INIT(none, &PyNone_Type);
    
    /* Глобальная переменная для всех None */
    Py_None = (PyObject *)none;
}

// Получение ссылки на None (НЕ создание!)
PyObject *
Py_NewReference(Py_None)
{
    Py_INCREF(Py_None);
    return Py_None;
}

// PyNone_Type (Objects/noneobject.c)
PyTypeObject PyNone_Type = {
    PyVarObject_HEAD_INIT(&PyType_Type, 0)
    .tp_name = "NoneType",
    .tp_basicsize = sizeof(PyNoneObject),  // всего PyObject_HEAD
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_IMMUTABLETYPE,
};
```

### Общее

`NoneType` не создаётся конструктором — существует ровно один глобальный объект `Py_None`, выделенный при старте
интерпретатора. Все `None` в Python — это ссылка на него через `Py_INCREF(Py_None)`.

### Описание

`_PyNone_Init()` вызывается при инициализации CPython: выделяется минимальная `PyNoneObject` через `PyObject_MALLOC`,
инициализируется `PyObject_INIT` (refcnt=1, type=PyNone_Type), присваивается глобальной `Py_None`. Доступ через
`Py_NewReference(Py_None)` только увеличивает refcnt без выделения памяти.

### Уточнения

- Создание происходит ОДИН раз в `_Py_InitializeEx()`.
- `sizeof(PyNoneObject) == sizeof(PyObject)` — только refcnt + type.
- Python 3.9+: `Py_TPFLAGS_IMMUTABLETYPE` блокирует подклассы None.
- `Py_RETURN_NONE` макрос: `Py_INCREF(Py_None); return Py_None;`.
- Бессмертный синглтон: интерпретатор держит refcnt > 0 вечно.

---

## GC-интеграция для контейнеров

```c
// list_traverse - обход ссылок для GC
static int list_traverse(PyListObject *o, visitproc visit, void *arg) {
    Py_ssize_t i = 0;
    Py_ssize_t len = Py_SIZE(o);
    for (; i < len; i++) {
        Py_VISIT(o->ob_item[i]);  // Отмечаем каждый элемент как живой
    }
    return 0;
}

// list_clear - разрыв циклических ссылок
static int list_clear(PyListObject *o) {
    Py_ssize_t i = 0;
    Py_ssize_t len = Py_SIZE(o);
    for (; i < len; i++) {
        Py_XDECREF(o->ob_item[i]);  // Уменьшаем refcnt элементов
        o->ob_item[i] = NULL;       // NULL'им ссылки
    }
    return 0;
}
```

### Общее

`list_traverse` и `list_clear` — внутренние функции CPython для **работы с сборщиком мусора (GC)**.  
Они помогают Python находить циклические ссылки и правильно освобождать память при удалении списка.  
Вызываются автоматически при сборке мусора или уничтожении объекта.

### Описание

- **`list_traverse(PyListObject *o, visitproc visit, void *arg)`** — обход всех элементов списка:
    - `Py_SIZE(o)` — получает длину списка (`ob_size`).
    - `Py_VISIT(o->ob_item[i])` — вызывает callback `visit()` для каждого элемента, помечая его как "живой" (доступный).
    - Возвращает `0` — успех обхода.

- **`list_clear(PyListObject *o)`** — очищает список от ссылок:
    - `Py_XDECREF(o->ob_item[i])` — уменьшает счётчик ссылок элемента (если он был 1, элемент удаляется).
    - `o->ob_item[i] = NULL` — обнуляет ссылку в списке, разрывая циклические связи.
    - Возвращает `0` — успех очистки.

### Уточнения

- `Py_VISIT()` и `Py_XDECREF()` — **стандартные макросы CPython** для безопасного управления ссылками в GC.
- `list_traverse` используется **generational GC** для предотвращения утечек памяти при циклах (список ссылается на
  себя).
- `list_clear` вызывается в `list_dealloc()` перед освобождением памяти, чтобы элементы могли быть собраны GC.
- Обе функции работают за **O(n)** — линейное время пропорционально длине списка.

---

## Байткод-интеграция: LIST_APPEND

```c
case LIST_APPEND: {
    PyObject *v = TOP();              // Берём значение с вершины стека
    PyObject *list = PEEK(oparg + 1); // Берём список из фиксированной позиции
    Py_ssize_t index = oparg;         // Индекс списка в localsplus
    
    // Вызываем list.append(v)
    int err = PyList_Append(list, v);
    Py_DECREF(v);                     // Освобождаем значение
    
    if (err == 0) {
        STACKADJ(-1);                 // Убираем значение со стека
    } else {
        // Ошибка - прерываем выполнение
        break;
    }
    DISPATCH_SAME_OPARG(1);           // Следующая инструкция
}
```

### Общее

Этот код — **часть байткод-интерпретатора CPython**, обрабатывающая инструкцию `LIST_APPEND`.  
Она реализует операцию `list.append(v)` на уровне виртуальной машины Python.  
Выполняется при вызове `lst.append(value)` в Python-коде.
Инструкция `LIST_APPEND` в байт-коде Python оптимизирована для работы с генераторами списков (list comprehensions),
например `[x for x in lst]`.

### Описание

- `PyObject *v = TOP();` — берёт **значение** с вершины стека виртуальной машины (то, что добавляем в список).
- `PyObject *list = PEEK(oparg + 1);` — берёт **список** из стека по смещению `oparg + 1` (список уже лежит ниже).
- `Py_ssize_t index = oparg;` — `oparg` содержит индекс списка в локальных переменных (`localsplus`).
- `int err = PyList_Append(list, v);` — вызывает стандартную функцию добавления в конец списка.
- `Py_DECREF(v);` — уменьшает счётчик ссылок значения (оно больше не нужно на стеке).
- `STACKADJ(-1);` — убирает значение со стека (при успехе остаётся только список).
- `DISPATCH_SAME_OPARG(1);` — переходит к следующей инструкции байткода.

### Уточнения

- `LIST_APPEND` — **оптимизированная инструкция** Python 3.9+, ускоряет `append()` за счёт прямого вызова C-функции.
- `TOP()` и `PEEK()` — макросы для доступа к стековой машине (frame->stack).
- `PyList_Append()` автоматически увеличивает `allocated`, если список заполнен (over-allocation).
- При ошибке (`err != 0`) выполнение прерывается, выбрасывая исключение (например, `TypeError`).
- `DISPATCH_SAME_OPARG(1)` — "быстрый dispatch" без изменения аргумента операции.

---

[Содержание](/CONTENTS.md#содержание)
