# **Типы данных**

## **Junior Level**

Типы данных в Python делятся на **изменяемые** (mutable) и **неизменяемые** (immutable).

**Простые типы:**

- Числа: `int`, `float`, `decimal`, `complex`
- Строки: `str`
- Логические значения: `bool`
- Специальный тип: `NoneType` (единственное значение `None`)

**Коллекционные типы:**

- `list` — изменяемая упорядоченная коллекция
- `tuple` — неизменяемая упорядоченная коллекция
- `dict` — изменяемая коллекция пар «ключ-значение» (упорядоченная с Python 3.7)
- `set` / `frozenset` — изменяемое и неизменяемое множества уникальных элементов
- `bytes` / `bytearray` — неизменяемая и изменяемая последовательности байтов

## **Middle Level**

1. **Ключевые различия мутабельности:**
    - **Изменяемые:** `list`, `dict`, `set`, `bytearray`, пользовательские классы. Можно модифицировать после создания.
    - **Неизменяемые:** `int`, `float`, `decimal`, `str`, `bytes`, `tuple`, `frozenset`, `bool`, `NoneType`. Любая
      операция создаёт новый объект.

2. **Практические следствия:**
    - Передача изменяемых объектов в функции позволяет модифицировать оригинал
    - Только неизменяемые объекты могут быть ключами словаря (требуется хэшируемость)
    - Мутабельность влияет на потокобезопасность и кэширование

3. **Специфика типов:**
    - `None` — синглтон, обозначающий отсутствие значения
    - `bool` — подкласс `int`, значения `True` и `False` — синглтоны
    - `tuple` — неизменяем, но может содержать изменяемые элементы
    - `set`/`frozenset` — хранят только хэшируемые элементы, реализация аналогична словарям без значений

## **Senior Level**

В CPython **все типы данных** наследуют от базовой структуры `PyObject`, которая содержит refcount и указатель на тип.
Каждый тип описывается массивом **слотов** в `PyTypeObject`.
`Include/object.h`, `Include/cpython/object.h`

## 1. Базовая структура PyObject

```c
typedef struct _object {
    _PyObject_HEAD_EXTRA       // Платформо-зависимые поля для отладки (PyDebug)
    Py_ssize_t ob_refcnt;      // Счётчик ссылок - при 0 вызывается tp_dealloc
    struct _typeobject *ob_type; // Указатель на PyTypeObject описывающий тип
} PyObject;
```

# Описание структуры PyObject в CPython

## Общее

Это **фундаментальная C-структура из ядра CPython**, которая представляет любой объект в Python на самом низком уровне.
Каждый объект в Python — будь то число, строка, список или ваш собственный класс — в памяти выглядит как экземпляр этой
структуры. Она содержит три ключевых компонента: счётчик ссылок (для управления памятью), указатель на тип объекта и
служебные поля для отладки.

## Описание

**Отладочная информация:**

- `_PyObject_HEAD_EXTRA` — это не одно поле, а макрос, который раскрывается в дополнительные платформо-зависимые поля *
  *только в отладочных сборках Python** (когда интерпретатор скомпилирован с флагом `--with-pydebug`). В обычных сборках
  это ничего не добавляет. Используется для отслеживания проблем с памятью.

**Счётчик ссылок:**

- `ob_refcnt` — целое число, которое **считает, сколько переменных или структур указывают на этот объект**. Когда
  счётчик становится 0, Python вызывает функцию `tp_dealloc` (из `PyTypeObject`) для освобождения памяти. Это основной
  механизм управления памятью в CPython (garbage collection через reference counting).

**Указатель на тип:**

- `ob_type` — указатель на структуру `PyTypeObject`, которая описывает тип этого объекта. Это то же самое, что
  возвращает встроенная функция `type(obj)` в Python. Через этот указатель интерпретатор узнаёт, как работать с
  объектом: какие операции он поддерживает, как получить его атрибуты, как его удалить.

## Уточнения

- **Reference counting — это не threading-safe по умолчанию**: В CPython счётчик ссылок работает за счёт глобальной
  блокировки (GIL — Global Interpreter Lock), поэтому многопоточность имеет ограничения. В Python 3.13+ появился режим
  free-threaded, где это иначе.

- **Минимальный размер**: Даже самый простой объект в памяти занимает как минимум столько байт, сколько занимает
  `PyObject` (обычно 16-24 байта на 64-битной системе в зависимости от конфигурации). Это почему в Python много памяти
  уходит на служебную информацию, даже для маленьких объектов.

- **ob_refcnt увеличивается и уменьшается постоянно**: Каждый раз, когда вы присваиваете объект переменной, счётчик
  увеличивается на 1. Когда переменная удаляется или переназначается, счётчик уменьшается на 1. Вы можете проверить это
  функцией `sys.getrefcount(obj)`.

- **Связь с PyTypeObject**: `PyObject` и `PyTypeObject` работают вместе: `PyObject` — это экземпляр, `PyTypeObject` —
  это описание класса. Например, объект `5` имеет `ob_type`, указывающий на `PyTypeObject` для типа `int`.

## 2. PyVarObject для контейнеров

```c
typedef struct {
    PyObject ob_base;          // Встроенный PyObject (refcnt + type)
    Py_ssize_t ob_size;        // Количество элементов (длина строки/списка)
} PyVarObject;
```

### Общее

- Это структура данных из исходного кода CPython (стандартной реализации Python, написанной на C).
- Она представляет собой расширенный заголовок для объектов, которые имеют переменную длину (количество элементов).
- Такие типы данных, как списки (`list`), кортежи (`tuple`) и строки (`str`), в памяти начинаются именно с этой
  структуры.

### Описание

- `typedef struct { ... } PyVarObject;` — конструкция языка C, создающая новый тип данных `PyVarObject`, описывающий,
  как объект лежит в оперативной памяти.
- `PyObject ob_base` — поле, внедряющее базовый объект внутрь. Оно содержит два критически важных элемента: счетчик
  ссылок (для сборщика мусора) и указатель на тип данных (класс объекта).
- `Py_ssize_t ob_size` — поле, хранящее количество элементов в объекте (значение, которое возвращает функция `len()`).
  Для списка это число слотов, для строки — количество символов.

### Уточнения

- Благодаря тому, что `ob_base` стоит первым, любой указатель на `PyVarObject` можно безопасно рассматривать как
  указатель на `PyObject`. Это позволяет функциям интерпретатора работать с любыми объектами (фиксированными и
  переменными) одинаково.
- Целые числа (`int`) в Python 3 также реализованы через `PyVarObject`, так как они поддерживают длинную арифметику и
  могут состоять из произвольного количества «цифр» в памяти.
- Доступ к длине объекта происходит за время O(1), так как интерпретатор просто читает значение `ob_size`, не
  пересчитывая элементы каждый раз.

## 3. PyTypeObject - "паспорт" каждого типа

```c
typedef struct _typeobject {
    PyVarObject ob_base;       // Тип сам является объектом (можно наследовать)
    
    const char *tp_name;       // Имя типа ("list", "dict", "int")
    Py_ssize_t tp_basicsize;   // Размер в байтах без переменной части
    Py_ssize_t tp_itemsize;    // Размер одного элемента переменной части
    
    destructor tp_dealloc;     // Функция уничтожения (list_dealloc)
    printfunc tp_print;        // Для print()
    reprfunc tp_repr;          // Для repr()
    
    // Протокол чисел
    PyNumberMethods *tp_as_number;  // nb_add, nb_sub, nb_multiply...
    
    // Протокол последовательностей
    PySequenceMethods *tp_as_sequence; // sq_item, sq_ass_slice...
    
    // Протокол маппингов
    PyMappingMethods *tp_as_mapping;  // mp_subscript, mp_ass_subscript
    
    // Поиск атрибутов
    getattrofunc tp_getattro;      // obj.attr
    setattrofunc tp_setattro;      // obj.attr = value
    
    // Дескрипторы (property, method)
    descrgetfunc tp_descr_get;     // __get__
    descrsetfunc tp_descr_set;     // __set__
    
    Py_ssize_t tp_dictoffset;      // Смещение __dict__ (или -1)
    Py_ssize_t tp_weaklistoffset;  // Смещение weakref списка
    
    PyObject *tp_mro;              // Method Resolution Order (tuple типов)
    PyObject *tp_cache;            // Кеш атрибутов (free-threaded)
    unsigned int tp_subclasses;    // Количество живых подклассов
    
    PyObject *tp_dict;             // __dict__ класса
    // ... 100+ слотов
} PyTypeObject;
```

# Описание структуры PyTypeObject в Python

## Общее

Это **внутренняя C-структура из ядра Python**, которая определяет тип объекта на самом низком уровне. Каждый класс и
встроенный тип в Python (list, dict, int, str) представлены в памяти именно такой структурой. Она содержит всю
метаинформацию о типе: имя, размер, методы обработки операций (сложение, индексирование), управление атрибутами и многое
другое. Это фундамент, на котором работает весь механизм объектно-ориентированного программирования в Python.

## Описание

**Базовая информация:**

- `ob_base` — каждый тип сам является объектом (в Python всё является объектом, включая сами типы)
- `tp_name` — строка с именем типа, которая выводится, например, при вызове `type(obj).__name__`
- `tp_basicsize` и `tp_itemsize` — память: базовый размер структуры плюс размер на один элемент для переменных
  контейнеров (список с 10 элементами занимает `basicsize + 10 * itemsize` байт)

**Управление жизненным циклом:**

- `tp_dealloc` — функция уничтожения объекта, вызывается при удалении (соответствует `__del__` на уровне C)
- `tp_print`, `tp_repr` — старый способ для вывода и представления (в Python 3.9+ `tp_print` устарел)

**Протоколы операций** — указатели на структуры с функциями для конкретных операций:

- `tp_as_number` — арифметические операции: `__add__`, `__sub__`, `__mul__` и т.д.
- `tp_as_sequence` — операции последовательностей: `obj[i]`, `obj[i:j]`, `len(obj)`
- `tp_as_mapping` — операции словарей: `obj[key]`, `len(obj)` для словарей

**Управление атрибутами:**

- `tp_getattro` / `tp_setattro` — низкоуровневые функции для доступа к атрибутам (`obj.attr` и `obj.attr = value`)

**Дескрипторы:**

- `tp_descr_get` / `tp_descr_set` — механизм дескрипторов, на котором работают `property`, методы класса, статические
  методы

**Служебная информация:**

- `tp_dictoffset` — смещение в памяти, где находится `__dict__` объекта (словарь атрибутов экземпляра)
- `tp_mro` — кортеж типов в порядке разрешения методов (Method Resolution Order) — порядок поиска атрибутов в иерархии
  наследования
- `tp_dict` — `__dict__` самого класса, где хранятся методы и атрибуты класса

## Уточнения

1. **C-структура, но видна из Python**: Вы не работаете с этой структурой напрямую в коде на Python, но когда пишете
   класс с методами `__add__`, `__getitem__` или `__get__`, Python переводит эти методы в соответствующие C-функции в
   этой структуре для производительности.

2. **tp_print устарел**: В Python 3.9+ поле `tp_print` более не используется. Вывод объектов управляется через `tp_repr`
   и `tp_str`.

3. **100+ слотов**: Код содержит комментарий «... 100+ слотов», что означает в реальной структуре есть множество
   дополнительных полей для специальных случаев, обработки исключений, сериализации и прочего. Здесь показаны только
   самые важные.

4. **Зачем это нужно знать**: Если вы пишете расширения на C для Python или оптимизируете критичные места, понимание
   этой структуры помогает правильно определить поведение типа. Для обычного Python-кода достаточно знать, что она
   существует.

5. **Про free-threaded**: Поле `tp_cache` относится к улучшениям для параллельного выполнения (free-threaded Python),
   актуально для Python 3.13+, для Python 3.9-3.12 на него можно не обращать внимание.

## 4. PyLongObject (int) - переменной точности

```c
typedef uint32_t digit;        // 30-битная цифра (2^30 = ~1e9)

typedef struct _longobject {
    PyObject_VAR_HEAD          // PyObject + ob_size (кол-во цифр)
    digit ob_digit[1];         // Массив цифр (размер ob_size)
} PyLongObject;
```

## Общее

`PyLongObject` — это внутренняя структура CPython, представляющая **все целые числа (`int`)** в Python.  
Даже обычное число `42` или огромный `10**1000` — это один и тот же тип объекта `PyLongObject`.  
Главная идея — хранить число не как одно значение, а как **массив “цифр”** в 30 бит, что позволяет поддерживать целые
числа любой длины (длинная арифметика).

## Описание

- `typedef uint32_t digit;` — определяет тип для хранения одной “цифры” числа. Каждая цифра занимает 32 бита, но реально
  используются только 30. Это оставляет запас для удобных вычислений без переполнений.  
  Например, большое число хранится как массив таких 30-битных частей.

- `PyObject_VAR_HEAD` — макрос, который вставляет в структуру стандартные поля из `PyVarObject`:
    - `ob_refcnt` — счётчик ссылок (для управления памятью).
    - `ob_type` — указатель на тип (`int`).
    - `ob_size` — количество “цифр” (`digit`) в числе и знак (если отрицательное, `ob_size` < 0).

- `digit ob_digit[1];` — первый элемент массива, в котором реально хранятся “цифры” числа.  
  Несмотря на размер `[1]`, массив в памяти может быть длиннее — его конечная длина задается `ob_size`.  
  Например, число `12345678901234567890` будет храниться как несколько элементов в этом массиве.

## Уточнения

- Такой подход позволяет Python-числам быть **неограниченно большими**, в отличие от фиксированной разрядности в C (
  `int`, `long`).
- Младшая цифра хранится первой (наименьший порядок) — это **младший разрядный порядок (little-endian)**.
- “30 бит на цифру” выбрано, чтобы при арифметических операциях с двумя цифрами не происходило переполнения 32‑битного
  регистра.
- Для маленьких чисел Python использует **кэш** заранее созданных объектов (от -5 до 256), чтобы не пересоздавать их в
  памяти.

**Создание PyLongObject:**

```c
PyObject *_PyLong_New(Py_ssize_t size) {
    PyLongObject *result;
    
    size = Py_ABS(size);  // Берем модуль размера
    
    // Выделяем память под заголовок + массив цифр
    result = PyObject_MALLOC(sizeof(PyLongObject) + 
                             (size-1) * sizeof(digit));
    if (!result) {
        return PyErr_NoMemory();
    }
    
    // Инициализируем как PyObject
    PyObject_INIT(result, &PyLong_Type);
    Py_SET_SIZE(result, size);  // Устанавливаем ob_size
    result->ob_digit[0] = 0;    // Нулевая цифра
    
    return (PyObject *)result;
}
```

## Общее

`_PyLong_New` — это внутренняя функция CPython, которая **создаёт объект целого числа (`int`) в памяти**.  
Она не вычисляет значение, а лишь выделяет и подготавливает структуру `PyLongObject`, чтобы Python мог потом записать
туда цифры числа.  
Используется внутри интерпретатора при создании или копировании больших чисел.

## Описание

- `PyObject *_PyLong_New(Py_ssize_t size)` — функция принимает количество “цифр” (`digit`), которые нужно
  зарезервировать для будущего числа.  
  Если `size` отрицательное, берётся модуль (`Py_ABS(size)`), т.к. знак хранится отдельно через `ob_size`.

- `PyObject_MALLOC(sizeof(PyLongObject) + (size - 1) * sizeof(digit))` — выделяет память под заголовок (`PyLongObject`)
  и нужное количество “цифр”.  
  В структуре уже есть один элемент `ob_digit[1]`, поэтому добавляется `(size - 1)`.

- `if (!result) return PyErr_NoMemory();` — если память не выделилась, Python выбрасывает ошибку `MemoryError`.

- `PyObject_INIT(result, &PyLong_Type);` — макрос инициализирует базовую часть как `PyObject`, указывая, что это объект
  типа `int`.

- `Py_SET_SIZE(result, size);` — записывает длину числа (количество “цифр”) в `ob_size`.

- `result->ob_digit[0] = 0;` — устанавливает первую “цифру” числа равной нулю (инициализация).

- `return (PyObject *)result;` — возвращает созданный объект, приведённый к общему типу `PyObject *`, как это принято
  для всех Python-объектов.

## Уточнения

- Эта функция только выделяет память — **значение числа формируется позже**, другими функциями (например, при парсинге
  литерала или в арифметике).
- Функция — **внутренняя** (начинается с подчёркивания) и не предназначена для использования из Python‑C API напрямую.
- Используется стандартный **аллокатор Python** (`PyObject_MALLOC`), чтобы система могла отслеживать память GC и
  профилировать выделения.
- Знак числа не устанавливается здесь — он задаётся отдельно через `Py_SET_SIZE()` (положительный или отрицательный).

## 5. PyListObject со слотами протоколов

```c
typedef struct {
    PyObject_VAR_HEAD         // PyObject + ob_size (длина)
    PyObject **ob_item;       // Указатели на элементы
    Py_ssize_t allocated;     // Выделенная ёмкость (> ob_size)
} PyListObject;
```

## Общее

`PyListObject` — это внутренняя структура CPython, которая описывает объект **списка (`list`)**.  
Когда вы создаёте список вроде `[1, 2, 3]`, в памяти Python создаёт именно такую структуру.  
Она хранит указатели на элементы, информацию о длине и о том, сколько памяти зарезервировано под будущие добавления.

## Описание

- `PyObject_VAR_HEAD` — стандартный заголовок переменных объектов, который добавляет поля:
    - `ob_refcnt` — счётчик ссылок (управление памятью).
    - `ob_type` — ссылка на тип (`list`).
    - `ob_size` — текущее количество элементов в списке (то, что возвращает `len(lst)`).

- `PyObject **ob_item;` — указатель на **массив ссылок** (указателей) на реальные объекты Python.  
  То есть сам список хранит не данные, а только ссылки — например, `[1, "a"]` содержит ссылки на `PyLongObject(1)` и
  `PyUnicodeObject("a")`.

- `Py_ssize_t allocated;` — количество ячеек, реально выделенных под элементы.  
  Оно может быть больше, чем `ob_size`, чтобы ускорить `append()` и не выделять память при каждом добавлении.

## Уточнения

- Разница между `ob_size` и `allocated` помогает Python делать **динамическое расширение** списка (амортизация вставок).
- Список — это не массив примитивов, а **массив указателей на объекты**, поэтому изменение одного списка не трогает
  содержимое других.
- Элементы списка всегда находятся в куче (heap), и список просто хранит ссылки на них.
- При удалении элементов память под массив может быть перераспределена — это управляется внутренними функциями
  `list_resize()`.

**Слоты PyList_Type:**

```c
PyTypeObject PyList_Type = {
    PyVarObject_HEAD_INIT(&PyType_Type, 0)  // Наследуем от type
    "list",                    // tp_name
    sizeof(PyListObject),      // tp_basicsize
    0,                         // tp_itemsize (переменная часть в ob_item)
    
    (destructor)list_dealloc,  // tp_dealloc
    0,                         // tp_print
    0,                         // tp_getattr
    0,                         // tp_setattr
    0,                         // tp_reserved
    list_repr,                 // tp_repr -> str(list)
    
    0,                         // tp_as_number
    &list_as_sequence,         // tp_as_sequence <- ВАЖНО!
    0,                         // tp_as_mapping
    (hashfunc)PyObject_HashNotImplemented,  // tp_hash (списки не хешируемы)
};
```

## Общее

`PyList_Type` — это **определение типа `list` на уровне C** внутри интерпретатора CPython.  
Эта структура описывает, как Python должен работать со списками: как их создавать, удалять, представлять в виде строки и
какие операции они поддерживают.  
По сути, это “паспорт” встроенного типа `list`, с которым работает любая функция `type()` и весь механизм ООП Python.

## Описание

- `PyVarObject_HEAD_INIT(&PyType_Type, 0)` — инициализирует заголовок типа.  
  Указывает, что `list` — это **объект типа `type`** (в Python всё — объект, включая классы).  
  Второй параметр `0` — это базовый размер для `_var`-части (переменная длина задаётся отдельно).

- `"list"` — имя типа, которое возвращает `type([]).__name__`.

- `sizeof(PyListObject)` — базовый размер структуры в памяти (заголовок + указатели, без элементов).

- `tp_itemsize = 0` — размер дополнительного элемента в переменных частях структуры не используется, потому что список
  хранит данные через `ob_item` (указатель на отдельный массив).

- `(destructor)list_dealloc` — функция, которая освобождает память списка при удалении (`tp_dealloc`).

- `list_repr` — функция, которая формирует строковое представление (`repr(list)` или `str(list)`).

- `&list_as_sequence` — ссылка на таблицу функций, описывающих поведение списка как **последовательности** (sequence
  protocol).  
  Именно отсюда берутся операции `len(lst)`, `lst[i]`, `lst.append()` и `lst[i:j]`.

- `(hashfunc)PyObject_HashNotImplemented` — указывает, что список **нельзя хешировать** (поэтому `hash([])` вызывает
  ошибку).

## Уточнения

- `PyList_Type` хранится в памяти как **глобальная структура**, доступная интерпретатору для всех операций со списками.
- В ней много других полей, которые здесь не показаны (например, для инициализации, копирования, итераций).
- Протокол `tp_as_sequence` делает список совместимым с универсальными функциями Python, которые работают со всеми
  последовательностями (`tuple`, `str` и др.).
- Поскольку список изменяемый, Python специально запрещает его хеширование, чтобы не нарушать поведение словарей и
  множеств.

**list_as_sequence.sq_item (lst[i]):**

```c
static PyObject *list_item(PyListObject *self, Py_ssize_t i) {
    if (i < 0 || i >= Py_SIZE(self)) {
        PyErr_SetString(PyExc_IndexError, "list index out of range");
        return NULL;
    }
    Py_INCREF(self->ob_item[i]);   // Увеличиваем refcnt
    return self->ob_item[i];       // Возвращаем элемент
}
```

## Общее

`list_item` — это внутренняя C‑функция, которая реализует поведение **доступа к элементу списка по индексу** — то есть
выражение `lst[i]` в Python.  
Она безопасно проверяет границы индекса и возвращает нужный элемент, корректно управляя счётчиком ссылок (чтобы объект
не был удалён преждевременно).

## Описание

- `if (i < 0 || i >= Py_SIZE(self))` — проверка выхода за границы.  
  Функция `Py_SIZE(self)` возвращает текущее количество элементов (`ob_size` из `PyListObject`).  
  Если индекс меньше нуля или больше последнего элемента, выбрасывается исключение `IndexError`.

- `PyErr_SetString(PyExc_IndexError, "list index out of range");` — создаёт и поднимает стандартное исключение Python,
  полностью аналогичное тому, что видит пользователь.

- `Py_INCREF(self->ob_item[i]);` — увеличивает счётчик ссылок на возвращаемый объект, чтобы гарантировать, что он не
  удалится из памяти, пока Python-код им пользуется.

- `return self->ob_item[i];` — возвращает указатель на объект, находящийся по данному индексу (элемент списка).

## Уточнения

- Проверка диапазона обязательна, потому что в C нет защиты от обращения к памяти за пределами массива — это
  предотвращает падения интерпретатора.
- В Python отрицательные индексы (`lst[-1]`) обрабатываются **на более высоком уровне** — сюда уже приходит вычисленный
  положительный индекс.
- Увеличение `refcount` обеспечивает **безопасность памяти**: даже если элемент будет удалён из списка, ссылка,
  возвращённая из этой функции, останется действительной в пользовательском коде.
- Эта функция является частью реализации **sequence protocol**, который отвечает за операции индексирования и срезов.

## 6. PyDictObject с split table (с 3.6)

```c
typedef struct {
    Py_ssize_t ma_used;        // Кол-во ключей (не слотов!)
    uint64_t ma_version_tag;   // Версия для итераторов
    PyDictKeysObject *ma_keys; // Общие ключи
    PyObject **ma_values;      // Массив значений
} PyDictObject;
```

## Общее

`PyDictObject` — это внутренняя структура CPython, которая описывает объект **словаря (`dict`)**.  
Каждый словарь в Python — это хеш-таблица, оптимизированная для быстрого доступа по ключу (`dict[key]`).  
Эта структура управляет ключами, значениями и вспомогательными данными (например, версией для отслеживания изменений при
итерации).

## Описание

- `Py_ssize_t ma_used` — количество **реальных пар ключ–значение**, которые сейчас находятся в словаре.  
  Это не количество выделенных слотов в таблице, а именно количество активных записей, то есть то, что возвращает
  `len(dict)`.

- `uint64_t ma_version_tag` — номер версии словаря.  
  Он увеличивается при каждом изменении (добавление, удаление, обновление).  
  Используется итераторами и кэшем атрибутов, чтобы понимать, что структура изменилась.

- `PyDictKeysObject *ma_keys` — указатель на структуру, содержащую **ключи и хеш-таблицу**.  
  Эта часть может быть общей для нескольких словарей (например, у экземпляров класса с одинаковыми атрибутами).

- `PyObject **ma_values` — массив указателей на **значения**, соответствующие индексам ключей из `ma_keys`.  
  Если поле равно `NULL`, значит, это «старый» словарь, где и ключи, и значения лежат в одном месте (используется для
  обычных dict).

## Уточнения

- Современная реализация (с Python 3.6) гарантирует **сохранение порядка вставки** благодаря оптимизированной
  хеш-таблице.
- Разделение `ma_keys` и `ma_values` позволяет экономить память при использовании общих ключей (например, в `__dict__` у
  одинаковых объектов одного класса).
- `ma_used` и `ma_version_tag` применяются для корректной работы итераторов: изменение словаря во время обхода вызывает
  ошибку `RuntimeError`.
- Доступ к элементам (`dict[key]`) осуществляется через хеш функции, хранящиеся в `PyDictKeysObject`, а значения
  подтягиваются из `ma_values` по индексу.

**PyDictKeysObject:**

```c
struct _dictkeysobject {
    Py_ssize_t dk_size;        // Размер хеш-таблицы
    enum dict_keys_kind dk_kind; // DICT_KEYS_UNICODE и т.д.
    union {
        PyDictUnicodeEntry *dk_entries;  // Полная таблица key+value
        PyDictKeyEntry *dk_indices;      // Только индексы
    } dk;
    uint64_t dk_version_tag;
};
```

Ключи компактно хранятся в `PyDictKeysObject`, который может быть **shared** между словарями (
экономия памяти).

## 7. GC-интеграция для контейнеров

```c
// list_traverse - обход ссылок для GC
static int list_traverse(PyListObject *o, visitproc visit, void *arg) {
    Py_ssize_t i = 0;
    Py_ssize_t len = Py_SIZE(o);
    for (; i < len; i++) {
        Py_VISIT(o->ob_item[i]);  // Отмечаем каждый элемент как живой
    }
    return 0;
}

// list_clear - разрыв циклических ссылок
static int list_clear(PyListObject *o) {
    Py_ssize_t i = 0;
    Py_ssize_t len = Py_SIZE(o);
    for (; i < len; i++) {
        Py_XDECREF(o->ob_item[i]);  // Уменьшаем refcnt элементов
        o->ob_item[i] = NULL;       // NULL'им ссылки
    }
    return 0;
}
```

---

Контейнеры в Python (списки, словари и др.) могут создавать циклические ссылки, когда содержат ссылки на самих себя или
другие контейнеры. Чтобы обнаруживать и очищать такие циклы, Python использует механизм циклического сборщика мусора (
GC).

Для работы с GC каждый контейнер должен предоставлять две специальные функции:

1. **`tp_traverse` (обход ссылок)**  
   Функция `list_traverse` вызывается GC для "посещения" всех объектов, на которые ссылается список.  
   `Py_VISIT` помечает каждый элемент как достижимый, что предотвращает его ошибочное удаление.

2. **`tp_clear` (очистка ссылок)**  
   Когда GC обнаруживает цикл из недостижимых объектов, он вызывает `list_clear` для безопасного разрыва ссылок.  
   Функция уменьшает счетчики ссылок элементов и обнуляет указатели, позволяя GC корректно освободить память.

Без этих функций контейнеры с циклическими ссылками никогда не освобождались бы, вызывая утечки памяти.

## 8. Байткод-интеграция: LIST_APPEND

```c
case LIST_APPEND: {
    PyObject *v = TOP();              // Берём значение с вершины стека
    PyObject *list = PEEK(oparg + 1); // Берём список из фиксированной позиции
    Py_ssize_t index = oparg;         // Индекс списка в localsplus
    
    // Вызываем list.append(v)
    int err = PyList_Append(list, v);
    Py_DECREF(v);                     // Освобождаем значение
    
    if (err == 0) {
        STACKADJ(-1);                 // Убираем значение со стека
    } else {
        // Ошибка - прерываем выполнение
        break;
    }
    DISPATCH_SAME_OPARG(1);           // Следующая инструкция
}
```

Инструкция `LIST_APPEND` в байт-коде Python оптимизирована для работы с генераторами списков (list comprehensions),
например `[x for x in lst]`. Рассмотрим логику:

1. **Обычный подход**: При добавлении элементов в список через метод `append()` в цикле, список каждый раз должен быть
   на вершине стека. Это требует лишних операций `PUSH` и `POP` для управления стеком в каждой итерации.

2. **Оптимизация в генераторах списков**:
    - Список-аккумулятор (в который собираются результаты) создаётся **один раз** в начале работы генератора.
    - Он сохраняется в специальной области памяти — `localsplus` (слот для локальных переменных и временных значений).
    - Инструкция `LIST_APPEND` использует аргумент `oparg` для прямого доступа к этому слоту (`PEEK(oparg + 1)`), минуя
      вершину стека.
    - Значение для добавления (`v`) по-прежнему берётся с вершины стека (`TOP()`), после чего стек освобождается (
      `STACKADJ(-1)`).

**Преимущества**:

- **Экономия операций**: Исключаются лишние манипуляции со стеком (не нужно постоянно перемещать список на стек и
  обратно).
- **Скорость**: Прямой доступ к `localsplus` выполняется быстрее, чем работа со стеком.

**Пример для понимания**:  
В генераторе `[x*2 for x in range(5)]`:

- Список-аккумулятор `result` хранится в `localsplus` (условно в слоте `0`).
- На каждой итерации вычисленное значение `x*2` помещается на стек.
- `LIST_APPEND` берёт список из `localsplus[0]`, добавляет к нему значение с вершины стека, и очищает стек.

Такой подход делает выполнение генераторов списков более эффективным по сравнению с обычным циклом с `append()`.

## 9. Инициализация типов: PyType_Ready

```c
int PyType_Ready(PyTypeObject *type) {
    if (type->tp_flags & Py_TPFLAGS_READY)  // Уже инициализирован
        return 0;
    
    // Наследуем слоты от базовых классов
    if (type->tp_bases) {
        Py_ssize_t i, nbase = PyTuple_GET_SIZE(type->tp_bases);
        for (i = 0; i < nbase; i++) {
            PyTypeObject *base = (PyTypeObject *)PyTuple_GET_ITEM(type->tp_bases, i);
            if (PyType_Ready(base) < 0)
                return -1;
            
            // Наследуем слоты (tp_as_number, tp_as_sequence...)
            inherit_special(base, type);
        }
    }
    
    // Вычисляем MRO
    if (mro_internal(type) < 0)
        return -1;
        
    // Инициализируем tp_dict
    if (type->tp_dict == NULL) {
        if (PyType_AllocDict(type) < 0)
            return -1;
    }
    
    type->tp_flags |= Py_TPFLAGS_READY;  // Отмечаем готовым
    return 0;
}
```

Перед первым использованием типа вызывается PyType_Ready. Оно наследует слоты от родителей,
вычисляет MRO, создаёт `__dict__` класса. Без этого тип не готов к работе.

Типы данных в CPython — это **PyTypeObject** с 100+ слотами протоколов, живущие в памяти как обычные объекты, с
refcount'ами, GC-интеграцией и наследованием слотов через MRO.

- [Содержание](/CONTENTS.md#содержание)

---

Общие (1 файл)
Раздел: "В CPython все типы данных наследуют от базовой структуры..."

Раздел 1: "Базовая структура PyObject" + описание

Раздел 2: "PyVarObject для контейнеров" + описание

Раздел 3: "PyTypeObject - паспорт каждого типа" + описание

Раздел 9: "Инициализация типов: PyType_Ready"

Раздел 7: "GC-интеграция для контейнеров" (общий механизм)

int (1 файл)
Раздел 4: "PyLongObject (int) - переменной точности" + описание + создание PyLongObject

float (1 файл)
❌ Нет в исходном материале

decimal (1 файл)
❌ Нет в исходном материале

str (1 файл)
❌ Нет в исходном материале (только упоминания в PyVarObject)

bytes (1 файл)
❌ Нет в исходном материале

frozenset (1 файл)
❌ Нет в исходном материале

bool (1 файл)
❌ Нет в исходном материале

NoneType (1 файл)
❌ Нет в исходном материале

list (1 файл)
Раздел 5: "PyListObject со слотами протоколов" + структура + PyList_Type + list_item

Раздел 8: "Байткод-интеграция: LIST_APPEND"

Раздел 7: "GC-интеграция" (list_traverse, list_clear)

dict (1 файл)
Раздел 6: "PyDictObject с split table (с 3.6)" + PyDictKeysObject

set (1 файл)
❌ Нет в исходном материале

bytearray (1 файл)
❌ Нет в исходном материале