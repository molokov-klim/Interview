# **Типы данных**

---

## **Junior Level**

Типы данных в Python делятся на **изменяемые** (mutable) и **неизменяемые** (immutable).

**Простые типы:**

- Числа: `int`, `float`, `decimal`, `complex`
- Строки: `str`
- Логические значения: `bool`
- Специальный тип: `NoneType` (единственное значение `None`)

**Коллекции**

- `list` — изменяемая упорядоченная коллекция
- `tuple` — неизменяемая упорядоченная коллекция
- `dict` — изменяемая коллекция пар «ключ-значение» (упорядоченная с Python 3.7)
- `set` / `frozenset` — изменяемое и неизменяемое множества уникальных элементов
- `bytes` / `bytearray` — неизменяемая и изменяемая последовательности байтов

---

## **Middle Level**

Объекты изменяемыех типов можно модифицировать после создания. А любая модификация объекта неизменяемого типа
создаёт новый объект.
Передача изменяемых объектов в функции позволяет модифицировать оригинал
Только неизменяемые объекты могут быть ключами словаря (требуется хэшируемость)
Мутабельность негативно влияет на потокобезопасность и кэширование

### Специфика типов:

`None` — синглтон, обозначающий отсутствие значения
`bool` — подкласс `int`, значения `True` и `False` — синглтоны
`tuple` — неизменяем, но может содержать изменяемые элементы
`set`/`frozenset` — хранят только хэшируемые элементы, реализация аналогична словарям без значений

### Обеспечение иммутабельности пользовательских объектов:

Для пользовательских классов полная иммутабельность невозможна из-за динамической природы языка, но её можно эффективно
эмулировать с помощью dataclasses, namedtuple или переопределения специальных методов. Это особенно полезно в тестовой
автоматизации, где конфигурации и тестовые данные должны оставаться неизменными для предсказуемости.

## Встроенные иммутабельные типы

Используйте tuple вместо list, frozenset вместо set для данных, которые не должны меняться.

- namedtuple из collections даёт именованные поля с иммутабельностью:
  `Point = namedtuple('Point', ['x', 'y']); p = Point(1, 2)` — доступ через p.x, но изменение запрещено.
- Преимущества: хэшируемость (для словарей/множеств), кэширование Python, безопасность в многопоточности.

## Dataclasses с frozen=True

Самый современный способ для Python 3.7+: `@dataclass(frozen=True)` генерирует класс с иммутабельными полями,
перехватывая setattr/delattr исключениями FrozenInstanceError.

```python
from dataclasses import dataclass


@dataclass(frozen=True)
class Config:
    host: str
    port: int
```

Подходит для конфигов в CI/CD или тестовых фреймворках, но создание чуть медленнее обычных dataclasses.

## Ручная иммутабельность

Переопределите __setattr__, __delattr__, используйте __slots__ для экономии памяти и запрета monkey-patching.

```python
class Immutable:
    __slots__ = ['_value']

    def __init__(self, value):
        object.__setattr__(self, '_value', value)

    def __setattr__(self, name, value):
        raise AttributeError(f"'{self.__class__.__name__}' is immutable")

    @property
    def value(self):
        return self._value
```

Это относительно надёжно. Комбинируйте с @property для read-only доступа.

## Практические советы

Избегайте мутабельных вложений (list в tuple) — используйте tuple внутри tuple. Для валидации добавьте Pydantic с
model_config['frozen'] = True.

---

## **Senior Level**

В CPython **все типы данных** наследуют от базовой структуры `PyObject`, которая содержит refcount и указатель на тип.
Каждый тип описывается массивом **слотов** в `PyTypeObject`.
`Include/object.h`, `Include/cpython/object.h`

## Базовый объект (PyObject)

```c
typedef struct _object {
    _PyObject_HEAD_EXTRA       // Платформо-зависимые поля для отладки (PyDebug)
    Py_ssize_t ob_refcnt;      // Счётчик ссылок - при 0 вызывается tp_dealloc
    struct _typeobject *ob_type; // Указатель на PyTypeObject описывающий тип
} PyObject;
```

### Общее

Это **фундаментальная C-структура из ядра CPython**, которая представляет любой объект в Python на самом низком уровне.
Каждый объект в Python — будь то число, строка, список или ваш собственный класс — в памяти выглядит как экземпляр этой
структуры. Она содержит три ключевых компонента: счётчик ссылок (для управления памятью), указатель на тип объекта и
служебные поля для отладки.

### Описание

**Отладочная информация:**

- `_PyObject_HEAD_EXTRA` — это не одно поле, а макрос, который раскрывается в дополнительные платформо-зависимые поля *
  *только в отладочных сборках Python** (когда интерпретатор скомпилирован с флагом `--with-pydebug`). В обычных сборках
  это ничего не добавляет. Используется для отслеживания проблем с памятью.

**Счётчик ссылок:**

- `ob_refcnt` — целое число, которое **считает, сколько переменных или структур указывают на этот объект**. Когда
  счётчик становится 0, Python вызывает функцию `tp_dealloc` (из `PyTypeObject`) для освобождения памяти. Это основной
  механизм управления памятью в CPython (garbage collection через reference counting).

**Указатель на тип:**

- `ob_type` — указатель на структуру `PyTypeObject`, которая описывает тип этого объекта. Это то же самое, что
  возвращает встроенная функция `type(obj)` в Python. Через этот указатель интерпретатор узнаёт, как работать с
  объектом: какие операции он поддерживает, как получить его атрибуты, как его удалить.

### Уточнения

- **Reference counting — это не threading-safe по умолчанию**: В CPython счётчик ссылок работает за счёт глобальной
  блокировки (GIL — Global Interpreter Lock), поэтому многопоточность имеет ограничения. В Python 3.13+ появился режим
  free-threaded, где это иначе.

- **Минимальный размер**: Даже самый простой объект в памяти занимает как минимум столько байт, сколько занимает
  `PyObject` (обычно 16-24 байта на 64-битной системе в зависимости от конфигурации). Это почему в Python много памяти
  уходит на служебную информацию, даже для маленьких объектов.

- **ob_refcnt увеличивается и уменьшается постоянно**: Каждый раз, когда вы присваиваете объект переменной, счётчик
  увеличивается на 1. Когда переменная удаляется или переназначается, счётчик уменьшается на 1. Вы можете проверить это
  функцией `sys.getrefcount(obj)`.

- **Связь с PyTypeObject**: `PyObject` и `PyTypeObject` работают вместе: `PyObject` — это экземпляр, `PyTypeObject` —
  это описание класса. Например, объект `5` имеет `ob_type`, указывающий на `PyTypeObject` для типа `int`.

---

## "Паспорт" каждого типа (PyTypeObject)

```c
typedef struct _typeobject {
    PyVarObject ob_base;       // Тип сам является объектом (можно наследовать)
    
    const char *tp_name;       // Имя типа ("list", "dict", "int")
    Py_ssize_t tp_basicsize;   // Размер в байтах без переменной части
    Py_ssize_t tp_itemsize;    // Размер одного элемента переменной части
    
    destructor tp_dealloc;     // Функция уничтожения (list_dealloc)
    printfunc tp_print;        // Для print()
    reprfunc tp_repr;          // Для repr()
    
    // Протокол чисел
    PyNumberMethods *tp_as_number;  // nb_add, nb_sub, nb_multiply...
    
    // Протокол последовательностей
    PySequenceMethods *tp_as_sequence; // sq_item, sq_ass_slice...
    
    // Протокол маппингов
    PyMappingMethods *tp_as_mapping;  // mp_subscript, mp_ass_subscript
    
    // Поиск атрибутов
    getattrofunc tp_getattro;      // obj.attr
    setattrofunc tp_setattro;      // obj.attr = value
    
    // Дескрипторы (property, method)
    descrgetfunc tp_descr_get;     // __get__
    descrsetfunc tp_descr_set;     // __set__
    
    Py_ssize_t tp_dictoffset;      // Смещение __dict__ (или -1)
    Py_ssize_t tp_weaklistoffset;  // Смещение weakref списка
    
    PyObject *tp_mro;              // Method Resolution Order (tuple типов)
    PyObject *tp_cache;            // Кеш атрибутов (free-threaded)
    unsigned int tp_subclasses;    // Количество живых подклассов
    
    PyObject *tp_dict;             // __dict__ класса
    // ... 100+ слотов
} PyTypeObject;
```

### Общее

Это **внутренняя C-структура из ядра Python**, которая определяет тип объекта на самом низком уровне. Каждый класс и
встроенный тип в Python (list, dict, int, str) представлены в памяти именно такой структурой. Она содержит всю
метаинформацию о типе: имя, размер, методы обработки операций (сложение, индексирование), управление атрибутами и многое
другое. Это фундамент, на котором работает весь механизм объектно-ориентированного программирования в Python.

### Описание

**Базовая информация:**

- `ob_base` — каждый тип сам является объектом (в Python всё является объектом, включая сами типы)
- `tp_name` — строка с именем типа, которая выводится, например, при вызове `type(obj).__name__`
- `tp_basicsize` и `tp_itemsize` — память: базовый размер структуры плюс размер на один элемент для переменных
  контейнеров (список с 10 элементами занимает `basicsize + 10 * itemsize` байт)

**Управление жизненным циклом:**

- `tp_dealloc` — функция уничтожения объекта, вызывается при удалении (соответствует `__del__` на уровне C)
- `tp_print`, `tp_repr` — старый способ для вывода и представления (в Python 3.9+ `tp_print` устарел)

**Протоколы операций** — указатели на структуры с функциями для конкретных операций:

- `tp_as_number` — арифметические операции: `__add__`, `__sub__`, `__mul__` и т.д.
- `tp_as_sequence` — операции последовательностей: `obj[i]`, `obj[i:j]`, `len(obj)`
- `tp_as_mapping` — операции словарей: `obj[key]`, `len(obj)` для словарей

**Управление атрибутами:**

- `tp_getattro` / `tp_setattro` — низкоуровневые функции для доступа к атрибутам (`obj.attr` и `obj.attr = value`)

**Дескрипторы:**

- `tp_descr_get` / `tp_descr_set` — механизм дескрипторов, на котором работают `property`, методы класса, статические
  методы

**Служебная информация:**

- `tp_dictoffset` — смещение в памяти, где находится `__dict__` объекта (словарь атрибутов экземпляра)
- `tp_mro` — кортеж типов в порядке разрешения методов (Method Resolution Order) — порядок поиска атрибутов в иерархии
  наследования
- `tp_dict` — `__dict__` самого класса, где хранятся методы и атрибуты класса

### Уточнения

1. **C-структура, но видна из Python**: Вы не работаете с этой структурой напрямую в коде на Python, но когда пишете
   класс с методами `__add__`, `__getitem__` или `__get__`, Python переводит эти методы в соответствующие C-функции в
   этой структуре для производительности.

2. **tp_print устарел**: В Python 3.9+ поле `tp_print` более не используется. Вывод объектов управляется через `tp_repr`
   и `tp_str`.

3. **100+ слотов**: Код содержит комментарий «... 100+ слотов», что означает в реальной структуре есть множество
   дополнительных полей для специальных случаев, обработки исключений, сериализации и прочего. Здесь показаны только
   самые важные.

4. **Зачем это нужно знать**: Если вы пишете расширения на C для Python или оптимизируете критичные места, понимание
   этой структуры помогает правильно определить поведение типа. Для обычного Python-кода достаточно знать, что она
   существует.

5. **Про free-threaded**: Поле `tp_cache` относится к улучшениям для параллельного выполнения (free-threaded Python),
   актуально для Python 3.13+, для Python 3.9-3.12 на него можно не обращать внимание.

---

## Инициализация типов: PyType_Ready

```c
int PyType_Ready(PyTypeObject *type) {
    if (type->tp_flags & Py_TPFLAGS_READY)  // Уже инициализирован
        return 0;
    
    // Наследуем слоты от базовых классов
    if (type->tp_bases) {
        Py_ssize_t i, nbase = PyTuple_GET_SIZE(type->tp_bases);
        for (i = 0; i < nbase; i++) {
            PyTypeObject *base = (PyTypeObject *)PyTuple_GET_ITEM(type->tp_bases, i);
            if (PyType_Ready(base) < 0)
                return -1;
            
            // Наследуем слоты (tp_as_number, tp_as_sequence...)
            inherit_special(base, type);
        }
    }
    
    // Вычисляем MRO
    if (mro_internal(type) < 0)
        return -1;
        
    // Инициализируем tp_dict
    if (type->tp_dict == NULL) {
        if (PyType_AllocDict(type) < 0)
            return -1;
    }
    
    type->tp_flags |= Py_TPFLAGS_READY;  // Отмечаем готовым
    return 0;
}
```

### Общее

`PyType_Ready` — это ключевая функция CPython, которая **финализирует тип** (класс) перед его использованием.  
Вызывается автоматически при определении класса (`class MyClass:`) или импорте модуля.  
Подготавливает все слоты, наследование и MRO (порядок разрешения методов).

### Описание

- `if (type->tp_flags & Py_TPFLAGS_READY)` — проверяет, уже ли тип инициализирован (избегает повторной работы).

- `if (type->tp_bases)` — цикл по базовым классам:
    - Рекурсивно вызывает `PyType_Ready(base)` для каждого родителя.
    - `inherit_special(base, type)` — копирует слоты (`tp_as_number`, `tp_as_sequence` и др.) из базового класса.

- `mro_internal(type)` — вычисляет **Method Resolution Order** (порядок поиска методов при множественном наследовании).

- `PyType_AllocDict(type)` — создаёт `__dict__` класса, если его нет (словарь атрибутов и методов).

- `type->tp_flags |= Py_TPFLAGS_READY` — помечает тип как полностью готовый к использованию.

### Уточнения

- **Рекурсивная инициализация** гарантирует, что все предки готовы перед дочерним классом.
- `inherit_special()` заполняет протоколы операций (арифметика, индексирование) из ближайшего базового класса.
- MRO критичен для **множественного наследования** — определяет порядок `super()`.
- Вызывается **один раз** за тип — повторные вызовы игнорируются (`Py_TPFLAGS_READY`).
- В Python 3.9+ улучшена производительность за счёт кэширования MRO и оптимизации слотов.

---

## База коллекций (PyVarObject)

```c
typedef struct {
    PyObject ob_base;          // Встроенный PyObject (refcnt + type)
    Py_ssize_t ob_size;        // Количество элементов (длина строки/списка)
} PyVarObject;
```

### Общее

- Это структура данных из исходного кода CPython (стандартной реализации Python, написанной на C).
- Она представляет собой расширенный заголовок для объектов, которые имеют переменную длину (количество элементов).
- Такие типы данных, как списки (`list`), кортежи (`tuple`) и строки (`str`), в памяти начинаются именно с этой
  структуры.

### Описание

- `typedef struct { ... } PyVarObject;` — конструкция языка C, создающая новый тип данных `PyVarObject`, описывающий,
  как объект лежит в оперативной памяти.
- `PyObject ob_base` — поле, внедряющее базовый объект внутрь. Оно содержит два критически важных элемента: счетчик
  ссылок (для сборщика мусора) и указатель на тип данных (класс объекта).
- `Py_ssize_t ob_size` — поле, хранящее количество элементов в объекте (значение, которое возвращает функция `len()`).
  Для списка это число слотов, для строки — количество символов.

### Уточнения

- Благодаря тому, что `ob_base` стоит первым, любой указатель на `PyVarObject` можно безопасно рассматривать как
  указатель на `PyObject`. Это позволяет функциям интерпретатора работать с любыми объектами (фиксированными и
  переменными) одинаково.
- Целые числа (`int`) в Python 3 также реализованы через `PyVarObject`, так как они поддерживают длинную арифметику и
  могут состоять из произвольного количества «цифр» в памяти.
- Доступ к длине объекта происходит за время O(1), так как интерпретатор просто читает значение `ob_size`, не
  пересчитывая элементы каждый раз.

---

## int (PyLongObject)

```c
typedef uint32_t digit;        // 30-битная цифра (2^30 = ~1e9)

typedef struct _longobject {
    PyObject_VAR_HEAD          // PyObject + ob_size (кол-во цифр)
    digit ob_digit[1];         // Массив цифр (размер ob_size)
} PyLongObject;
```

### Общее

`PyLongObject` — это внутренняя структура CPython, представляющая **все целые числа (`int`)** в Python.  
Даже обычное число `42` или огромный `10**1000` — это один и тот же тип объекта `PyLongObject`.  
Главная идея — хранить число не как одно значение, а как **массив “цифр”** в 30 бит, что позволяет поддерживать целые
числа любой длины (длинная арифметика).

### Описание

- `typedef uint32_t digit;` — определяет тип для хранения одной “цифры” числа. Каждая цифра занимает 32 бита, но реально
  используются только 30. Это оставляет запас для удобных вычислений без переполнений.  
  Например, большое число хранится как массив таких 30-битных частей.

- `PyObject_VAR_HEAD` — макрос, который вставляет в структуру стандартные поля из `PyVarObject`:
    - `ob_refcnt` — счётчик ссылок (для управления памятью).
    - `ob_type` — указатель на тип (`int`).
    - `ob_size` — количество “цифр” (`digit`) в числе и знак (если отрицательное, `ob_size` < 0).

- `digit ob_digit[1];` — первый элемент массива, в котором реально хранятся “цифры” числа.  
  Несмотря на размер `[1]`, массив в памяти может быть длиннее — его конечная длина задается `ob_size`.  
  Например, число `12345678901234567890` будет храниться как несколько элементов в этом массиве.

### Уточнения

- Такой подход позволяет Python-числам быть **неограниченно большими**, в отличие от фиксированной разрядности в C (
  `int`, `long`).
- Младшая цифра хранится первой (наименьший порядок) — это **младший разрядный порядок (little-endian)**.
- “30 бит на цифру” выбрано, чтобы при арифметических операциях с двумя цифрами не происходило переполнения 32‑битного
  регистра.
- Для маленьких чисел Python использует **кэш** заранее созданных объектов (от -5 до 256), чтобы не пересоздавать их в
  памяти.

---

## Создание int (PyLongObject)

```c
PyObject *_PyLong_New(Py_ssize_t size) {
    PyLongObject *result;
    
    size = Py_ABS(size);  // Берем модуль размера
    
    // Выделяем память под заголовок + массив цифр
    result = PyObject_MALLOC(sizeof(PyLongObject) + 
                             (size-1) * sizeof(digit));
    if (!result) {
        return PyErr_NoMemory();
    }
    
    // Инициализируем как PyObject
    PyObject_INIT(result, &PyLong_Type);
    Py_SET_SIZE(result, size);  // Устанавливаем ob_size
    result->ob_digit[0] = 0;    // Нулевая цифра
    
    return (PyObject *)result;
}
```

### Общее

`_PyLong_New` — это внутренняя функция CPython, которая **создаёт объект целого числа (`int`) в памяти**.  
Она не вычисляет значение, а лишь выделяет и подготавливает структуру `PyLongObject`, чтобы Python мог потом записать
туда цифры числа.  
Используется внутри интерпретатора при создании или копировании больших чисел.

### Описание

- `PyObject *_PyLong_New(Py_ssize_t size)` — функция принимает количество “цифр” (`digit`), которые нужно
  зарезервировать для будущего числа.  
  Если `size` отрицательное, берётся модуль (`Py_ABS(size)`), т.к. знак хранится отдельно через `ob_size`.

- `PyObject_MALLOC(sizeof(PyLongObject) + (size - 1) * sizeof(digit))` — выделяет память под заголовок (`PyLongObject`)
  и нужное количество “цифр”.  
  В структуре уже есть один элемент `ob_digit[1]`, поэтому добавляется `(size - 1)`.

- `if (!result) return PyErr_NoMemory();` — если память не выделилась, Python выбрасывает ошибку `MemoryError`.

- `PyObject_INIT(result, &PyLong_Type);` — макрос инициализирует базовую часть как `PyObject`, указывая, что это объект
  типа `int`.

- `Py_SET_SIZE(result, size);` — записывает длину числа (количество “цифр”) в `ob_size`.

- `result->ob_digit[0] = 0;` — устанавливает первую “цифру” числа равной нулю (инициализация).

- `return (PyObject *)result;` — возвращает созданный объект, приведённый к общему типу `PyObject *`, как это принято
  для всех Python-объектов.

### Уточнения

- Эта функция только выделяет память — **значение числа формируется позже**, другими функциями (например, при парсинге
  литерала или в арифметике).
- Функция — **внутренняя** (начинается с подчёркивания) и не предназначена для использования из Python‑C API напрямую.
- Используется стандартный **аллокатор Python** (`PyObject_MALLOC`), чтобы система могла отслеживать память GC и
  профилировать выделения.
- Знак числа не устанавливается здесь — он задаётся отдельно через `Py_SET_SIZE()` (положительный или отрицательный).

---

## float (PyFloatObject)

```c
typedef struct {
    PyObject ob_base;      // PyObject (refcnt + type)
    double ob_fval;        // IEEE 754 double-precision значение
} PyFloatObject;
```

### Общее

`PyFloatObject` — это внутренняя структура CPython, представляющая **числа с плавающей запятой (`float`)**.  
Любое число вроде `3.14` или `math.pi` в памяти хранится именно так.  
Простая структура — всего **одно поле со значением** в формате IEEE 754 double.

### Описание

- `PyObject ob_base` — стандартный заголовок:
    - `ob_refcnt` — счётчик ссылок для управления памятью.
    - `ob_type` — указатель на `PyFloat_Type` (тип `float`).

- `double ob_fval` — **реальное значение** числа в формате double (64 бита, ~15 значащих цифр).  
  Это стандарт IEEE 754, который используется во всех современных языках программирования.

### Уточнения

- **Фиксированный размер** — всегда 24 байта на 64-битной системе (PyObject + double).
- **Кэш маленьких float** отсутствует (в отличие от `int`), каждый `3.14` создаёт новый объект.
- **NaN, Inf, -Inf** поддерживаются стандартно через IEEE 754 (`float('nan')`, `float('inf')`).
- Арифметика (`+`, `-`, `*`, `/`) реализована через `tp_as_number` в `PyFloat_Type`.

---

## Создание float (PyFloatObject)

```c
PyObject *PyFloat_FromDouble(double fval) {
    PyFloatObject *op = _PyFloat_New();  // Выделяем PyFloatObject
    if (!op)
        return NULL;
    op->ob_fval = fval;                  // Записываем значение
    return (PyObject *)op;
}

static PyObject *_PyFloat_New(void) {
    PyFloatObject *op = (PyFloatObject*)PyObject_MALLOC(sizeof(PyFloatObject));
    if (!op) {
        return PyErr_NoMemory();
    }
    PyObject_INIT(op, &PyFloat_Type);    // Инициализируем как float
    return (PyObject *)op;
}
```

### Общее

`PyFloat_FromDouble` — основная функция CPython для **создания объекта `float` из C double**.  
Вызывается интерпретатором при литералах `3.14`, вызовах `float()`, математических операциях.  
Создаёт готовый Python-объект с заданным значением.

### Описание

- `PyFloatObject *op = _PyFloat_New();` — вызывает внутреннюю функцию выделения памяти под `PyFloatObject`.
- `_PyFloat_New()` — выделяет память через `PyObject_MALLOC` и инициализирует:
    - `PyObject_INIT(op, &PyFloat_Type)` — устанавливает `ob_refcnt=1`, `ob_type=&PyFloat_Type`.
- `op->ob_fval = fval;` — записывает **значение double** в поле объекта.
- `return (PyObject *)op;` — возвращает как универсальный `PyObject *`.

### Уточнения

- **Нет кэша** для float (в отличие от малых int) — каждый `3.14` создаёт новый объект.
- `PyObject_MALLOC` — специальный аллокатор Python для отслеживания GC.
- Функция **thread-safe** благодаря GIL (Python 3.9+).
- Используется в байткоде (`BINARY_OP` для `+`, `-`, `*`, `/` с float).

---

## decimal (PyDecimalObject)

```c
// decimal.Decimal - пользовательский класс Python, НЕ встроенный тип CPython
// Реализован в Objects/decimalmodule.c как PyTypeObject с C-ускорением

typedef struct {
    PyObject ob_base;           // Стандартный заголовок
    PyObject *digits;           // Массив цифр (список int)
    PyObject *exp;              // Показатель степени 10 (int)
    PyObject *prec;             // Точность (int)
    PyObject *rounding;         // Режим округления
    PyObject *context;          // Контекст вычислений
} PyDecimalObject;
```

### Общее

`decimal.Decimal` — **НЕ встроенный тип CPython**, а **модульный класс** из `decimal` с C-реализацией.  
Предоставляет **десятичную арифметику фиксированной точности** (банковские расчёты, финансы).  
В отличие от `float`, хранит числа как массив цифр + показатель степени.

### Описание

- `PyObject ob_base` — стандартный заголовок (`refcnt`, `type=PyDecimal_Type`).
- `PyObject *digits` — **массив цифр** в десятичной системе (список `int`).
- `PyObject *exp` — **показатель степени** (например, `123E-2` = 1.23).
- `PyObject *prec` — **точность** (максимум цифр для операций).
- `PyObject *rounding` — режим округления (`ROUND_HALF_UP` и др.).
- `PyObject *context` — глобальный контекст вычислений (`getcontext()`).

### Уточнения

- **Полностью управляемый** через `decimal.getcontext()` — точность, округление, исключения.
- Арифметика **десятичная**, не двоичная (никаких ошибок округления как в `float`).
- В CPython ускорен **C-кодом** (`Objects/decimalmodule.c`), но это всё равно Python-класс.
- Используется для **финансовых расчётов** (`0.1 + 0.2 == 0.3` работает правильно).

---

## Создание decimal (PyDecimalObject)

```c
PyObject *PyDecimal_FromString(PyObject *s) {
    PyDecimalObject *result = (PyDecimalObject *)PyObject_MALLOC(sizeof(PyDecimalObject));
    if (!result)
        return PyErr_NoMemory();
    
    PyObject_INIT(result, &PyDecimal_Type);
    
    // Парсим строку в цифры + экспоненту
    result->digits = parse_decimal_digits(s);
    result->exp = parse_exponent(s);
    result->prec = getcontext_prec();
    result->rounding = getcontext_rounding();
    result->context = getcontext_ref();
    
    return (PyObject *)result;
}
```

### Общее

Создание `PyDecimalObject` происходит через **функции модуля `decimal`** (например, `decimal.Decimal('1.23')`).  
Парсит строку в **десятичное представление** (цифры + экспонента) и связывает с глобальным контекстом точности.  
НЕ использует стандартный `_PyXXX_New()` — это модульная логика.

### Описание

- `PyObject_MALLOC(sizeof(PyDecimalObject))` — выделяет память под структуру.
- `PyObject_INIT(result, &PyDecimal_Type)` — инициализирует как `decimal.Decimal`.
- `result->digits = parse_decimal_digits(s)` — **разбирает цифры** из строки (`['1', '2', '3']`).
- `result->exp = parse_exponent(s)` — извлекает **экспоненту** (например, `E-2`).
- `result->prec = getcontext_prec()` — берёт **точность** из `decimal.getcontext()`.
- `result->rounding/context` — копирует настройки контекста округления и вычислений.

### Уточнения

- **Парсинг строковый** — `Decimal('1.23')` разбирается посимвольно, без потери точности.
- **Глобальный контекст** (`getcontext()`) определяет поведение всех операций.
- Создание **медленнее float/int** из-за парсинга и инициализации Python-объектов (`digits`, `exp`).
- В CPython 3.9+ **ускорено C-парсингом**, но остаётся модульным (не встроенный тип).

---

## str (PyUnicodeObject)

```c
typedef struct {
    PyObject_VAR_HEAD       // PyObject + ob_size (длина в символах)
    Py_UCS4 *ob_sval;       // Массив Unicode символов (UCS-4)
    // Или Py_UCS2 *ob_sval для компактных строк
    // Или char *ob_sval для latin-1 строк
} PyUnicodeObject;
```

### Общее

`PyUnicodeObject` — внутренняя структура CPython для **строк (`str`)**.  
Любая строка `s = "hello"` или `s = "привет"` хранится именно так.  
Поддерживает **три формата** хранения (compact, 1-byte, 2-byte, 4-byte) для экономии памяти.

### Описание

- `PyObject_VAR_HEAD` — стандартный заголовок:
    - `ob_refcnt` — счётчик ссылок.
    - `ob_type` — `&PyUnicode_Type`.
    - `ob_size` — **длина строки** в символах (не байтах).

- `Py_UCS4 *ob_sval` — **массив символов Unicode**:
    - `Py_UCS4` (32-bit) — полный Unicode (эмодзи, редкие символы).
    - `Py_UCS2` (16-bit) — BMP символы (большинство текста).
    - `char` (8-bit) — только ASCII/Latin-1.  
      Формат выбирается автоматически по содержимому.

### Уточнения

- **Автоматическая компрессия** — короткие ASCII строки занимают минимум памяти.
- **Interning** — одинаковые строки (`"hello"`) кэшируются как синглтоны (`sys.intern()`).
- **Immutable** — строки неизменяемы, операции `+`, `replace()` создают новые объекты.
- В Python 3.9+ улучшена **кодировка** (PEEPHOLER оптимизирует конкатенацию строк).

---

# Создание str (PyUnicodeObject)

```c
// Include/cpython/unicodeobject.h (Python 3.9+)
typedef struct {
    PyObject_VAR_HEAD
    Py_ssize_t length;      // Длина строки в символах (obsize)
    Py_hash_t hash;         // Кэшированный хэш (0 = не вычислен)
    struct {
        // Компактные Unicode варианты (Python 3.9+)
        Py_UCS1 *str;       // 1-byte ASCII/Latin-1
        Py_UCS2 *str2;      // 2-byte BMP
        Py_UCS4 *str4;      // 4-byte полный Unicode
    } data;
} PyUnicodeObject;

// Создание строки из C-строки (ASCII/Latin-1)
PyObject* PyUnicode_FromString(const char *u) {
    return PyUnicode_DecodeUTF8(u, strlen(u), NULL);
}

// Внутренняя функция создания (упрощённо)
static PyObject* unicode_new(Py_ssize_t length, int kind) {
    PyUnicodeObject *u;
    Py_ssize_t size;
    
    size = length * PyUnicode_KIND_SIZE(kind) + sizeof(PyUnicodeObject);
    u = PyObject_MALLOC(size);
    if (!u) return PyErr_NoMemory();
    
    PyObject_INIT_VAR(u, &PyUnicode_Type, length);
    u->hash = -1;  // Хэш не вычислен
    u->data.any = PyUnicode_DATA(u);  // Указатель на данные
    
    return (PyObject*)u;
}
```

### Общее

PyUnicodeObject — это C-структура CPython для хранения строк str в Python 3.9+. Использует **компактное представление
** (compact unicode): 1/2/4 байта на символ в зависимости от диапазона Unicode. Создание происходит через
PyUnicode_FromString() или внутренние функции вроде unicode_new().

### Описание

- **PyObject_VAR_HEAD**: Наследует refcnt, obtype (PyUnicode_Type), obsize (длина в символах).
- **length**: Количество символов (не байт!).
- **hash**: Кэшированный хэш для быстрого dict/set (-1 = не вычислен).
- **data.any**: Умный union — ASCII (1байт), BMP (2байт), полный Unicode (4байт).
- **unicode_new()**: Выделяет память под PyUnicodeObject + данные, инициализирует через PyObject_INIT_VAR.

### Уточнения

- **Компактность Python 3.9+**: "hello" → 1-byte (Py_UCS1), "привет" → 2-byte (Py_UCS2).
- **PyUnicode_FromString()**: Автоматически выбирает UTF-8 → PyUnicodeObject.
- **Interning**: sys.intern("hello") сохраняет один PyUnicodeObject для одинаковых строк.
- **Immutable**: После создания str нельзя изменить (no setattr!).
- **Memory layout**: PyObject (24байт) + данные сразу следом (O(1) доступ).

---

## dict (PyDictObject)

```c
typedef struct {
    Py_ssize_t ma_used;        // Кол-во ключей (не слотов!)
    uint64_t ma_version_tag;   // Версия для итераторов
    PyDictKeysObject *ma_keys; // Общие ключи
    PyObject **ma_values;      // Массив значений
} PyDictObject;
```

### Общее

`PyDictObject` — это внутренняя структура CPython, которая описывает объект **словаря (`dict`)**.  
Каждый словарь в Python — это хеш-таблица, оптимизированная для быстрого доступа по ключу (`dict[key]`).  
Эта структура управляет ключами, значениями и вспомогательными данными (например, версией для отслеживания изменений при
итерации).

### Описание

- `Py_ssize_t ma_used` — количество **реальных пар ключ–значение**, которые сейчас находятся в словаре.  
  Это не количество выделенных слотов в таблице, а именно количество активных записей, то есть то, что возвращает
  `len(dict)`.

- `uint64_t ma_version_tag` — номер версии словаря.  
  Он увеличивается при каждом изменении (добавление, удаление, обновление).  
  Используется итераторами и кэшем атрибутов, чтобы понимать, что структура изменилась.

- `PyDictKeysObject *ma_keys` — указатель на структуру, содержащую **ключи и хеш-таблицу**.  
  Эта часть может быть общей для нескольких словарей (например, у экземпляров класса с одинаковыми атрибутами).
  PyDictKeysObject содержит массив записей (PyDictKeyEntry), где хранятся:
    - сам ключ (PyObject *key)
    - хэш этого ключа (целое число, рассчитанное при вставке)
    - индекс (или прямое значение), указывающий на место в ma_values.
    - хэш-индекс — таблицу разных размеров, по которой Python быстрo находит нужный элемент по хэшу. Это и есть
      внутренняя хэш-таблица, которая делает словари такими быстрыми при поиске.

- `PyObject **ma_values` — массив указателей на **значения**, соответствующие индексам ключей из `ma_keys`.  
  Если поле равно `NULL`, значит, это «старый» словарь, где и ключи, и значения лежат в одном месте (используется для
  обычных dict).

### Уточнения

- Современная реализация (с Python 3.6) гарантирует **сохранение порядка вставки** благодаря оптимизированной
  хеш-таблице.
- Разделение `ma_keys` и `ma_values` позволяет экономить память при использовании общих ключей (например, в `__dict__` у
  одинаковых объектов одного класса).
- `ma_used` и `ma_version_tag` применяются для корректной работы итераторов: изменение словаря во время обхода вызывает
  ошибку `RuntimeError`.
- Доступ к элементам (`dict[key]`) осуществляется через хеш функции, хранящиеся в `PyDictKeysObject`, а значения
  подтягиваются из `ma_values` по индексу.

---

# Создание dict (PyDictObject)

```c
PyObject *
PyDict_New(void)
{
    /* We don't incref Py_EMPTY_KEYS here because it is immortal. */
    return new_dict(Py_EMPTY_KEYS, NULL, 0, 0);
}

static PyObject *
new_dict(PyDictKeysObject *keys, PyDictValues *values,
         Py_ssize_t used, int free_values_on_failure)
{
    assert(keys != NULL);
    PyDictObject *mp = _Py_FREELIST_POP(PyDictObject, dicts);
    if (mp == NULL) {
        mp = PyObject_GC_New(PyDictObject, &PyDict_Type);
        if (mp == NULL) {
            dictkeys_decref(keys, false);
            if (free_values_on_failure) {
                free_values(values, false);
            }
            return NULL;
        }
    }
    assert(Py_IS_TYPE(mp, &PyDict_Type));
    mp->ma_keys = keys;
    mp->ma_values = values;
    mp->ma_used = used;
    mp->_ma_watcher_tag = 0;
    ASSERT_CONSISTENT(mp);
    _PyObject_GC_TRACK(mp);
    return (PyObject *)mp;
}
```

### Общее

Создание пустого словаря `dict{}` в CPython начинается с вызова `PyDict_New()`. Эта функция создаёт объект
`PyDictObject` с минимальными начальными настройками, используя предсозданную "пустую" структуру ключей `Py_EMPTY_KEYS`.
Словарь получается компактным и готовым к быстрому заполнению без немедленного выделения дополнительной памяти под
записи.

### Описание

`PyDict_New()` вызывает вспомогательную функцию `new_dict()`, передавая ей бессмертный объект `Py_EMPTY_KEYS` (с
`dk_refcnt = PY_SSIZE_T_MIN`, размер 8 слотов, все индексы `DKIX_EMPTY`). Функция `new_dict()` берёт объект из пула
свободных словарей (`_Py_FREELIST_POP`) или создаёт новый через `PyObject_GC_New()`. Инициализируются поля: `ma_keys`
указывает на пустые ключи, `ma_values = NULL` (комбинированная таблица), `ma_used = 0`. Объект помечается для сборщика
мусора и возвращается.

### Уточнения

- `Py_EMPTY_KEYS` — глобальный бессмертный объект с 8 слотами (минимальный размер `PyDict_MINSIZE=8`), все индексы
  заполнены `DKIX_EMPTY(-1)` для быстрого поиска.
- Комбинированная таблица (`ma_values=NULL`) хранит ключи/значения в `dk_entries` структуры `PyDictKeysObject`.
- При первом добавлении элемента словарь вырастет до нужного размера через `dictresize()` с коэффициентом
  `USABLE_FRACTION=2/3`.
- Пул freelists ускоряет создание малых словарей, снижая нагрузку на `malloc()`.

---

## PyDictKeysObject

```c
struct _dictkeysobject {
    Py_ssize_t dk_size;        // Размер хеш-таблицы
    enum dict_keys_kind dk_kind; // DICT_KEYS_UNICODE и т.д.
    union {
        PyDictUnicodeEntry *dk_entries;  // Полная таблица key+value
        PyDictKeyEntry *dk_indices;      // Только индексы
    } dk;
    uint64_t dk_version_tag;
};
```

### Общее

`PyDictKeysObject` (или `_dictkeysobject`) — это внутренняя структура CPython, которая хранит **ключи и хеш-таблицу**
для словарей.  
Она отделена от `PyDictObject` и может быть **общей** для нескольких словарей (экономия памяти).  
Это "сердце" быстрого поиска в `dict[key]`.

### Описание

- `Py_ssize_t dk_size` — размер **хеш-таблицы** (количество слотов, обычно больше `ma_used`).  
  Python резервирует больше места, чтобы избежать частых перехеширований.

- `enum dict_keys_kind dk_kind` — тип структуры ключей:
    - `DICT_KEYS_UNICODE` — оптимизация для строковых ключей (самый частый случай).
    - `DICT_KEYS_GENERAL` — для произвольных хешируемых объектов.

- `union { ... } dk` — **союз** (union) с разными вариантами хранения:
    - `PyDictUnicodeEntry *dk_entries` — **полная таблица** ключ+значение (для "старых" словарей).
    - `PyDictKeyEntry *dk_indices` — **только индексы** для быстрого поиска (современный split table).

- `uint64_t dk_version_tag` — версия ключей (синхронизируется с `ma_version_tag` словаря).

### Уточнения

- **Union** позволяет экономить память: разные словари используют разные форматы в зависимости от содержимого.
- В Python 3.9+ **преобладает split table** (`dk_indices` + отдельные `ma_values`), `dk_entries` используется редко.
- `dk_size` определяет, сколько элементов в `dk_indices[]` для поиска по хэшу (open addressing с probing).
- Общие `ma_keys` используются в `__dict__` экземпляров одного класса — все объекты делят одну таблицу ключей.

---

## list (PyListObject)

```c
typedef struct {
    PyObject_VAR_HEAD         // PyObject + ob_size (длина)
    PyObject **ob_item;       // Указатели на элементы
    Py_ssize_t allocated;     // Выделенная ёмкость (> ob_size)
} PyListObject;
```

### Общее

`PyListObject` — это внутренняя структура CPython, которая описывает объект **списка (`list`)**.  
Когда вы создаёте список вроде `[1, 2, 3]`, в памяти Python создаёт именно такую структуру.  
Она хранит указатели на элементы, информацию о длине и о том, сколько памяти зарезервировано под будущие добавления.

### Описание

- `PyObject_VAR_HEAD` — стандартный заголовок переменных объектов, который добавляет поля:
    - `ob_refcnt` — счётчик ссылок (управление памятью).
    - `ob_type` — ссылка на тип (`list`).
    - `ob_size` — текущее количество элементов в списке (то, что возвращает `len(lst)`).

- `PyObject **ob_item;` — указатель на **массив ссылок** (указателей) на реальные объекты Python.  
  То есть сам список хранит не данные, а только ссылки — например, `[1, "a"]` содержит ссылки на `PyLongObject(1)` и
  `PyUnicodeObject("a")`.

- `Py_ssize_t allocated;` — количество ячеек, реально выделенных под элементы.  
  Оно может быть больше, чем `ob_size`, чтобы ускорить `append()` и не выделять память при каждом добавлении.

### Уточнения

- Разница между `ob_size` и `allocated` помогает Python делать **динамическое расширение** списка (амортизация вставок).
- Список — это не массив примитивов, а **массив указателей на объекты**, поэтому изменение одного списка не трогает
  содержимое других.
- Элементы списка всегда находятся в куче (heap), и список просто хранит ссылки на них.
- При удалении элементов память под массив может быть перераспределена — это управляется внутренними функциями
  `list_resize()`.

---

## Слоты list'а (PyList_Type)

```c
PyTypeObject PyList_Type = {
    PyVarObject_HEAD_INIT(&PyType_Type, 0)  // Наследуем от type
    "list",                    // tp_name
    sizeof(PyListObject),      // tp_basicsize
    0,                         // tp_itemsize (переменная часть в ob_item)
    
    (destructor)list_dealloc,  // tp_dealloc
    0,                         // tp_print
    0,                         // tp_getattr
    0,                         // tp_setattr
    0,                         // tp_reserved
    list_repr,                 // tp_repr -> str(list)
    
    0,                         // tp_as_number
    &list_as_sequence,         // tp_as_sequence <- ВАЖНО!
    0,                         // tp_as_mapping
    (hashfunc)PyObject_HashNotImplemented,  // tp_hash (списки не хешируемы)
};
```

### Общее

`PyList_Type` — это **определение типа `list` на уровне C** внутри интерпретатора CPython.  
Эта структура описывает, как Python должен работать со списками: как их создавать, удалять, представлять в виде строки и
какие операции они поддерживают.  
По сути, это “паспорт” встроенного типа `list`, с которым работает любая функция `type()` и весь механизм ООП Python.

### Описание

- `PyVarObject_HEAD_INIT(&PyType_Type, 0)` — инициализирует заголовок типа.  
  Указывает, что `list` — это **объект типа `type`** (в Python всё — объект, включая классы).  
  Второй параметр `0` — это базовый размер для `_var`-части (переменная длина задаётся отдельно).

- `"list"` — имя типа, которое возвращает `type([]).__name__`.

- `sizeof(PyListObject)` — базовый размер структуры в памяти (заголовок + указатели, без элементов).

- `tp_itemsize = 0` — размер дополнительного элемента в переменных частях структуры не используется, потому что список
  хранит данные через `ob_item` (указатель на отдельный массив).

- `(destructor)list_dealloc` — функция, которая освобождает память списка при удалении (`tp_dealloc`).

- `list_repr` — функция, которая формирует строковое представление (`repr(list)` или `str(list)`).

- `&list_as_sequence` — ссылка на таблицу функций, описывающих поведение списка как **последовательности** (sequence
  protocol).  
  Именно отсюда берутся операции `len(lst)`, `lst[i]`, `lst.append()` и `lst[i:j]`.

- `(hashfunc)PyObject_HashNotImplemented` — указывает, что список **нельзя хешировать** (поэтому `hash([])` вызывает
  ошибку).

### Уточнения

- `PyList_Type` хранится в памяти как **глобальная структура**, доступная интерпретатору для всех операций со списками.
- В ней много других полей, которые здесь не показаны (например, для инициализации, копирования, итераций).
- Протокол `tp_as_sequence` делает список совместимым с универсальными функциями Python, которые работают со всеми
  последовательностями (`tuple`, `str` и др.).
- Поскольку список изменяемый, Python специально запрещает его хеширование, чтобы не нарушать поведение словарей и
  множеств.

---

## Доступ к элементу у list

```c
static PyObject *list_item(PyListObject *self, Py_ssize_t i) {
    if (i < 0 || i >= Py_SIZE(self)) {
        PyErr_SetString(PyExc_IndexError, "list index out of range");
        return NULL;
    }
    Py_INCREF(self->ob_item[i]);   // Увеличиваем refcnt
    return self->ob_item[i];       // Возвращаем элемент
}
```

### Общее

`list_item` — это внутренняя C‑функция, которая реализует поведение **доступа к элементу списка по индексу** — то есть
выражение `lst[i]` в Python.  
Она безопасно проверяет границы индекса и возвращает нужный элемент, корректно управляя счётчиком ссылок (чтобы объект
не был удалён преждевременно).

### Описание

- `if (i < 0 || i >= Py_SIZE(self))` — проверка выхода за границы.  
  Функция `Py_SIZE(self)` возвращает текущее количество элементов (`ob_size` из `PyListObject`).  
  Если индекс меньше нуля или больше последнего элемента, выбрасывается исключение `IndexError`.

- `PyErr_SetString(PyExc_IndexError, "list index out of range");` — создаёт и поднимает стандартное исключение Python,
  полностью аналогичное тому, что видит пользователь.

- `Py_INCREF(self->ob_item[i]);` — увеличивает счётчик ссылок на возвращаемый объект, чтобы гарантировать, что он не
  удалится из памяти, пока Python-код им пользуется.

- `return self->ob_item[i];` — возвращает указатель на объект, находящийся по данному индексу (элемент списка).

### Уточнения

- Проверка диапазона обязательна, потому что в C нет защиты от обращения к памяти за пределами массива — это
  предотвращает падения интерпретатора.
- В Python отрицательные индексы (`lst[-1]`) обрабатываются **на более высоком уровне** — сюда уже приходит вычисленный
  положительный индекс.
- Увеличение `refcount` обеспечивает **безопасность памяти**: даже если элемент будет удалён из списка, ссылка,
  возвращённая из этой функции, останется действительной в пользовательском коде.
- Эта функция является частью реализации **sequence protocol**, который отвечает за операции индексирования и срезов.

---

# bytes (...)

...

---

# Создание bytes (...)

...

---

# bytearray (...)

...

---

# Создание bytearray (...)

...

---

# set (...)

...

---

# Создание set (...)

...

---

# frozenset (...)

...

---

# Создание frozenset (...)

...

---

# bool (...)

...

---

# Создание bool (...)

...

---

# NoneType (...)

...

---

## GC-интеграция для контейнеров

```c
// list_traverse - обход ссылок для GC
static int list_traverse(PyListObject *o, visitproc visit, void *arg) {
    Py_ssize_t i = 0;
    Py_ssize_t len = Py_SIZE(o);
    for (; i < len; i++) {
        Py_VISIT(o->ob_item[i]);  // Отмечаем каждый элемент как живой
    }
    return 0;
}

// list_clear - разрыв циклических ссылок
static int list_clear(PyListObject *o) {
    Py_ssize_t i = 0;
    Py_ssize_t len = Py_SIZE(o);
    for (; i < len; i++) {
        Py_XDECREF(o->ob_item[i]);  // Уменьшаем refcnt элементов
        o->ob_item[i] = NULL;       // NULL'им ссылки
    }
    return 0;
}
```

### Общее

`list_traverse` и `list_clear` — внутренние функции CPython для **работы с сборщиком мусора (GC)**.  
Они помогают Python находить циклические ссылки и правильно освобождать память при удалении списка.  
Вызываются автоматически при сборке мусора или уничтожении объекта.

### Описание

- **`list_traverse(PyListObject *o, visitproc visit, void *arg)`** — обход всех элементов списка:
    - `Py_SIZE(o)` — получает длину списка (`ob_size`).
    - `Py_VISIT(o->ob_item[i])` — вызывает callback `visit()` для каждого элемента, помечая его как "живой" (доступный).
    - Возвращает `0` — успех обхода.

- **`list_clear(PyListObject *o)`** — очищает список от ссылок:
    - `Py_XDECREF(o->ob_item[i])` — уменьшает счётчик ссылок элемента (если он был 1, элемент удаляется).
    - `o->ob_item[i] = NULL` — обнуляет ссылку в списке, разрывая циклические связи.
    - Возвращает `0` — успех очистки.

### Уточнения

- `Py_VISIT()` и `Py_XDECREF()` — **стандартные макросы CPython** для безопасного управления ссылками в GC.
- `list_traverse` используется **generational GC** для предотвращения утечек памяти при циклах (список ссылается на
  себя).
- `list_clear` вызывается в `list_dealloc()` перед освобождением памяти, чтобы элементы могли быть собраны GC.
- Обе функции работают за **O(n)** — линейное время пропорционально длине списка.

---

## Байткод-интеграция: LIST_APPEND

```c
case LIST_APPEND: {
    PyObject *v = TOP();              // Берём значение с вершины стека
    PyObject *list = PEEK(oparg + 1); // Берём список из фиксированной позиции
    Py_ssize_t index = oparg;         // Индекс списка в localsplus
    
    // Вызываем list.append(v)
    int err = PyList_Append(list, v);
    Py_DECREF(v);                     // Освобождаем значение
    
    if (err == 0) {
        STACKADJ(-1);                 // Убираем значение со стека
    } else {
        // Ошибка - прерываем выполнение
        break;
    }
    DISPATCH_SAME_OPARG(1);           // Следующая инструкция
}
```

### Общее

Этот код — **часть байткод-интерпретатора CPython**, обрабатывающая инструкцию `LIST_APPEND`.  
Она реализует операцию `list.append(v)` на уровне виртуальной машины Python.  
Выполняется при вызове `lst.append(value)` в Python-коде.
Инструкция `LIST_APPEND` в байт-коде Python оптимизирована для работы с генераторами списков (list comprehensions),
например `[x for x in lst]`.

### Описание

- `PyObject *v = TOP();` — берёт **значение** с вершины стека виртуальной машины (то, что добавляем в список).
- `PyObject *list = PEEK(oparg + 1);` — берёт **список** из стека по смещению `oparg + 1` (список уже лежит ниже).
- `Py_ssize_t index = oparg;` — `oparg` содержит индекс списка в локальных переменных (`localsplus`).
- `int err = PyList_Append(list, v);` — вызывает стандартную функцию добавления в конец списка.
- `Py_DECREF(v);` — уменьшает счётчик ссылок значения (оно больше не нужно на стеке).
- `STACKADJ(-1);` — убирает значение со стека (при успехе остаётся только список).
- `DISPATCH_SAME_OPARG(1);` — переходит к следующей инструкции байткода.

### Уточнения

- `LIST_APPEND` — **оптимизированная инструкция** Python 3.9+, ускоряет `append()` за счёт прямого вызова C-функции.
- `TOP()` и `PEEK()` — макросы для доступа к стековой машине (frame->stack).
- `PyList_Append()` автоматически увеличивает `allocated`, если список заполнен (over-allocation).
- При ошибке (`err != 0`) выполнение прерывается, выбрасывая исключение (например, `TypeError`).
- `DISPATCH_SAME_OPARG(1)` — "быстрый dispatch" без изменения аргумента операции.

---

[Содержание](/CONTENTS.md#содержание)
