# **Типы данных**

## **Junior Level**

Типы данных в Python делятся на **изменяемые** (mutable) и **неизменяемые** (immutable).

**Простые типы:**

- Числа: `int`, `float`, `decimal`, `complex`
- Строки: `str`
- Логические значения: `bool`
- Специальный тип: `NoneType` (единственное значение `None`)

**Коллекционные типы:**

- `list` — изменяемая упорядоченная коллекция
- `tuple` — неизменяемая упорядоченная коллекция
- `dict` — изменяемая коллекция пар «ключ-значение» (упорядоченная с Python 3.7)
- `set` / `frozenset` — изменяемое и неизменяемое множества уникальных элементов
- `bytes` / `bytearray` — неизменяемая и изменяемая последовательности байтов

## **Middle Level**

1. **Ключевые различия мутабельности:**
    - **Изменяемые:** `list`, `dict`, `set`, `bytearray`, пользовательские классы. Можно модифицировать после создания.
    - **Неизменяемые:** `int`, `float`, `decimal`, `str`, `bytes`, `tuple`, `frozenset`, `bool`, `NoneType`. Любая
      операция создаёт новый объект.

2. **Практические следствия:**
    - Передача изменяемых объектов в функции позволяет модифицировать оригинал
    - Только неизменяемые объекты могут быть ключами словаря (требуется хэшируемость)
    - Мутабельность влияет на потокобезопасность и кэширование

3. **Специфика типов:**
    - `None` — синглтон, обозначающий отсутствие значения
    - `bool` — подкласс `int`, значения `True` и `False` — синглтоны
    - `tuple` — неизменяем, но может содержать изменяемые элементы
    - `set`/`frozenset` — хранят только хэшируемые элементы, реализация аналогична словарям без значений

## **Senior Level**

В CPython **все типы данных** наследуют от базовой структуры `PyObject`, которая содержит refcount и указатель на тип.
Каждый тип описывается массивом **слотов** в `PyTypeObject`.
`Include/object.h`, `Include/cpython/object.h`

## 1. Базовая структура PyObject

```c
typedef struct _object {
    _PyObject_HEAD_EXTRA       // Платформо-зависимые поля для отладки (PyDebug)
    Py_ssize_t ob_refcnt;      // Счётчик ссылок - при 0 вызывается tp_dealloc
    struct _typeobject *ob_type; // Указатель на PyTypeObject описывающий тип
} PyObject;
```

# Описание структуры PyObject в CPython

## Общее

Это **фундаментальная C-структура из ядра CPython**, которая представляет любой объект в Python на самом низком уровне.
Каждый объект в Python — будь то число, строка, список или ваш собственный класс — в памяти выглядит как экземпляр этой
структуры. Она содержит три ключевых компонента: счётчик ссылок (для управления памятью), указатель на тип объекта и
служебные поля для отладки.

## Описание ключевых компонентов

**Отладочная информация:**

- `_PyObject_HEAD_EXTRA` — это не одно поле, а макрос, который раскрывается в дополнительные платформо-зависимые поля *
  *только в отладочных сборках Python** (когда интерпретатор скомпилирован с флагом `--with-pydebug`). В обычных сборках
  это ничего не добавляет. Используется для отслеживания проблем с памятью.

**Счётчик ссылок:**

- `ob_refcnt` — целое число, которое **считает, сколько переменных или структур указывают на этот объект**. Когда
  счётчик становится 0, Python вызывает функцию `tp_dealloc` (из `PyTypeObject`) для освобождения памяти. Это основной
  механизм управления памятью в CPython (garbage collection через reference counting).

**Указатель на тип:**

- `ob_type` — указатель на структуру `PyTypeObject`, которая описывает тип этого объекта. Это то же самое, что
  возвращает встроенная функция `type(obj)` в Python. Через этот указатель интерпретатор узнаёт, как работать с
  объектом: какие операции он поддерживает, как получить его атрибуты, как его удалить.

## Уточнения

1. **Reference counting — это не threading-safe по умолчанию**: В CPython счётчик ссылок работает за счёт глобальной
   блокировки (GIL — Global Interpreter Lock), поэтому многопоточность имеет ограничения. В Python 3.13+ появился режим
   free-threaded, где это иначе.

2. **_PyObject_HEAD_EXTRA — макрос, не поле**: В исходном коде это определено как `#define _PyObject_HEAD_EXTRA` и может
   быть пустым или содержать дополнительные поля. Не путайте с обычными полями структуры.

3. **Минимальный размер**: Даже самый простой объект в памяти занимает как минимум столько байт, сколько занимает
   `PyObject` (обычно 16-24 байта на 64-битной системе в зависимости от конфигурации). Это почему в Python много памяти
   уходит на служебную информацию, даже для маленьких объектов.

4. **ob_refcnt увеличивается и уменьшается постоянно**: Каждый раз, когда вы присваиваете объект переменной, счётчик
   увеличивается на 1. Когда переменная удаляется или переназначается, счётчик уменьшается на 1. Вы можете проверить это
   функцией `sys.getrefcount(obj)`.

5. **Связь с PyTypeObject**: `PyObject` и `PyTypeObject` работают вместе: `PyObject` — это экземпляр, `PyTypeObject` —
   это описание класса. Например, объект `5` имеет `ob_type`, указывающий на `PyTypeObject` для типа `int`.

## 2. PyVarObject для контейнеров

```c
typedef struct {
    PyObject ob_base;          // Встроенный PyObject (refcnt + type)
    Py_ssize_t ob_size;        // Количество элементов (длина строки/списка)
} PyVarObject;
```

`PyVarObject` является расширением базового `PyObject` и используется для типов с переменным количеством элементов.
Структура включает дополнительное поле `ob_size`, которое хранится сразу после стандартного заголовка.

- `ob_size` содержит количество элементов в объекте, но его значение зависит от типа:
    - Для строк (`str`) — количество символов (Unicode code points)
    - Для байтовых объектов (`bytes`, `bytearray`) — количество байт
    - Для списков (`list`), кортежей (`tuple`) — количество элементов
    - Для массивов (`array.array`) — количество элементов указанного типа

**Важные уточнения:**

- Не все коллекции используют `PyVarObject`. Например, словари (`dict`) и множества (`set`) имеют собственные структуры,
  где размер хранится отдельно
- Поле `ob_size` может не соответствовать выделенной памяти: списки хранят дополнительную ёмкость для эффективного
  добавления элементов
- Для строк и кортежей `ob_size` фиксирован после создания, для списков может изменяться

## 3. PyTypeObject - "паспорт" каждого типа

```c
typedef struct _typeobject {
    PyVarObject ob_base;       // Тип сам является объектом (можно наследовать)
    
    const char *tp_name;       // Имя типа ("list", "dict", "int")
    Py_ssize_t tp_basicsize;   // Размер в байтах без переменной части
    Py_ssize_t tp_itemsize;    // Размер одного элемента переменной части
    
    destructor tp_dealloc;     // Функция уничтожения (list_dealloc)
    printfunc tp_print;        // Для print()
    reprfunc tp_repr;          // Для repr()
    
    // Протокол чисел
    PyNumberMethods *tp_as_number;  // nb_add, nb_sub, nb_multiply...
    
    // Протокол последовательностей
    PySequenceMethods *tp_as_sequence; // sq_item, sq_ass_slice...
    
    // Протокол маппингов
    PyMappingMethods *tp_as_mapping;  // mp_subscript, mp_ass_subscript
    
    // Поиск атрибутов
    getattrofunc tp_getattro;      // obj.attr
    setattrofunc tp_setattro;      // obj.attr = value
    
    // Дескрипторы (property, method)
    descrgetfunc tp_descr_get;     // __get__
    descrsetfunc tp_descr_set;     // __set__
    
    Py_ssize_t tp_dictoffset;      // Смещение __dict__ (или -1)
    Py_ssize_t tp_weaklistoffset;  // Смещение weakref списка
    
    PyObject *tp_mro;              // Method Resolution Order (tuple типов)
    PyObject *tp_cache;            // Кеш атрибутов (free-threaded)
    unsigned int tp_subclasses;    // Количество живых подклассов
    
    PyObject *tp_dict;             // __dict__ класса
    // ... 100+ слотов
} PyTypeObject;
```

# Описание структуры PyTypeObject в Python

## Общее

Это **внутренняя C-структура из ядра Python**, которая определяет тип объекта на самом низком уровне. Каждый класс и
встроенный тип в Python (list, dict, int, str) представлены в памяти именно такой структурой. Она содержит всю
метаинформацию о типе: имя, размер, методы обработки операций (сложение, индексирование), управление атрибутами и многое
другое. Это фундамент, на котором работает весь механизм объектно-ориентированного программирования в Python.

## Описание ключевых компонентов

**Базовая информация:**

- `ob_base` — каждый тип сам является объектом (в Python всё является объектом, включая сами типы)
- `tp_name` — строка с именем типа, которая выводится, например, при вызове `type(obj).__name__`
- `tp_basicsize` и `tp_itemsize` — память: базовый размер структуры плюс размер на один элемент для переменных
  контейнеров (список с 10 элементами занимает `basicsize + 10 * itemsize` байт)

**Управление жизненным циклом:**

- `tp_dealloc` — функция уничтожения объекта, вызывается при удалении (соответствует `__del__` на уровне C)
- `tp_print`, `tp_repr` — старый способ для вывода и представления (в Python 3.9+ `tp_print` устарел)

**Протоколы операций** — указатели на структуры с функциями для конкретных операций:

- `tp_as_number` — арифметические операции: `__add__`, `__sub__`, `__mul__` и т.д.
- `tp_as_sequence` — операции последовательностей: `obj[i]`, `obj[i:j]`, `len(obj)`
- `tp_as_mapping` — операции словарей: `obj[key]`, `len(obj)` для словарей

**Управление атрибутами:**

- `tp_getattro` / `tp_setattro` — низкоуровневые функции для доступа к атрибутам (`obj.attr` и `obj.attr = value`)

**Дескрипторы:**

- `tp_descr_get` / `tp_descr_set` — механизм дескрипторов, на котором работают `property`, методы класса, статические
  методы

**Служебная информация:**

- `tp_dictoffset` — смещение в памяти, где находится `__dict__` объекта (словарь атрибутов экземпляра)
- `tp_mro` — кортеж типов в порядке разрешения методов (Method Resolution Order) — порядок поиска атрибутов в иерархии
  наследования
- `tp_dict` — `__dict__` самого класса, где хранятся методы и атрибуты класса

## Уточнения

1. **C-структура, но видна из Python**: Вы не работаете с этой структурой напрямую в коде на Python, но когда пишете
   класс с методами `__add__`, `__getitem__` или `__get__`, Python переводит эти методы в соответствующие C-функции в
   этой структуре для производительности.

2. **tp_print устарел**: В Python 3.9+ поле `tp_print` более не используется. Вывод объектов управляется через `tp_repr`
   и `tp_str`.

3. **100+ слотов**: Код содержит комментарий «... 100+ слотов», что означает в реальной структуре есть множество
   дополнительных полей для специальных случаев, обработки исключений, сериализации и прочего. Здесь показаны только
   самые важные.

4. **Зачем это нужно знать**: Если вы пишете расширения на C для Python или оптимизируете критичные места, понимание
   этой структуры помогает правильно определить поведение типа. Для обычного Python-кода достаточно знать, что она
   существует.

5. **Про free-threaded**: Поле `tp_cache` относится к улучшениям для параллельного выполнения (free-threaded Python),
   актуально для Python 3.13+, для Python 3.9-3.12 на него можно не обращать внимание.

## 4. PyLongObject (int) - переменной точности

```c
typedef uint32_t digit;        // 30-битная цифра (2^30 = ~1e9)

typedef struct _longobject {
    PyObject_VAR_HEAD          // PyObject + ob_size (кол-во цифр)
    digit ob_digit[1];         // Массив цифр (размер ob_size)
} PyLongObject;
```

Целые числа хранятся как массив 30-битных "цифр". Маленькие числа (-5..256) кешируются как singletons для экономии
памяти.

**Создание PyLongObject:**

```c
PyObject *_PyLong_New(Py_ssize_t size) {
    PyLongObject *result;
    
    size = Py_ABS(size);  // Берем модуль размера
    
    // Выделяем память под заголовок + массив цифр
    result = PyObject_MALLOC(sizeof(PyLongObject) + 
                             (size-1) * sizeof(digit));
    if (!result) {
        return PyErr_NoMemory();
    }
    
    // Инициализируем как PyObject
    PyObject_INIT(result, &PyLong_Type);
    Py_SET_SIZE(result, size);  // Устанавливаем ob_size
    result->ob_digit[0] = 0;    // Нулевая цифра
    
    return (PyObject *)result;
}
```

Выделяем ровно столько памяти, сколько нужно под заголовок + нужное количество 30-битных цифр.
Например, число 1e18 требует ~6 цифр (6*30=180 бит).

## 5. PyListObject со слотами протоколов

```c
typedef struct {
    PyObject_VAR_HEAD         // PyObject + ob_size (длина)
    PyObject **ob_item;       // Указатели на элементы
    Py_ssize_t allocated;     // Выделенная ёмкость (> ob_size)
} PyListObject;
```

Список - это массив указателей на PyObject*. `allocated` больше `ob_size` для оптимизации (
over-allocation ~1.125x).

**Слоты PyList_Type:**

```c
PyTypeObject PyList_Type = {
    PyVarObject_HEAD_INIT(&PyType_Type, 0)  // Наследуем от type
    "list",                    // tp_name
    sizeof(PyListObject),      // tp_basicsize
    0,                         // tp_itemsize (переменная часть в ob_item)
    
    (destructor)list_dealloc,  // tp_dealloc
    0,                         // tp_print
    0,                         // tp_getattr
    0,                         // tp_setattr
    0,                         // tp_reserved
    list_repr,                 // tp_repr -> str(list)
    
    0,                         // tp_as_number
    &list_as_sequence,         // tp_as_sequence <- ВАЖНО!
    0,                         // tp_as_mapping
    (hashfunc)PyObject_HashNotImplemented,  // tp_hash (списки не хешируемы)
};
```

`tp_as_sequence` указывает на таблицу со слотами `sq_item` (lst), `sq_slice` (lst[1:3]),
`sq_ass_slice` (lst[1:3]=[]).

**list_as_sequence.sq_item (lst[i]):**

```c
static PyObject *list_item(PyListObject *self, Py_ssize_t i) {
    if (i < 0 || i >= Py_SIZE(self)) {
        PyErr_SetString(PyExc_IndexError, "list index out of range");
        return NULL;
    }
    Py_INCREF(self->ob_item[i]);   // Увеличиваем refcnt
    return self->ob_item[i];       // Возвращаем элемент
}
```

Проверяем индекс, увеличиваем refcnt элемента (теперь владелец отвечает за его жизнь),
возвращаем указатель.

## 6. PyDictObject с split table (с 3.6)

```c
typedef struct {
    Py_ssize_t ma_used;        // Кол-во ключей (не слотов!)
    uint64_t ma_version_tag;   // Версия для итераторов
    PyDictKeysObject *ma_keys; // Общие ключи
    PyObject **ma_values;      // Массив значений
} PyDictObject;
```

С 3.6 словари компактные: ключи вынесены в отдельную `PyDictKeysObject`, значения в массиве.
`ma_used` считает реальные пары, а не слоты.

**PyDictKeysObject:**

```c
struct _dictkeysobject {
    Py_ssize_t dk_size;        // Размер хеш-таблицы
    enum dict_keys_kind dk_kind; // DICT_KEYS_UNICODE и т.д.
    union {
        PyDictUnicodeEntry *dk_entries;  // Полная таблица key+value
        PyDictKeyEntry *dk_indices;      // Только индексы
    } dk;
    uint64_t dk_version_tag;
};
```

Ключи компактно хранятся в `PyDictKeysObject`, который может быть **shared** между словарями (
экономия памяти).

## 7. GC-интеграция для контейнеров

```c
// list_traverse - обход ссылок для GC
static int list_traverse(PyListObject *o, visitproc visit, void *arg) {
    Py_ssize_t i = 0;
    Py_ssize_t len = Py_SIZE(o);
    for (; i < len; i++) {
        Py_VISIT(o->ob_item[i]);  // Отмечаем каждый элемент как живой
    }
    return 0;
}

// list_clear - разрыв циклических ссылок
static int list_clear(PyListObject *o) {
    Py_ssize_t i = 0;
    Py_ssize_t len = Py_SIZE(o);
    for (; i < len; i++) {
        Py_XDECREF(o->ob_item[i]);  // Уменьшаем refcnt элементов
        o->ob_item[i] = NULL;       // NULL'им ссылки
    }
    return 0;
}
```

---

Контейнеры в Python (списки, словари и др.) могут создавать циклические ссылки, когда содержат ссылки на самих себя или
другие контейнеры. Чтобы обнаруживать и очищать такие циклы, Python использует механизм циклического сборщика мусора (
GC).

Для работы с GC каждый контейнер должен предоставлять две специальные функции:

1. **`tp_traverse` (обход ссылок)**  
   Функция `list_traverse` вызывается GC для "посещения" всех объектов, на которые ссылается список.  
   `Py_VISIT` помечает каждый элемент как достижимый, что предотвращает его ошибочное удаление.

2. **`tp_clear` (очистка ссылок)**  
   Когда GC обнаруживает цикл из недостижимых объектов, он вызывает `list_clear` для безопасного разрыва ссылок.  
   Функция уменьшает счетчики ссылок элементов и обнуляет указатели, позволяя GC корректно освободить память.

Без этих функций контейнеры с циклическими ссылками никогда не освобождались бы, вызывая утечки памяти.

## 8. Байткод-интеграция: LIST_APPEND

```c
case LIST_APPEND: {
    PyObject *v = TOP();              // Берём значение с вершины стека
    PyObject *list = PEEK(oparg + 1); // Берём список из фиксированной позиции
    Py_ssize_t index = oparg;         // Индекс списка в localsplus
    
    // Вызываем list.append(v)
    int err = PyList_Append(list, v);
    Py_DECREF(v);                     // Освобождаем значение
    
    if (err == 0) {
        STACKADJ(-1);                 // Убираем значение со стека
    } else {
        // Ошибка - прерываем выполнение
        break;
    }
    DISPATCH_SAME_OPARG(1);           // Следующая инструкция
}
```

Инструкция `LIST_APPEND` в байт-коде Python оптимизирована для работы с генераторами списков (list comprehensions),
например `[x for x in lst]`. Рассмотрим логику:

1. **Обычный подход**: При добавлении элементов в список через метод `append()` в цикле, список каждый раз должен быть
   на вершине стека. Это требует лишних операций `PUSH` и `POP` для управления стеком в каждой итерации.

2. **Оптимизация в генераторах списков**:
    - Список-аккумулятор (в который собираются результаты) создаётся **один раз** в начале работы генератора.
    - Он сохраняется в специальной области памяти — `localsplus` (слот для локальных переменных и временных значений).
    - Инструкция `LIST_APPEND` использует аргумент `oparg` для прямого доступа к этому слоту (`PEEK(oparg + 1)`), минуя
      вершину стека.
    - Значение для добавления (`v`) по-прежнему берётся с вершины стека (`TOP()`), после чего стек освобождается (
      `STACKADJ(-1)`).

**Преимущества**:

- **Экономия операций**: Исключаются лишние манипуляции со стеком (не нужно постоянно перемещать список на стек и
  обратно).
- **Скорость**: Прямой доступ к `localsplus` выполняется быстрее, чем работа со стеком.

**Пример для понимания**:  
В генераторе `[x*2 for x in range(5)]`:

- Список-аккумулятор `result` хранится в `localsplus` (условно в слоте `0`).
- На каждой итерации вычисленное значение `x*2` помещается на стек.
- `LIST_APPEND` берёт список из `localsplus[0]`, добавляет к нему значение с вершины стека, и очищает стек.

Такой подход делает выполнение генераторов списков более эффективным по сравнению с обычным циклом с `append()`.

## 9. Инициализация типов: PyType_Ready

```c
int PyType_Ready(PyTypeObject *type) {
    if (type->tp_flags & Py_TPFLAGS_READY)  // Уже инициализирован
        return 0;
    
    // Наследуем слоты от базовых классов
    if (type->tp_bases) {
        Py_ssize_t i, nbase = PyTuple_GET_SIZE(type->tp_bases);
        for (i = 0; i < nbase; i++) {
            PyTypeObject *base = (PyTypeObject *)PyTuple_GET_ITEM(type->tp_bases, i);
            if (PyType_Ready(base) < 0)
                return -1;
            
            // Наследуем слоты (tp_as_number, tp_as_sequence...)
            inherit_special(base, type);
        }
    }
    
    // Вычисляем MRO
    if (mro_internal(type) < 0)
        return -1;
        
    // Инициализируем tp_dict
    if (type->tp_dict == NULL) {
        if (PyType_AllocDict(type) < 0)
            return -1;
    }
    
    type->tp_flags |= Py_TPFLAGS_READY;  // Отмечаем готовым
    return 0;
}
```

Перед первым использованием типа вызывается PyType_Ready. Оно наследует слоты от родителей,
вычисляет MRO, создаёт `__dict__` класса. Без этого тип не готов к работе.

Типы данных в CPython — это **PyTypeObject** с 100+ слотами протоколов, живущие в памяти как обычные объекты, с
refcount'ами, GC-интеграцией и наследованием слотов через MRO.

- [Содержание](/CONTENTS.md#содержание)
