OBJECTIVE:

- Сократи ответ до минимум одного, максимум трёх предложений. Это должен быть быстрый ответ на собеседовании (его можно
  заучить и он должен быть
  верным).

DATA:

# **Garbage Collector (Сборщик мусора)**

Сборщик мусора в Python использует два основных механизма: подсчёт ссылок для немедленного освобождения памяти, когда
счётчик достигает нуля, и циклический сборщик для обнаружения и удаления недостижимых групп объектов, ссылающихся друг
на друга. Объекты делятся на три поколения, что оптимизирует процесс, так как большинство объектов живут недолго. Модуль
`gc` позволяет управлять этим процессом, получать статистику и настраивать поведение сборщика.

## **Junior Level**

Сборщик мусора в Python — это автоматический механизм управления памятью, который освобождает память от объектов,
которые больше не используются программой. Python использует комбинированный подход: **подсчет ссылок (reference
counting)** для немедленного освобождения памяти и **циклический сборщик мусора (cycle collector)** для обнаружения и
удаления циклических ссылок.

Представьте, что каждый объект в Python имеет счётчик, который увеличивается при создании новой ссылки на объект и
уменьшается при удалении ссылки. Когда счётчик достигает нуля, объект немедленно удаляется. Однако, если два объекта
ссылаются друг на друга (циклическая ссылка), их счётчики никогда не станут нулевыми. Для таких случаев существует
циклический сборщик мусора, который периодически запускается и находит недостижимые циклы.

Модуль `gc` позволяет управлять сборщиком мусора, получать статистику и настраивать поведение.

## **Middle Level**

1. **Два механизма управления памятью**:
    - **Подсчет ссылок**: Каждый объект хранит счётчик ссылок (`ob_refcnt`). При создании ссылки счётчик увеличивается,
      при удалении — уменьшается. При достижении нуля вызывается деструктор (`__del__`) и память освобождается. Это
      происходит немедленно и предсказуемо.
    - **Циклический сборщик**: Обнаруживает и удаляет группы объектов, которые ссылаются друг на друга, но недостижимы
      из основной программы.

2. **Поколения объектов (Generational GC)**:
    - Объекты делятся на три поколения (0, 1, 2). Новые объекты попадают в поколение 0.
    - Чаще всего запускается сборка в поколении 0, реже — в 1, ещё реже — в 2.
    - Основано на эмпирическом наблюдении: большинство объектов живут недолго.

3. **Пороги сборки**:
    - Параметры `gc.get_threshold()` возвращают кортеж (threshold0, threshold1, threshold2).
    - Сборка в поколении 0 запускается, когда количество выделений минус освобождений превышает threshold0.
    - После определённого числа сборок в поколении 0 запускается сборка в поколении 1 и т.д.

4. **Модуль `gc`**:
    - `gc.enable()` / `gc.disable()`: Включение/выключение циклического сборщика.
    - `gc.collect(generation=None)`: Принудительный запуск сборки.
    - `gc.get_referents(obj)`: Объекты, на которые ссылается `obj`.
    - `gc.get_referrers(obj)`: Объекты, которые ссылаются на `obj`.
    - `gc.set_debug(flags)`: Установка флагов отладки.

5. **Проблемные случаи**:
    - **Циклические ссылки с `__del__`**: Если объекты в цикле имеют метод `__del__`, сборщик не может безопасно удалить
      их (возникает `uncollectable`).
    - **Слабые ссылки (`weakref`)**: Не увеличивают счётчик ссылок, не препятствуют сборке мусора.

6. **Производительность**:
    - Подсчёт ссылок происходит при каждой операции с объектами (быстро, но постоянно).
    - Циклический сборщик запускается периодически и может вызывать паузы.

## **Senior Level**

**1. Реализация подсчёта ссылок в CPython**

В `Include/object.h`:

```c
typedef struct _object {
    Py_ssize_t ob_refcnt;        // Счётчик ссылок
    PyTypeObject *ob_type;
} PyObject;
```

Макросы для работы со счётчиком:

- `Py_INCREF(op)`: Увеличивает счётчик (атомарно в многопоточном режиме).
- `Py_DECREF(op)`: Уменьшает счётчик. При достижении нуля вызывает `_Py_Dealloc(op)`.

**2. Циклический сборщик: алгоритм и структуры**

**Поколения**: Каждое поколение — это двусвязный список объектов (`_PyGC_Head`):

```c
typedef struct _gc_head {
    uintptr_t _gc_next;   // Следующий объект в списке поколения
    uintptr_t _gc_prev;   // Предыдущий объект
    Py_ssize_t gc_refs;   // Временное поле для алгоритма
} PyGC_Head;
```

**Алгоритм обнаружения циклов (трехцветная маркировка)**:

1. **Идентификация**: Все объекты в поколении помечаются как белые (непосещённые).
2. **Поиск корней**: Обход корневых объектов (глобальные переменные, локальные переменные в стеке вызовов, регистры
   процессора). Они помечаются как серые.
3. **Распространение**: Пока есть серые объекты:
    - Берём серый объект, обходим все его ссылки.
    - Если ссылка ведёт на белый объект, делаем его серым.
    - Исходный объект становится чёрным.
4. **Очистка**: Все белые объекты (недостижимые) удаляются.

**3. Поколения и пороги**

Внутренние счетчики:

- `generations[0].count`: Количество объектов в поколении 0.
- `generations[0].threshold`: Порог для запуска сборки (по умолчанию 700).

Когда `generations[0].count > generations[0].threshold`, запускается сборка в поколении 0. После сборки выжившие объекты
перемещаются в поколение 1, и т.д.

**4. Обработка `__del__` и `gc.garbage`**

Если в цикле есть объекты с методом `__del__`, сборщик не может определить порядок вызова деструкторов. Такие объекты
помещаются в `gc.garbage` (список), чтобы программист мог обработать их вручную.

**5. Многопоточность и GIL**

Подсчёт ссылок атомарен благодаря GIL. Циклический сборщик работает так:

- При запуске сборки все потоки приостанавливаются.
- Сборщик захватывает GIL и выполняет сборку.
- Потоки возобновляются после завершения.

**6. Оптимизации CPython**

**Быстрое выделение памяти (pymalloc)**:

- Использует собственный аллокатор для небольших объектов (до 512 байт).
- Уменьшает фрагментацию и ускоряет выделение/освобождение.

**Кэширование свободной памяти**:

- Освобождённая память кэшируется для быстрого повторного использования.
- Для каждого размера объекта есть свой пул свободных блоков.

**7. Слабые ссылки (weakref)**

Реализованы через отдельную структуру:

```c
typedef struct _PyWeakReference {
    PyObject_HEAD
    PyObject *wr_object;    // Слабая ссылка (может быть NULL)
    PyObject *wr_callback;  // Колбэк при удалении объекта
    // ...
} PyWeakReference;
```

Слабые ссылки не увеличивают `ob_refcnt`, поэтому не препятствуют сборке мусора.

**8. Отладка и диагностика**

Флаги отладки (`gc.set_debug()`):

- `DEBUG_STATS`: Вывод статистики после сборки.
- `DEBUG_COLLECTABLE`: Вывод информации об удаляемых объектах.
- `DEBUG_UNCOLLECTABLE`: Вывод информации о неудаляемых объектах (с `__del__`).
- `DEBUG_SAVEALL`: Сохранение всех удаляемых объектов в `gc.garbage`.

**9. Производительность и настройка**

**Проблемы**:

- **Паузы**: Циклический сборщик может вызывать заметные паузы в работе программы.
- **Фрагментация памяти**: Частые выделения/освобождения приводят к фрагментации.

**Оптимизации**:

- Настройка порогов через `gc.set_threshold()`.
- Отключение сборщика (`gc.disable()`) в критичных по времени участках кода (с последующим ручным запуском).
- Использование слабых ссылок для предотвращения циклических ссылок.

**10. Тестирование для AQA**

**Подходы к тестированию**:

1. **Тестирование утечек памяти**:
    - Использование `tracemalloc` для отслеживания выделений.
    - Создание сценариев, которые должны освобождать память.
    - Проверка, что `gc.collect()` не находит новых недостижимых объектов.

2. **Тестирование циклических ссылок**:
    - Создание искусственных циклов и проверка их удаления.
    - Проверка объектов с `__del__` (должны попадать в `gc.garbage`).

3. **Нагрузочное тестирование**:
    - Длительная работа приложения с проверкой стабильности потребления памяти.
    - Тестирование в условиях нехватки памяти (out-of-memory).

4. **Интеграция с профилировщиками**:
    - Использование `objgraph` для визуализации графа объектов.
    - Интеграция с `pympler` для детального анализа памяти.

**11. Инструменты для анализа памяти**

- `tracemalloc`: Трассировка выделений памяти.
- `objgraph`: Визуализация графа объектов.
- `pympler`: Детальный анализ использования памяти.
- `memory_profiler`: Профилирование использования памяти построчно.
- `gc.get_objects()`: Получение списка всех отслеживаемых объектов (осторожно — может быть медленно).

**12. Специфика для разных реализаций Python**

- **CPython**: Описанный выше подход (подсчёт ссылок + циклический сборщик).
- **PyPy**: Использует сложный сборщик мусора с перемещением объектов (moving GC), более агрессивный и эффективный.
- **Jython/IronPython**: Полагаются на сборщик мусора JVM/.NET соответственно.

- [Содержание](#содержание)
