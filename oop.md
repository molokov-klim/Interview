# **Наследование vs композиция**

[Содержание](/CONTENTS.md#содержание)

## **Junior Level**

Наследование и композиция — это два фундаментальных подхода к организации кода в объектно-ориентированном
программировании, и выбор между ними определяет, насколько гибкой, понятной и удобной для поддержки будет ваша система.

Основное различие лежит в типе отношений, которые они моделируют:

* **Наследование** описывает отношение **«является»** (is-a). Например, `Dog` (Собака) наследует от `Animal` (Животное),
  потому что собака *является* конкретным видом животного. Это позволяет `Dog` автоматически получить общие для всех
  животных свойства и методы (например, `eat()` или `sleep()`), а также добавить свои уникальные (`bark()`).
* **Композиция** описывает отношение **«имеет»** (has-a). Класс `Car` (Автомобиль) не является двигателем, но он *имеет*
  его как составную часть. Двигатель — это независимый компонент, с которым автомобиль взаимодействует через четко
  определенный интерфейс.

**Ключевое правило современной разработки: предпочитайте композицию наследованию.** Наследование создает жесткую,
статическую связь, подобную родственной. Изменения в «родительском» классе могут неожиданно «сломать» всех его
«потомков». Композиция же строит более гибкие, договорные отношения: вы можете заменить «двигатель» на другой, не
переделывая всю «машину». Для тестирования это преимущество критично — компоненты, переданные через композицию, легко
подменить на заглушки (mocks), что позволяет тестировать классы изолированно.

[Содержание](/CONTENTS.md#содержание)

## **Middle Level**

### **Детали и тонкости наследования в Python**

1. **Механизм и порядок разрешения методов (MRO)**: Python поддерживает множественное наследование. Чтобы управлять
   потенциальным хаосом при поиске методов, используется строгий **MRO (Method Resolution Order)**, вычисляемый по
   алгоритму C3 (`ClassName.__mro__`). Этот порядок гарантирует, что каждый класс в иерархии будет проверен только один
   раз и предсказуемо.

2. **Инструмент `super()` и кооперативное наследование**: `super()` — это не просто вызов метода родителя. В условиях
   MRO он делегирует выполнение **следующему классу в цепочке**. Это позволяет нескольким классам-предкам (например,
   `Mixin`-ам) кооперативно участвовать в выполнении одного метода (например, `__init__`), не мешая друг другу.

3. **Наследование как потенциальное нарушение инкапсуляции**: Это ключевая критика наследования. Дочерний класс получает
   доступ к защищённым (`_protected`) членам родителя, что создает хрупкую, скрытую зависимость от его внутренней
   реализации. Тестировать такой класс сложно, так как для понимания его поведения необходимо глубоко знать детали
   работы родителя.

4. **Множественное наследование и Mixins**: Python разрешает множественное наследование, что часто используется для *
   *Mixins** — небольших классов, добавляющих конкретную функциональность (например, `JSONSerializableMixin`). Mixin не
   предназначен для использования отдельно. При их применении важно проектировать имена методов так, чтобы избежать
   конфликтов, разрешаемых через MRO.

5. **Абстрактные классы (ABC)**: Модуль `abc` позволяет создавать формальные «чертежи» — классы, объявляющие
   обязательные методы (через `@abstractmethod`). Они заставляют наследников соблюдать контракт, явно формализуя
   отношение «является».

### **Детали и тонкости композиции в Python**

1. **Композиция vs Агрегация: управление жизненным циклом**:
    * **Композиция (сильная связь)**: Компонент (например, `Heart` для `Human`) не существует отдельно. Он создаётся и
      уничтожается вместе с объектом-владельцем (обычно в `__init__`).
    * **Агрегация (слабая связь)**: Компонент (например, `Driver` для `Car`) существует независимо и передаётся объекту
      извне (как аргумент). Их жизненные циклы разделены.

2. **Композиция и структурная типизация (Протоколы)**: Вместо жесткого наследования от абстрактного класса для
   достижения полиморфизма в Python всё чаще используют **композицию с протоколами** (`typing.Protocol`). Объекту не
   нужно объявлять «я наследник `Reader`» — достаточно просто реализовать метод `read()`. Это резко снижает связанность.
   В тестах можно подставить любой объект с нужным методом, не строя сложных иерархий.

3. **Делегирование как явная форма композиции**: Паттерн **Делегирование** — это когда внешний объект (делегатор) явно
   передает выполнение задачи внутреннему объекту (делегату). В Python его можно элегантно реализовать через
   `__getattr__`, автоматически перенаправляя вызовы. Это основа для объеков-обёрток (адаптеров, прокси), которые дают
   полный контроль над взаимодействием и являются идеальной точкой для внедрения моков в тестах.

4. **Динамическое поведение**: Композиция позволяет менять поведение объекта во время выполнения программы, заменяя его
   компоненты. Этот принцип лежит в основе многих паттернов, таких как **Стратегия** (Strategy), где алгоритм можно
   «подменить на лету».

### **Сравнительный анализ для проектирования и тестирования**

* **Гибкость и связность**: Наследование фиксирует отношения на этапе компиляции, приводя к высокой связности.
  Композиция/агрегация определяют поведение во время выполнения, обеспечивая слабую связность и большую гибкость.

* **Тестируемость**: Класс, построенный на композиции, легко тестировать изолированно. Его зависимости — это просто
  аргументы, которые можно подменить. Тестирование глубокой иерархии наследования требует создания сложных фикстур и
  мокирования родительских методов, что увеличивает сложность тестов.

* **Проблема хрупкого базового класса**: Это главный риск наследования. Даже безопасное на вид изменение во внутренней
  логике родителя может сломать работу непредусмотревшего этого наследника. В больших проектах отследить такие побочные
  эффекты крайне трудно.

* **Борьба со сложностью архитектуры**: Глубокие иерархии наследования имеют тенденцию разрастаться и усложняться.
  Композиция предлагает альтернативную парадигму: строить сложную систему не через вертикальное ветвление, а через
  горизонтальную сборку из небольших, независимых и легко заменяемых компонентов. Это прямой путь к более
  поддерживаемому и надежному коду.

[Содержание](/CONTENTS.md#содержание)

## **Senior Level**

## Базовая структура объектов CPython

В CPython все объекты наследуют от базовой структуры `PyObject`, которая имитирует наследование через композицию в C.
Это видно в заголовочном файле `Include/object.h`.

```c
// Include/object.h: базовая структура всех Python объектов
#define PyObject_HEAD                   PyObject ob_base;

struct _object {
    // Счетчик ссылок (может быть разбит на части для 64-битных систем)
    union {
#if SIZEOF_VOID_P > 4
        PY_INT64_T ob_refcnt_full;
        struct {
# if PY_BIG_ENDIAN
            uint16_t ob_flags;     // Флаги объекта
            uint16_t ob_overflow;  // Переполнение refcnt
            uint32_t ob_refcnt;    // Основной счетчик ссылок
# else
            uint32_t ob_refcnt;    // Основной счетчик ссылок
            uint16_t ob_overflow;  // Переполнение refcnt
            uint16_t ob_flags;     // Флаги объекта
# endif
        };
#else
        Py_ssize_t ob_refcnt;          // Простой счетчик ссылок
#endif
    };
    PyTypeObject *ob_type;             // Указатель на тип объекта
};
```

Каждый Python-объект в памяти начинается с "шапки" — счетчика ссылок (сколько мест держит ссылку
на объект) и указателя на его тип. Это как паспорт объекта: "кто я и сколько на меня ссылок". Любая конкретная
структура (число, строка, список) начинается с этой шапки, а потом идут свои поля. Благодаря этому любой указатель на
объект можно безопасно привести к `PyObject*` — первые байты всегда одинаковые.

## PyTypeObject — сердце наследования

Типы в CPython — это объекты `PyTypeObject`, которые содержат слоты (vtable) для методов. Наследование — это копирование
и переопределение этих слотов.

```c
// Objects/typeobject.c: фрагмент инициализации типа
typedef struct {
    int slot;              // Номер слота (tp_new, tp_call и т.д.)
    void *pfunc;           // Указатель на C-функцию
} PyType_Slot;

// PyTypeObject содержит сотни таких слотов
// Ключевые для наследования:
PyTypeObject {
    PyObject_HEAD           // Наследует от PyObject
    Py_ssize_t tp_basicsize; // Размер базовой части объекта
    Py_ssize_t tp_itemsize;  // Размер для VarObject
    unsigned long tp_flags;  // Флаги типа
    PyObject *tp_bases;      // Кортеж базовых классов (!!!)
    PyObject *tp_base;       // Прямой базовый класс
    PyObject *tp_dict;       // Словарь атрибутов типа
    PyObject *tp_mro;        // Method Resolution Order
    // ... сотни слотов методов: tp_new, tp_init, tp_call ...
};
```

`PyTypeObject` — это "рецепт" для создания объектов определенного типа. Он хранит список базовых
классов (`tp_bases`) и порядок поиска методов (`tp_mro`). Когда создается новый класс, CPython копирует слоты из
родителей, разрешает конфликты по MRO и создает новый тип. Это не C++ наследование — это ручное копирование таблиц
методов.

## Инициализация наследования в PyType_Ready()

Функция `PyType_Ready()` вычисляет MRO, наследует слоты и подготавливает тип. Вот ключевой фрагмент.

```c
// Objects/typeobject.c: упрощенный фрагмент PyType_Ready()
static int
type_ready(PyTypeObject *type) {
    // 1. Берем базовые классы
    PyObject *bases = lookup_tp_bases(type);  // Кортеж родителей
    
    // 2. Вычисляем MRO (порядок разрешения методов)
    if (type->tp_mro == NULL) {
        type->tp_mro = mro_internal(type);    // C3-линеаризация
        if (type->tp_mro == NULL) {
            return -1;
        }
    }
    
    // 3. Наследуем слоты методов от родителей
    for (Py_ssize_t i = 0; i < PyTuple_GET_SIZE(bases); i++) {
        PyTypeObject *base = PyTuple_GET_ITEM(bases, i);
        inherit_slots(type, base);            // Копируем слоты
    }
    
    // 4. Разрешаем конфликты по MRO
    resolve_slots(type);
    
    // 5. Устанавливаем флаги готовности
    type_add_flags(type, Py_TPFLAGS_READY);
    return 0;
}
```

При создании класса `PyType_Ready()` делает три вещи: 1) строит MRO (очередь "от кого наследовать
методы"), 2) копирует методы из родителей в свою таблицу слотов, 3) разрешает конфликты (если метод есть у нескольких
родителей — берет по приоритету MRO). После этого тип "готов" и объекты можно создавать.

## Композиция через указатели на типы

Композиция в CPython — это когда объект содержит указатели на другие типы, а не наследует их структуры. Пример:
`PyFloatObject`.

```c
// Objects/floatobject.c: Float содержит PyObject_HEAD + свои поля
typedef struct {
    PyObject_HEAD                // Наследование "слева"
    double ob_fval;              // Свое поле: значение double
} PyFloatObject;

// Использование: любой PyFloat* можно привести к PyObject*
PyFloatObject *f = ...;
PyObject *obj = (PyObject*)f;      // Безопасно!
PyTypeObject *type = obj->ob_type; // Получаем тип float
```

Композиция — это "имеет-a": float "имеет" PyObject в начале + double. Наследование — "является-a":
любой float "является" PyObject. В памяти это одно и то же — первые байты всегда PyObject. Разница в семантике:
наследование дает слоты методов автоматически, композиция — требует явных вызовов.

## MRO (Method Resolution Order) — C3 алгоритм

MRO решает, чей метод вызывать при множественном наследовании. Вычисляется рекурсивно.

```c
// Objects/typeobject.c: упрощенный mro_internal()
static PyObject *
mro_internal(PyTypeObject *type) {
    PyObject *bases = type->tp_bases;     // Список родителей
    PyObject *seqs = PyTuple_New(1 + PyTuple_GET_SIZE(bases));
    
    // Собираем MRO всех родителей
    for (Py_ssize_t i = 0; i < PyTuple_GET_SIZE(bases); i++) {
        PyTypeObject *base = PyTuple_GET_ITEM(bases, i);
        PyObject *parent_mro = lookup_tp_mro(base);
        PyTuple_SET_ITEM(seqs, i+1, Py_NewRef(parent_mro));
    }
    
    // C3-линеаризация: решает порядок с учетом приоритетов
    PyObject *mro = merge_mros(seqs);     // Алгоритм C3
    return mro;
}
```

MRO — это "очередь родителей": сначала сам класс, потом родители слева направо, исключая уже
использованных. Алгоритм C3 гарантирует, что родители сохраняют свой порядок. При вызове метода CPython идет по этой
очереди до первого совпадения: `type->tp_call`, `base1->tp_call`, `base2->tp_call`....

## __slots__ и ограничения множественного наследования

`__slots__` конфликтует с наследованием из-за фиксированных смещений в памяти.

```c
// Objects/typeobject.c: проверка слотов при наследовании
static int
check_slots(PyTypeObject *type) {
    // Если несколько родителей с __slots__, layouts конфликтуют
    for (Py_ssize_t i = 0; i < PyTuple_GET_SIZE(type->tp_bases); i++) {
        PyTypeObject *base = PyTuple_GET_ITEM(type->tp_bases, i);
        if (base->tp_dictoffset && type->tp_dictoffset &&
            base->tp_dictoffset != type->tp_dictoffset) {
            PyErr_SetString(PyExc_TypeError,
                "multiple parents with conflicting __slots__");
            return -1;
        }
    }
    return 0;
}
```

`__slots__` фиксирует места атрибутов в памяти (экономит память, убирает `__dict__`). При
наследовании смещения должны совпадать, иначе дескрипторы слотов "смотрят не туда". Композиция решает проблему — просто
держишь объект внутри без наследования структур.

## Кэш атрибутов и версии типов

CPython кэширует поиск атрибутов через `tp_version_tag`. Изменение базовых классов инвалидирует кэш рекурсивно.

```c
// Objects/typeobject.c: инвалидация при изменении иерархии
void PyType_Modified(PyTypeObject *type) {
    BEGIN_TYPE_LOCK();                    // Глобальная блокировка типов
    type_modified_unlocked(type);         // Рекурсивно по подклассам
    END_TYPE_LOCK();
}

static void type_modified_unlocked(PyTypeObject *type) {
    // Сбрасываем версию кэша
    set_version_unlocked(type, 0);
    
    // Рекурсивно инвалидируем подклассы
    PyObject *subclasses = lookup_tp_subclasses(type);
    for each subclass in subclasses {
        type_modified_unlocked(subclass);
    }
}
```

Каждый тип имеет "версию". При поиске `obj.x` CPython проверяет кэш по версии типа. Изменение
родителей → смена версии → инвалидация кэша для всего поддерева. Это дорого, поэтому наследование иерархий в runtime —
редкость.

## Итоговое сравнение под капотом

| Аспект        | Наследование                  | Композиция                          |
|---------------|-------------------------------|-------------------------------------|
| **Память**    | PyObject_HEAD + поля          | PyObject_HEAD + указатель на объект |
| **Методы**    | Автокопирование слотов по MRO | Ручной вызов `self.child.method()`  |
| **Атрибуты**  | Поиск по MRO, кэш с версиями  | Прямой доступ через указатель       |
| **Slots**     | Конфликты layouts             | Нет проблем                         |
| **Изменение** | Инвалидация всего поддерева   | Локальное                           |

Наследование быстрее для статичных иерархий (автоматическое копирование слотов), композиция гибче (без конфликтов
слотов, локальные изменения).

- [Содержание](/CONTENTS.md#содержание)

---

# **Композиция и агрегация**

## **Junior Level*

Композиция и агрегация — это два способа создания отношений между объектами в объектно-ориентированном программировании.
Обе описывают ситуацию, когда один объект содержит в себе другой, но с критически важным различием в силе связи и
управлении жизненным циклом.

Представьте, что вы строите дом. **Композиция** — это как комната в доме. Комната не существует отдельно от дома. Когда
дом сносят, комната исчезает вместе с ним. Объект-владелец (дом) полностью контролирует жизнь объекта-части (комнаты). *
*Агрегация** — это как мебель в доме. Стол, стул, диван существуют независимо от дома. Их занесли в дом, а потом могут
вынести в другой дом или на склад. Объект-владелец (дом) использует объект-часть (мебель), но не управляет его рождением
и смертью.

В разработке композиция означает, что при уничтожении основного объекта уничтожаются и все его составные части.
Агрегация означает, что объекты собраны вместе, но могут жить самостоятельно. Для QA инженера понимание этого различия
помогает проектировать тестовые фикстуры и моки, правильно управлять их жизненным циклом и понимать, какие зависимости
нужно создавать заново, а какие можно переиспользовать между тестами.

[Содержание](/CONTENTS.md#содержание)

## **Middle Level**

С технической точки зрения, композиция и агрегация реализуются через **атрибуты класса**, но с разной семантикой
создания и владения.

1. **Реализация:**
    * **Композиция (Composition):** Объект-часть создается **внутри** конструктора (или иного метода) объекта-владельца.
      Владелец полностью инкапсулирует создание и, как правило, не предоставляет публичных методов для замены этой
      части. Часть реализуется как внутренний, приватный атрибут.
    * **Агрегация (Aggregation):** Объект-часть создается **вне** объекта-владельца и передается ему в качестве
      аргумента (чаще всего в конструктор). Владелец сохраняет ссылку на эту часть, но не управляет ее созданием.
      Объект-часть может быть общим (разделяемым) ресурсом.

2. **Жизненный цикл:**
    * При **композиции** жизненный цикл части жестко привязан к жизненному циклу целого. Когда объект-владелец
      удаляется (например, сборщиком мусора), удаляется и объект-часть, если на него больше нет ссылок.
    * При **агрегации** жизненные циклы независимы. Удаление владельца не влечет удаление части, так как на нее могут
      оставаться ссылки из других объектов.

3. **Для AQA:**
    * **Фикстуры в Pytest:** Композиция часто используется для создания сложных, вложенных фикстур, которые существуют
      только в рамках одной тестовой сессии или модуля и автоматически очищаются. Агрегация похожа на фикстуры с
      областью видимости `session` или `package`, которые создаются один раз и переиспользуются многими тестами.
    * **Тестовые данные:** Понимание, когда создавать новый экземпляр тестовых данных для каждого кейса (композиция), а
      когда использовать общий, предсозданный набор данных (агрегация), критично для скорости и изоляции тестов.
    * **Page Object:** Внутри Page Object может существовать композиция из элементов (например, `Button`, `InputField`),
      которые не имеют смысла вне контекста этой страницы. И агрегация — например, общий `Header` или `Footer`, которые
      могут быть переданы в несколько Page Object.

4. **Отличия от наследования:** И композиция, и агрегация — это альтернативы наследованию, предпочитаемые в современном
   дизайне ("предпочитай композицию наследованию"). Они обеспечивают большую гибкость и слабую связанность.

[Содержание](/CONTENTS.md#содержание)

## **Senior Level**

## Базовые структуры композиции в CPython

Композиция в CPython реализуется через **встраивание структур** (embedding) — `PyObject_HEAD` + поля + другие
`PyObject`. Агрегация — через **указатели** на объекты. Разница в управлении памятью и временем жизни.

```c
// Include/object.h: базовые макросы для композиции
#define PyObject_HEAD                   PyObject ob_base;  // Шапка: refcnt + type
#define PyObject_VAR_HEAD               PyVarObject ob_base; // Шапка + размер

struct _object {                       // PyObject — минимальный объект
    union {                            // Счетчик ссылок (refcnt)
#if SIZEOF_VOID_P > 4
        PY_INT64_T ob_refcnt_full;     // 64-битный refcnt
        struct {
# if PY_BIG_ENDIAN
            uint16_t ob_flags;         // Флаги объекта
            uint16_t ob_overflow;      // Переполнение refcnt
            uint32_t ob_refcnt;        // Основной refcnt
# else
            uint32_t ob_refcnt;        // Основной refcnt
            uint16_t ob_overflow;      // Переполнение refcnt
            uint16_t ob_flags;         // Флаги объекта
# endif
        };
#else
        Py_ssize_t ob_refcnt;          // 32-битный refcnt
#endif
    };
    PyTypeObject *ob_type;             // Указатель на тип (vtable)
};
```

`PyObject_HEAD` — это **обязательная "шапка"** в начале **каждого** Python-объекта (8-16 байт). Она содержит: 1) *
*refcnt** (сколько ссылок держит объект живым), 2) **ob_type** (указатель на таблицу методов типа). Любая структура типа
начинается с этой шапки. Композиция = шапка + свои поля + другие шапки.

## Пример композиции: PyTupleObject (строгая композиция)

Кортеж содержит **встроенный массив PyObject*** — классическая композиция "имеет-A".

```c
// Include/tupleobject.h + Objects/tupleobject.c
typedef struct {
    PyObject_VAR_HEAD                // Шапка PyObject + ob_size (кол-во элементов)
    PyObject *ob_item[1];            // Массив объектов (гибкий размер!)
} PyTupleObject;

// Реальная структура в памяти: PyObject_HEAD + Py_ssize_t ob_size + PyObject** об_item
// Размер выделяется: sizeof(PyTupleObject) + (size-1)*sizeof(PyObject*)
```

Кортеж `(1, "a", [])` в памяти — **один большой блок**: шапка кортежа + число элементов (3) + **3 указателя** на объекты
1, "a", []. Это **композиция**: кортеж **владеет** массивом указателей. Когда refcnt кортежа → 0, **все указатели
остаются жить** (их refcnt не трогаем).

## Пример агрегации: PyDictObject (слабая композиция)

Словарь содержит **указатели** на хэш-таблицу PyDictKeysObject — агрегация.

```c
// Objects/dictobject.c: PyDictObject (Python 3.9+)
typedef struct {
    PyObject_HEAD                    // Шапка словаря
    Py_ssize_t ma_used;              // Кол-во используемых слотов
    PyDictKeysObject *ma_keys;       // УКАЗАТЕЛЬ на отдельный объект ключей!!!
    PyObject **ma_values;            // Указатель на массив значений (опционально)
} PyDictObject;

typedef struct {
    Py_ssize_t dk_size;              // Размер хэш-таблицы
    PyDictUnicodeEntry *dk_entries;  // Массив записей (ключ+хэш)
    vectorcallfunc vectorcall;       // Методы для vectorcall
} PyDictKeysObject;
```

Словарь `{"a": 1}` — **два объекта**: 1) PyDictObject (шапка + указатель на ключи), 2) PyDictKeysObject (отдельная
хэш-таблица). Это **агрегация**: словарь **ссылается** на таблицу ключей, но **не владеет** ею. Таблица ключей может
использоваться **несколькими** словарями (shared keys optimization).

## Создание составных объектов: PyTuple_New()

Композиция создается **атомарно** — выделяется память под всю структуру сразу.

```c
// Objects/tupleobject.c: PyTuple_New()
PyObject *
PyTuple_New(Py_ssize_t size) {
    PyTupleObject *op;                 // Указатель на новый кортеж
    Py_ssize_t nbytes;                 // Общий размер в байтах
    
    if (size < 0) {                    // Проверка отрицательного размера
        PyErr_BadInternalCall();
        return NULL;
    }
    
    // Вычисляем размер: шапка + (size-1)*sizeof(PyObject*)
    nbytes = size * sizeof(PyObject *) + sizeof(PyTupleObject) - sizeof(PyObject *);
    
    // Выделяем память атомарно
    op = PyObject_GC_NewVar(PyTupleObject, &PyTuple_Type, size);
    if (op == NULL)                    // Ошибка выделения
        return NULL;
        
    // Инициализируем все указатели NULL (zero-filling)
    for (Py_ssize_t i = 0; i < size; i++)
        op->ob_item[i] = NULL;         // Каждый слот = NULL
    
    PyObject_GC_Track(op);             // Регистрируем в GC
    return (PyObject *) op;
}
```

`tuple(1,2,3)` → CPython **одним malloc()** выделяет **весь блок** (шапка + 3 указателя). Потом заполняет указатели
PyLong(1), PyLong(2), PyLong(3). **Композиция = единый блок памяти**. Когда refcnt → 0, **один free()** освобождает
всё.

## Разница в деструкторах: tp_dealloc

Композиция освобождает **свои** поля, агрегация — **НЕ трогает** подчиненные объекты.

```c
// Objects/tupleobject.c: tp_dealloc для PyTuple_Type
static void
tuple_dealloc(PyTupleObject *op) {
    Py_ssize_t len = Py_SIZE(op);      // Длина кортежа
    PyObject **items = op->ob_item;    // Указатель на массив
    
    PyObject_GC_UnTrack(op);           // Убираем из GC
    Py_TRASHCAN_SAFE_BEGIN(op)         // Защита от рекурсии
    
    // НЕ освобождаем ob_item[i]! Это агрегированные объекты
    // Просто обнуляем указатели (для отладки)
    while (--len >= 0) {
        Py_CLEAR(items[len]);          // Снижаем refcnt элементов
    }
    
    Py_TYPE(op)->tp_free((PyObject*)op); // free() всей структуры
    Py_TRASHCAN_SAFE_END(op)
}
```

Кортеж умирает → **НЕ трогает** содержимое (1,2,3 живут дальше), только **снижает их refcnt** и **освобождает свой блок
**. Словарь при смерти **НЕ трогает** ma_keys (агрегация). **Композиция** бы трогала встроенные объекты.

## __slots__ как экстремальная композиция

`__slots__` создает **фиксированную композицию** без `__dict__` — экономит память.

```c
// Objects/typeobject.c: обработка __slots__ в PyType_Ready()
static int
slotptr_cmp(PyObject *slot1, PyObject *slot2) {
    // Сортируем слоты по алфавиту для детерминизма
    return PyUnicode_Compare(slot1, slot2);
}

static PyObject *
collect_slots(PyTypeObject *type) {
    PyObject *slots = PyObject_GetAttrString((PyObject*)type, "__slots__");
    if (!slots) return NULL;
    
    // Сортируем и вычисляем смещения атрибутов
    Py_ssize_t nslots = PyList_GET_SIZE(slots);
    for (Py_ssize_t i = 0; i < nslots; i++) {
        PyObject *name = PyList_GET_ITEM(slots, i);
        PyMemberDef *member = create_member(name);  // Создаем дескриптор
        // member->offset = смещение в памяти экземпляра
    }
    
    type->tp_basicsize += nslots * sizeof(PyObject*); // Фиксируем размер
    return slots;
}
```

`__slots__ = ['x', 'y']` → CPython создает **фиксированные поля** сразу после PyObject_HEAD:
`[PyObject_HEAD | PyObject* x | PyObject* y]`. **Нет `__dict__`**, нет хэш-таблицы. **Чистая композиция** с известным
layout'ом памяти.

## Сравнение композиции и агрегации под капотом

| Аспект          | Композиция (встраивание)   | Агрегация (указатели)            |
|-----------------|----------------------------|----------------------------------|
| **Память**      | Единый malloc/free         | Несколько malloc (dict + keys)   |
| **Время жизни** | Владелец управляет всем    | Подчиненные живут независимо     |
| **Размер**      | sizeof(HEAD) + поля + HEAD | sizeof(HEAD) + sizeof(PyObject*) |
| **GC**          | Рекурсивно все поля        | Только указатели (не владеет)    |
| **Shared**      | Невозможно                 | Возможно (dict keys)             |

**Композиция** = "встроить структуру целиком", **агрегация** = "указатель на чужой объект". В CPython **tuple =
композиция** (встроенный массив), **dict = агрегация** (отдельные keys/values).

- [Содержание](/CONTENTS.md#содержание)

---

# **Связность и связанность**

## **Junior Level*

Связность и связанность — это две фундаментальные концепции качества кода, которые описывают, насколько хорошо
организованы компоненты внутри модуля и насколько сильно они зависят друг от друга.

**Связность (Cohesion)** отвечает на вопрос: "Насколько хорошо элементы внутри одного модуля (класса, функции) связаны
между собой и работают для достижения одной четкой цели?". Высокая связность — это хорошо. Это означает, что модуль
делает что-то одно, целостное и понятное. Например, модуль `MathUtils`, который содержит только функции для
математических вычислений, обладает высокой связностью. А модуль `Utils`, который смешивает функции для работы со
строками, отправки email и логирования, имеет низкую связность — это "мусорная корзина", которую трудно поддерживать.

**Связанность (Coupling)** отвечает на вопрос: "Насколько сильно один модуль зависит от внутреннего устройства другого
модуля?". Низкая связанность — это хорошо. Это означает, что модули взаимодействуют через четкие, простые интерфейсы и
могут изменяться независимо друг от друга. Если же модуль "залезает" в приватные детали другого модуля, то любое
изменение в одном сломает другой — это высокая связанность (сильная связь).

Простой принцип: нужно стремиться к **высокой связности и низкой связанности**. Для QA инженера это напрямую влияет на
тестируемость: модули с высокой связностью легко тестировать изолированно, а при низкой связанности можно легко заменять
зависимости на моки.

[Содержание](/CONTENTS.md#содержание)

## **Middle Level**

С технической точки зрения эти концепции реализуются через конкретные практики проектирования и имеют четкие индикаторы.

1. **Типы связности (от худшего к лучшему):**
    * **Случайная (Coincidental):** Элементы собраны вместе случайно (например, модуль `MiscHelpers`). Тестировать такое
      невозможно — нет единой ответственности.
    * **Логическая (Logical):** Элементы сгруппированы по категории (например, класс `DataProcessor`, который
      обрабатывает и CSV, и JSON, и XML). Тесты становятся размазанными и хрупкими.
    * **Временная (Temporal):** Элементы выполняются в одно время (например, функция `initialize_all()`, которая
      настраивает логгер, БД и кеш). Приводит к сложным фикстурам и непредсказуемым побочным эффектам в тестах.
    * **Процедурная (Procedural):** Элементы объединены последовательностью шагов (например, функция, которая читает
      файл, парсит данные и сохраняет в БД). В тестах приходится эмулировать всю последовательность.
    * **Коммуникационная (Communicational):** Элементы работают с одними и теми же данными (например, класс
      `CustomerReport`, который и вычисляет статистику, и форматирует отчет). Уже лучше, но еще есть смесь
      ответственностей.
    * **Последовательная (Sequential):** Выход одного элемента является входом для другого (конвейер). Хорошо для
      тестирования каждого шага.
    * **Функциональная (Functional):** Все элементы вносят вклад в выполнение одной четкой задачи — **идеал**. Класс
      `InvoiceCalculator` только считает, `InvoiceFormatter` только форматирует. Юнит-тесты пишутся легко и
      изолированно.

2. **Типы связанности (от худшего к лучшему):**
    * **Содержание (Content):** Модуль напрямую обращается к приватным данным или коду другого модуля (нарушение
      инкапсуляции). Тесты становятся хрупкими к любым изменениям.
    * **Общая (Common):** Модули используют глобальные данные. Для тестов это катастрофа — состояние тестов влияет друг
      на друга, параллельный запуск невозможен.
    * **Внешняя (External):** Модули зависят от внешнего формата данных или протокола. Требует сложных интеграционных
      тестов и моков.
    * **Управление (Control):** Один модуль управляет логикой другого (например, передача флагов). Усложняет
      тестирование, так как нужно проверять множество ветвлений.
    * **Структурная (Stamp):** Модуль принимает сложную структуру данных, но использует только часть полей. Создает
      скрытые зависимости и усложняет создание тестовых данных.
    * **Данных (Data):** Модули взаимодействуют через минимальный интерфейс (например, передача примитивных значений). *
      *Идеал** для тестирования — зависимости легко заглушить.

3. **Инструменты для достижения:**
    * **Принцип единственной ответственности (SRP)** ведет к высокой связности.
    * **Инверсия зависимостей (DIP)** через абстракции (ABC, Protocol) ведет к низкой связанности.
    * **Закон Деметры ("не разговаривай с незнакомцами")** снижает связанность.

[Содержание](/CONTENTS.md#содержание)

## **Senior Level**

В CPython 3.9+ **связность** (cohesion) — **монолитные типы** `PyTypeObject` с полным набором слотов (`tp_as_*`), *
*слабая связанность** (loose coupling) — **reference counting** + **generational GC** (`Modules/gcmodule.c`), *
*циклические зависимости** — `gc_refs` в цикло-детекции, **модульная связанность** — `import.c` граф
импортов. `Modules/gcmodule.c`,`Python/import.c`,`Objects/typeobject.c`

## 1. Высокая связность: монолитный PyTypeObject

```c
// Include/cpython/object.h — ВСЁ В ОДНОМ типе!
typedef struct _typeobject {
    PyObject_VAR_HEAD           // refcnt, type=type
    const char *tp_name;        // имя
    Py_ssize_t tp_basicsize;    // размер
    
    /* ЧИСЛОВЫЕ операции */
    struct PyNumberMethods *tp_as_number;
    
    /* ПОСЛЕДОВАТЕЛЬНОСТИ */
    struct PySequenceMethods *tp_as_sequence;
    
    /* СЛОВАРНЫЙ интерфейс */
    struct PyMappingMethods *tp_as_mapping;
    
    /* CALL, STR, REPR, HASH */
    ternaryfunc tp_call;
    reprfunc tp_str;
    reprfunc tp_repr;
    hashfunc tp_hash;
    
    /* АТРИБУТЫ */
    getattrofunc tp_getattro;
    setattrofunc tp_setattro;
    
    /* GC, ITERATOR */
    traverseproc tp_traverse;
    inquiry tp_clear;
    iterfunc tp_iter;
    
    /* НАСЛЕДОВАНИЕ */
    PyObject *tp_bases;
    PyTypeObject *tp_base;
    PyObject *tp_mro;
    
    /* 60+ слотов! */
} PyTypeObject;
```

**Высокая связность**! Один `PyTypeObject` содержит **ВСЕ** функции типа: арифметика + последовательности + вызов + GC +
наследование. **НЕ** разделены — **монолит**! `list` имеет `tp_as_sequence + tp_as_mapping + tp_as_number + tp_iter`.

## 2. Слабая связанность: Reference Counting (независимое удаление)

```c
// Objects/object.c — Py_DECREF независим!
Py_ssize_t _Py_RefTotal;

void Py_DECREF(PyObject *op) {
    PyObject *parent;  // НЕ НУЖЕН!
    
    // op->ob_refcnt-- (атомарно)
    Py_ssize_t refcnt = --op->ob_refcnt;
    
    if (refcnt == 0) {
        // УДАЛЯЕМ НЕЗАМЕДЛИТЕЛЬНО!
        // НЕ сообщаем никому!
        _Py_Dealloc(op);  // tp_dealloc(op)
        _Py_RefTotal--;
    }
}
```

**Слабая связанность**! При `del obj` → `Py_DECREF(obj)` → если `ob_refcnt==0` → **НЕЗАМЕДЛИТЕЛЬНО** `tp_dealloc(obj)`.
**НИКТО** не знает о существовании `obj` — **независимое уничтожение**!

## 3. Циклическая связанность: GC цикл-детекция (gcmodule.c)

```c
// Modules/gcmodule.c — цикл a→b→a
typedef struct {
    PyObject_HEAD
    uintptr_t gc_refs;     // ← временный счётчик для GC!
    char gc_state;         // GCSTATE_REACHABLE/UNREACHABLE/VISITED
    PyObject *_gc_next;    // ← в списке генерации!
    PyObject *_gc_prev;
} PyGC_Head;

void _PyGC_Collect(void) {
    // 1. MARK PHASE: gc_refs = ob_refcnt
    for (obj = gen0_head; obj; obj = obj->_gc_next) {
        obj->gc_refs = Py_REFCNT(obj);  // копируем refcnt
        obj->gc_state = GCSTATE_UNCOLLECTED;
    }
    
    // 2. TRAVERSE PHASE: вычитаем внутренние ссылки
    for (obj = gen0_head; obj; obj = obj->_gc_next) {
        if (obj->gc_refs > 0) {  // живой?
            traverse_children(obj);  // obj→child: child.gc_refs--
        }
    }
    
    // 3. SWEEP PHASE: gc_refs==0 → цикл → удаляем!
    for (obj = gen0_head; obj; obj = next) {
        if (obj->gc_refs == 0 && is_unreachable(obj)) {
            PyObject_GC_Del(obj);
        }
    }
}
```

**Циклическая связанность**! `a→b→a` → `ob_refcnt(a)=1, ob_refcnt(b)=1` (refcount **НЕ падает**). **GC** копирует
`gc_refs=ob_refcnt`, вычитает **внутренние** ссылки → `gc_refs=0` → **цикл найден** → `tp_clear()` + `tp_dealloc()`.

## 4. Генерационный GC: слабая связанность поколений

```c
// Modules/gcmodule.c — 3 поколения
struct gc_generation {
    PyGC_Head head;        // doubly-linked list
    Py_ssize_t threshold;  // порог для коллекции
    Py_ssize_t count;      // счётчик объектов
};

struct _gc_runtime_state {
    struct gc_generation generations[3];  // gen0, gen1, gen2
};

// Новые объекты → gen0
void PyObject_GC_Track(PyObject *op) {
    _PyGC_Head *gchead = &_PyGC_HEAD(op);
    generation0 = &_PyRuntime.gc.generations[0];
    link_into_list(generation0, gchead);  // gen0!
    generation0->count++;
}
```

**Слабая связанность поколений**! Новые объекты → **gen0** (collect every 700 objs). Выжившие → **gen1** (collect every
10k). Долгожители → **gen2**. **Молодые НЕ зависят** от старых!

## 5. Модульная связанность: import.c граф зависимостей

```c
// Python/import.c — обнаружение циклических импортов
typedef struct {
    PyObject *md_dict;     // module.__dict__
    unsigned int md_state; // MD_STATE_* importing/prepared etc.
    int md_weaklist;       // слабые ссылки
} PyModuleObject;

static int
set_importing_module(PyThreadState *tstate, PyObject *name, int set) {
    PyObject *modules = tstate->interp->modules;  // sys.modules
    
    PyModuleObject *module = PyDict_GetItemWithError(modules, name);
    if (!module)
        return 0;
    
    if (set) {
        if (module->md_state & MD_STATE_IMPORTING) {
            // ЦИКЛ! A→B→A
            PyErr_Format(PyExc_ImportError,
                "circular import: %R", name);
            return -1;
        }
        module->md_state |= MD_STATE_IMPORTING;
    }
    return 0;
}
```

**Циклическая модульная связанность**! `import a; import b` где `a→b`, `b→a` → `md_state |= MD_STATE_IMPORTING` → *
*ImportError**! **Графовая зависимость** отслеживается в `sys.modules`.

## 6. Связность атрибутов: __slots__ vs __dict__

```c
// Objects/typeobject.c — фиксированная структура = высокая связность
int PyType_Ready(PyTypeObject *type) {
    if (type->tp_dictoffset == 0) {  // __slots__!
        // ФИКСИРОВАННЫЕ поля: высокая связность
        type->tp_flags |= Py_TPFLAGS_HAVE_SLOTS;
    } else {
        // __dict__: динамическая связность
        type->tp_getattro = PyObject_GenericGetAttr;
    }
}
```

**`__slots__`** — **высокая связность**! Фиксированные поля `[x][y]` по offset. **`__dict__`** — **слабая связность**!
Динамический поиск в хеш-таблице.

## 7. Связность MRO: C3-линеаризация (строгий порядок)

```c
// Objects/typeobject.c — жёсткая последовательность
static int mro_internal(PyTypeObject *type) {
    PyObject *mro = mro_implementation(type);  // C3!
    
    // МОНОТОННАЯ СВЯЗННОСТЬ: child ДО parents
    if (!mro_is_linearized(mro)) {
        PyErr_SetString(PyExc_TypeError, "non-monotonic MRO");
        return -1;
    }
    
    type->tp_mro = mro;  // фиксированный порядок поиска!
}
```

**Жёсткая связность MRO**! `(D,B,C,A)` — **строгий порядок**. `D.method()` → **ТОЛЬКО** первый найденный в `tp_mro`. *
*НЕ** параллельный поиск!

## 8. Связность слотов: наследование tp_* (Objects/typeobject.c)

```c
// Наследование слотов = сильная связанность
static void inherit_slots(PyTypeObject *type) {
    PyTypeObject *base = type->tp_base;
    
    // КОПИРУЕМ указатели! Сильная связанность
    if (!type->tp_as_number) type->tp_as_number = base->tp_as_number;
    if (!type->tp_as_sequence) type->tp_as_sequence = base->tp_as_sequence;
    if (!type->tp_call) type->tp_call = base->tp_call;
    // ...
}
```

**Сильная связанность**! `MyList(list)` → `MyList.tp_as_sequence = list.tp_as_sequence` (**тот же указатель**!).
`len(MyList())` → **та же C-функция** `list_length()`!

## 9. Байткод и связность: LOAD_ATTR фиксированный путь

```python
class A: x = 1


class B(A): pass


b = B()
b.x
```

```
# Байткод:
  6 LOAD_FAST           0 (b)
  8 LOAD_ATTR           0 (x)     # ← фиксированный путь по MRO!
```

В `ceval.c`:

```c
case LOAD_ATTR: {
    PyObject *name = GETITEM(names, oparg);  // "x"
    PyObject *owner = POP();                 // b
    
    // ФИКСИРОВАННЫЙ путь: _PyType_Lookup(B, "x") → A.x
    PyObject *res = PyObject_GetAttr(owner, name);
    PUSH(res);
}
```

**Статическая связность**! `LOAD_ATTR 0 (x)` — **константа** в байткоде. **НЕ** динамический поиск — **фиксированный
offset** в `names` массиве!

## Итог связности/связанности в CPython 3.9+

| Тип связности          | Реализация                | Характеристика                       |
|------------------------|---------------------------|--------------------------------------|
| **Высокая (cohesion)** | `PyTypeObject` монолит    | 60+ слотов в одном объекте [1]       |
| **Слабая (loose)**     | `Py_DECREF` независимо    | refcnt==0 → немедленное удаление [2] |
| **Циклическая**        | `gc_refs` в GC            | `a→b→a` → цикл-детекция [3]          |
| **Модульная**          | `MD_STATE_IMPORTING`      | `import a→b→a` → ImportError [4]     |
| **Структурная**        | `__slots__` vs `__dict__` | фиксированные поля vs хеш [5]        |
| **Наследственная**     | `tp_mro` C3               | монотонный порядок [5]               |
| **Слотовая**           | `inherit_slots()`         | копирование указателей [5]           |

**CPython** балансирует: **высокая связность внутри типов**, **слабая между объектами**, **циклы** — GC, **модули** —
import-граф!

- [Содержание](/CONTENTS.md#содержание)

---

# **SOLID**

## **Junior Level*

SOLID — это набор из пяти ключевых принципов проектирования в объектно-ориентированном программировании, которые
помогают создавать гибкий, поддерживаемый и расширяемый код. Каждая буква акронима представляет отдельный принцип:

**S - Single Responsibility Principle (Принцип единственной ответственности):** Каждый класс или модуль должен иметь
только одну причину для изменения. Он должен отвечать за одну конкретную задачу или ответственность.

**O - Open/Closed Principle (Принцип открытости/закрытости):** Классы должны быть открыты для расширения, но закрыты для
модификации. Это означает, что мы можем добавлять новое поведение, не меняя существующий код.

**L - Liskov Substitution Principle (Принцип подстановки Барбары Лисков):** Объекты в программе должны быть заменяемы на
экземпляры их подтипов без изменения корректности программы. Проще говоря: если что-то работает с родительским классом,
это должно работать и с любым его наследником.

**I - Interface Segregation Principle (Принцип разделения интерфейса):** Лучше иметь много специализированных
интерфейсов, чем один универсальный. Клиенты не должны зависеть от методов, которые они не используют.

**D - Dependency Inversion Principle (Принцип инверсии зависимостей):** Модули верхнего уровня не должны зависеть от
модулей нижнего уровня. Оба должны зависеть от абстракций. Абстракции не должны зависеть от деталей — детали должны
зависеть от абстракций.

Для QA инженера понимание SOLID критично, потому что код, написанный по этим принципам, гораздо легче тестировать: он
лучше изолирован, зависимости явные и заменяемые, а поведение предсказуемо.

[Содержание](/CONTENTS.md#содержание)

## **Middle Level**

С технической точки зрения, каждый принцип SOLID реализуется через конкретные паттерны и механизмы Python.

1. **SRP (Single Responsibility):** На уровне модуля (файла .py) это означает, что модуль должен экспортировать
   логически связанный набор функций/классов. На уровне класса — класс должен иметь минимальное количество публичных
   методов, связанных одной целью. Нарушение SRP приводит к God-объектам, которые невозможно адекватно покрыть
   юнит-тестами. Метрика: если вы не можете назвать ответственность класса одним коротким предложением без союза "и" —
   принцип нарушен.

2. **OCP (Open/Closed):** В Python реализуется через:
    * **Наследование и полиморфизм:** Создание подклассов для добавления поведения.
    * **Композицию и паттерн "Стратегия":** Передача поведения через callable-объекты.
    * **Декораторы:** Обертывание функций без изменения их исходного кода.
    * **Абстрактные базовые классы (ABC):** Определение интерфейсов для расширения.
      Код, соответствующий OCP, позволяет добавлять новые тестовые сценарии и проверки без модификации ядра тестового
      фреймворка.

3. **LSP (Liskov Substitution):** Это контрактный принцип. В Python он реализуется через:
    * **Соблюдение сигнатур методов:** Подкласс не должен ужесточать предусловия (требовать больше) или ослаблять
      постусловия (обещать меньше).
    * **Сохранение инвариантов:** Состояние объекта после операций должно оставаться валидным с точки зрения базового
      класса.
    * **Исключения:** Подкласс не должен выбрасывать новые типы исключений, не являющиеся подтипами исключений базового
      класса.
      Нарушение LSP — классическая причина падения тестов при замене реализации. Для QA это означает, что моки и стабы
      должны точно следовать контракту реальных объектов.

4. **ISP (Interface Segregation):** В Python, где нет формальных интерфейсов, принцип реализуется через:
    * **Абстрактные базовые классы (ABC)** с минимальным набором абстрактных методов.
    * **Протоколы (Protocol),** которые позволяют описывать узкие, специфичные наборы методов.
    * **Миксины (Mixins)** — классы, предоставляющие конкретную функциональность.
      Следствие для тестирования: нам не нужно мокировать гигантские интерфейсы, достаточно реализовать только
      используемую часть.

5. **DIP (Dependency Inversion):** Практическая реализация:
    * **Зависимость от абстракций:** Вместо `ConcreteService` в коде указывается `AbstractService` (ABC или Protocol).
    * **Внедрение зависимостей (DI):** Зависимости передаются извне (через конструктор, сеттеры, контекст), а не
      создаются внутри класса.
    * **IoC-контейнеры** (в продвинутых случаях) для автоматического управления зависимостями.
      Это краеугольный камень тестируемости: он позволяет легко подменять реальные сервисы моками в тестах.

[Содержание](/CONTENTS.md#содержание)

## **Senior Level**

### **Пример 1: Single Responsibility Principle (SRP)**

#### ❌ **Неправильно: God Object в тестовом фреймворке**

```python
class TestFramework:
    """Нарушение SRP: класс делает слишком много"""

    def __init__(self):
        self.driver = None
        self.config = {}
        self.test_data = {}
        self.report_data = []
        self.logger = None

    def setup_driver(self):
        # Создание драйвера
        pass

    def load_config(self, path):
        # Загрузка конфигурации
        pass

    def generate_test_data(self):
        # Генерация тестовых данных
        pass

    def run_test(self, test_case):
        # Запуск теста
        pass

    def generate_report(self):
        # Генерация отчета
        pass

    def send_email(self):
        # Отправка email
        pass

    def cleanup(self):
        # Очистка
        pass

    def backup_results(self):
        # Бэкап результатов
        pass
```

#### ✅ **Правильно: Разделение ответственностей**

```python
from abc import ABC, abstractmethod
from typing import Protocol


class WebDriverProvider(Protocol):
    def get_driver(self): ...

    def quit_driver(self): ...


class ConfigLoader:
    def __init__(self, path: str):
        self.path = path

    def load(self) -> dict:
        """Только загрузка конфигурации"""
        with open(self.path, 'r') as f:
            return json.load(f)


class TestDataGenerator:
    def __init__(self, strategy: DataGenerationStrategy):
        self.strategy = strategy

    def generate(self) -> dict:
        """Только генерация тестовых данных"""
        return self.strategy.execute()


class TestRunner:
    def __init__(self, driver_provider: WebDriverProvider):
        self.driver_provider = driver_provider

    def run(self, test_case: TestCase) -> TestResult:
        """Только запуск теста"""
        driver = self.driver_provider.get_driver()
        # логика теста
        return result


class ReportGenerator:
    def __init__(self, formatter: ReportFormatter):
        self.formatter = formatter

    def generate(self, results: list[TestResult]) -> Report:
        """Только генерация отчета"""
        return self.formatter.format(results)


# Композиция компонентов
class TestSuite:
    def __init__(
            self,
            config_loader: ConfigLoader,
            data_generator: TestDataGenerator,
            test_runner: TestRunner,
            report_generator: ReportGenerator
    ):
        self.config_loader = config_loader
        self.data_generator = data_generator
        self.test_runner = test_runner
        self.report_generator = report_generator

    def execute(self):
        config = self.config_loader.load()
        test_data = self.data_generator.generate()
        # ... выполнение
```

### **Пример 2: Open/Closed Principle (OCP)**

#### ❌ **Неправильно: Модификация при добавлении новой проверки**

```python
class AssertionChecker:
    """Нарушение OCP: нужно модифицировать при добавлении новых проверок"""

    def check(self, actual, expected, check_type):
        if check_type == "equals":
            return actual == expected
        elif check_type == "contains":
            return expected in actual
        elif check_type == "greater":
            return actual > expected
        # Добавление новой проверки требует изменения кода
        # elif check_type == "regex":
        #     return bool(re.match(expected, actual))
        else:
            raise ValueError(f"Unknown check type: {check_type}")
```

#### ✅ **Правильно: Расширение через новые классы**

```python
from abc import ABC, abstractmethod
from typing import Any


class CheckStrategy(ABC):
    @abstractmethod
    def execute(self, actual: Any, expected: Any) -> bool:
        pass


class EqualsCheck(CheckStrategy):
    def execute(self, actual, expected):
        return actual == expected


class ContainsCheck(CheckStrategy):
    def execute(self, actual, expected):
        return expected in actual


class RegexCheck(CheckStrategy):
    def execute(self, actual, expected):
        import re
        return bool(re.match(expected, actual))


class CustomCheck(CheckStrategy):
    def __init__(self, custom_func):
        self.custom_func = custom_func

    def execute(self, actual, expected):
        return self.custom_func(actual, expected)


class AssertionChecker:
    """Соблюдение OCP: расширяется без модификации"""

    def __init__(self):
        self._strategies = {}
        self._register_default_strategies()

    def _register_default_strategies(self):
        self.register("equals", EqualsCheck())
        self.register("contains", ContainsCheck())

    def register(self, name: str, strategy: CheckStrategy):
        """Добавление новой стратегии без изменения кода"""
        self._strategies[name] = strategy

    def check(self, name: str, actual: Any, expected: Any) -> bool:
        if name not in self._strategies:
            raise ValueError(f"Unknown check: {name}")
        return self._strategies[name].execute(actual, expected)


# Использование
checker = AssertionChecker()
checker.register("regex", RegexCheck())  # Расширение без модификации

# Новую кастомную проверку можно добавить динамически
checker.register("custom", CustomCheck(lambda a, e: len(a) > e))
```

### **Пример 3: Liskov Substitution Principle (LSP)**

#### ❌ **Неправильно: Нарушение контракта базового класса**

```python
class Database:
    def connect(self, timeout: int = 10) -> bool:
        """Возвращает True при успешном подключении"""
        # Логика подключения
        return True

    def query(self, sql: str) -> list:
        """Возвращает список результатов"""
        return []


class MockDatabase(Database):
    def connect(self, timeout: int = 10) -> bool:
        """Нарушение LSP: изменяет контракт - требует больше"""
        if timeout < 20:  # Ужесточение предусловия
            raise ValueError("Mock requires timeout >= 20")
        return True

    def query(self, sql: str) -> list:
        """Нарушение LSP: изменяет контракт - возвращает другой тип"""
        return {}  # Должен возвращать list, а возвращает dict


# В тестах это приведет к падению
def test_database_operations(db: Database):
    db.connect(15)  # Упадет с MockDatabase
    results = db.query("SELECT * FROM users")
    # Упадет при попытке использовать results как list
```

#### ✅ **Правильно: Соблюдение контракта**

```python
from typing import Protocol, runtime_checkable


@runtime_checkable
class DatabaseProtocol(Protocol):
    def connect(self, timeout: int) -> bool: ...

    def query(self, sql: str) -> list: ...


class RealDatabase:
    def connect(self, timeout: int = 10) -> bool:
        print(f"Connecting with timeout {timeout}")
        return True

    def query(self, sql: str) -> list:
        print(f"Executing: {sql}")
        return ["result1", "result2"]


class MockDatabase:
    def connect(self, timeout: int = 10) -> bool:
        """Соблюдает контракт: те же предусловия"""
        print(f"Mock connecting with timeout {timeout}")
        return True  # Всегда успешно

    def query(self, sql: str) -> list:
        """Соблюдает контракт: возвращает list"""
        print(f"Mock executing: {sql}")
        return ["mock_result1", "mock_result2"]  # Корректный тип


class InMemoryDatabase:
    def __init__(self):
        self.data = {}

    def connect(self, timeout: int = 10) -> bool:
        """Соблюдает контракт"""
        return True  # Всегда успешно

    def query(self, sql: str) -> list:
        """Соблюдает контракт"""
        # Парсинг SQL и работа с памятью
        return list(self.data.values())


# Все реализации могут быть использованы взаимозаменяемо
def run_database_test(db: DatabaseProtocol):
    assert isinstance(db, DatabaseProtocol)  # Проверка протокола

    success = db.connect(15)
    assert success is True

    results = db.query("SELECT * FROM users")
    assert isinstance(results, list)  # Гарантировано

    return results


# Все реализации работают корректно
for db in [RealDatabase(), MockDatabase(), InMemoryDatabase()]:
    run_database_test(db)
```

### **Пример 4: Interface Segregation Principle (ISP)**

#### ❌ **Неправильно: "Толстый" интерфейс**

```python
class TestFrameworkInterface:
    """Нарушение ISP: заставляет реализовывать ненужные методы"""

    def setup_driver(self):
        pass

    def teardown_driver(self):
        pass

    def load_config(self):
        pass

    def parse_results(self):
        pass

    def generate_report(self):
        pass

    def send_notification(self):
        pass

    def backup_results(self):
        pass

    def cleanup_temp_files(self):
        pass


class SimpleTestRunner(TestFrameworkInterface):
    """Вынужден реализовывать все методы, хотя нужны только некоторые"""

    def setup_driver(self):
        # Нужно
        pass

    def teardown_driver(self):
        # Нужно
        pass

    def load_config(self):
        # Нужно
        pass

    def parse_results(self):
        # Не нужно, но вынужден реализовать
        raise NotImplementedError("Not needed for simple runner")

    def generate_report(self):
        # Не нужно, но вынужден реализовать
        raise NotImplementedError("Not needed for simple runner")

    # ... остальные ненужные методы
```

#### ✅ **Правильно: Разделенные интерфейсы**

```python
from typing import Protocol


class DriverManager(Protocol):
    def setup_driver(self): ...

    def teardown_driver(self): ...


class ConfigLoader(Protocol):
    def load_config(self) -> dict: ...


class TestExecutor(Protocol):
    def execute_test(self, test_case) -> TestResult: ...


class ResultParser(Protocol):
    def parse_results(self, results) -> ParsedResults: ...


class ReportGenerator(Protocol):
    def generate_report(self, data) -> Report: ...


class NotificationSender(Protocol):
    def send_notification(self, message): ...


# Классы реализуют только нужные интерфейсы
class SimpleTestRunner:
    def __init__(
            self,
            driver_manager: DriverManager,
            config_loader: ConfigLoader,
            test_executor: TestExecutor
    ):
        self.driver_manager = driver_manager
        self.config_loader = config_loader
        self.test_executor = test_executor

    def run(self):
        # Использует только нужные зависимости
        config = self.config_loader.load_config()
        self.driver_manager.setup_driver()
        # ... выполнение тестов
        self.driver_manager.teardown_driver()


class FullFeaturedRunner(SimpleTestRunner):
    def __init__(
            self,
            driver_manager: DriverManager,
            config_loader: ConfigLoader,
            test_executor: TestExecutor,
            result_parser: ResultParser,
            report_generator: ReportGenerator,
            notifier: NotificationSender
    ):
        super().__init__(driver_manager, config_loader, test_executor)
        self.result_parser = result_parser
        self.report_generator = report_generator
        self.notifier = notifier

    def run_with_reporting(self):
        results = self.run()
        parsed = self.result_parser.parse_results(results)
        report = self.report_generator.generate_report(parsed)
        self.notifier.send_notification(f"Report: {report}")
```

### **Пример 5: Dependency Inversion Principle (DIP)**

#### ❌ **Неправильно: Зависимость от конкретных реализаций**

```python
import requests
import smtplib
import json


class TestReporter:
    """Нарушение DIP: зависит от конкретных библиотек"""

    def __init__(self):
        # Прямая зависимость от конкретных реализаций
        self.http_client = requests.Session()
        self.email_client = smtplib.SMTP()
        self.json_parser = json

    def send_to_webhook(self, url: str, data: dict):
        """Жесткая привязка к requests"""
        response = self.http_client.post(url, json=data)
        return response.status_code == 200

    def send_email(self, to: str, subject: str, body: str):
        """Жесткая привязка к smtplib"""
        self.email_client.connect()
        # ... логика отправки
        self.email_client.quit()

    def parse_json(self, text: str):
        """Жесткая привязка к json модулю"""
        return self.json_parser.loads(text)
```

#### ✅ **Правильно: Зависимость от абстракций**

```python
from typing import Protocol, Any
from abc import ABC, abstractmethod


class HttpClient(Protocol):
    def post(self, url: str, data: dict) -> Any: ...

    def get(self, url: str) -> Any: ...


class EmailClient(Protocol):
    def connect(self): ...

    def send(self, to: str, subject: str, body: str) -> bool: ...

    def disconnect(self): ...


class JsonParser(Protocol):
    def loads(self, text: str) -> dict: ...

    def dumps(self, obj: dict) -> str: ...


class RequestsHttpClient:
    """Конкретная реализация для production"""

    def __init__(self):
        import requests
        self.session = requests.Session()

    def post(self, url: str, data: dict):
        return self.session.post(url, json=data)

    def get(self, url: str):
        return self.session.get(url)


class MockHttpClient:
    """Реализация для тестирования"""

    def __init__(self, mock_responses=None):
        self.mock_responses = mock_responses or {}
        self.calls = []

    def post(self, url: str, data: dict):
        self.calls.append(("POST", url, data))
        return self.mock_responses.get(url, MockResponse(200))

    def get(self, url: str):
        self.calls.append(("GET", url))
        return self.mock_responses.get(url, MockResponse(200))


class TestReporter:
    """Соблюдение DIP: зависит от абстракций"""

    def __init__(
            self,
            http_client: HttpClient,
            email_client: EmailClient,
            json_parser: JsonParser
    ):
        self.http_client = http_client
        self.email_client = email_client
        self.json_parser = json_parser

    def send_to_webhook(self, url: str, data: dict) -> bool:
        """Работает с любой реализацией HttpClient"""
        response = self.http_client.post(url, data)
        return getattr(response, 'status_code', 200) == 200

    def send_email(self, to: str, subject: str, body: str) -> bool:
        """Работает с любой реализацией EmailClient"""
        self.email_client.connect()
        success = self.email_client.send(to, subject, body)
        self.email_client.disconnect()
        return success


# В production
production_reporter = TestReporter(
    http_client=RequestsHttpClient(),
    email_client=RealEmailClient(),
    json_parser=StandardJsonParser()
)

# В тестах
mock_reporter = TestReporter(
    http_client=MockHttpClient(),
    email_client=MockEmailClient(),
    json_parser=MockJsonParser()
)
```

### **Пример 6: Комплексный пример - Фреймворк для API тестирования**

#### ❌ **Неправильно: Монолитная архитектура с нарушениями SOLID**

```python
class APITestFramework:
    """Монолит с множеством нарушений SOLID"""

    def __init__(self):
        self.requests = __import__('requests')
        self.json = __import__('json')
        self.config = self._load_config()
        self.auth = self._setup_auth()
        self.results = []
        self.reports = []

    def run_test(self, endpoint, method="GET", data=None):
        # SRP: слишком много ответственностей
        # DIP: прямая зависимость от requests
        # OCP: сложно добавить новые типы тестов

        url = self.config['base_url'] + endpoint

        # Жестко закодированная логика
        if method == "GET":
            response = self.requests.get(url, auth=self.auth)
        elif method == "POST":
            response = self.requests.post(url, json=data, auth=self.auth)
        # ... другие методы

        # Разная логика обработки в одном методе
        if response.status_code == 200:
            self._log_success(response)
        else:
            self._log_failure(response)

        # Генерация отчета в том же методе
        self._generate_report(response)

        return response
```

#### ✅ **Правильно: SOLID-архитектура**

```python
from abc import ABC, abstractmethod
from typing import Protocol, Optional, Any
from dataclasses import dataclass
import json as json_module


# ===== АБСТРАКЦИИ (DIP) =====
class HttpClient(Protocol):
    def request(self, method: str, url: str, **kwargs) -> Any: ...


class Authenticator(Protocol):
    def authenticate(self, request: dict) -> dict: ...


class ResponseValidator(Protocol):
    def validate(self, response) -> bool: ...


class ReportGenerator(Protocol):
    def generate(self, test_result) -> str: ...


# ===== SRP: Каждый класс с одной ответственностью =====
@dataclass
class TestRequest:
    endpoint: str
    method: str = "GET"
    data: Optional[dict] = None
    headers: Optional[dict] = None


@dataclass
class TestResult:
    request: TestRequest
    response: Any
    success: bool
    duration: float


class RequestBuilder:
    """Только сборка запросов"""

    def __init__(self, base_url: str):
        self.base_url = base_url

    def build(self, test_request: TestRequest) -> dict:
        return {
            'method': test_request.method,
            'url': f"{self.base_url}{test_request.endpoint}",
            'json': test_request.data,
            'headers': test_request.headers or {}
        }


class TestExecutor:
    """Только выполнение тестов"""

    def __init__(
            self,
            http_client: HttpClient,
            authenticator: Authenticator,
            request_builder: RequestBuilder
    ):
        self.http_client = http_client
        self.authenticator = authenticator
        self.request_builder = request_builder

    def execute(self, test_request: TestRequest) -> TestResult:
        import time
        start = time.time()

        # Подготовка запроса
        request_data = self.request_builder.build(test_request)
        authenticated_request = self.authenticator.authenticate(request_data)

        # Выполнение
        response = self.http_client.request(**authenticated_request)

        duration = time.time() - start

        return TestResult(
            request=test_request,
            response=response,
            success=200 <= getattr(response, 'status_code', 0) < 300,
            duration=duration
        )


# ===== OCP: Легко расширяемые валидаторы =====
class StatusCodeValidator:
    def validate(self, response) -> bool:
        return 200 <= response.status_code < 300


class JsonSchemaValidator:
    def __init__(self, schema: dict):
        self.schema = schema

    def validate(self, response) -> bool:
        import jsonschema
        try:
            jsonschema.validate(response.json(), self.schema)
            return True
        except:
            return False


class CompositeValidator:
    """Композиция валидаторов"""

    def __init__(self, validators: list[ResponseValidator]):
        self.validators = validators

    def validate(self, response) -> bool:
        return all(v.validate(response) for v in self.validators)


# ===== LSP: Взаимозаменяемые аутентификаторы =====
class BasicAuthenticator:
    def authenticate(self, request: dict) -> dict:
        request['auth'] = ('user', 'pass')
        return request


class TokenAuthenticator:
    def __init__(self, token: str):
        self.token = token

    def authenticate(self, request: dict) -> dict:
        headers = request.get('headers', {})
        headers['Authorization'] = f'Bearer {self.token}'
        request['headers'] = headers
        return request


class MockAuthenticator:
    def authenticate(self, request: dict) -> dict:
        return request  # Без аутентификации для тестов


# ===== ISP: Специализированные генераторы отчетов =====
class JsonReportGenerator:
    def generate(self, test_result: TestResult) -> str:
        return json_module.dumps({
            'success': test_result.success,
            'duration': test_result.duration,
            'status': getattr(test_result.response, 'status_code', None)
        })


class HtmlReportGenerator:
    def generate(self, test_result: TestResult) -> str:
        return f"""
        <html>
            <body>
                <h1>Test Result</h1>
                <p>Success: {test_result.success}</p>
                <p>Duration: {test_result.duration:.2f}s</p>
            </body>
        </html>
        """


# ===== ФИНАЛЬНАЯ КОМПОЗИЦИЯ =====
class APITestFramework:
    """SOLID-совместимый фреймворк"""

    def __init__(
            self,
            base_url: str,
            http_client: HttpClient,
            authenticator: Authenticator,
            validator: ResponseValidator,
            report_generator: ReportGenerator
    ):
        self.request_builder = RequestBuilder(base_url)
        self.executor = TestExecutor(http_client, authenticator, self.request_builder)
        self.validator = validator
        self.report_generator = report_generator
        self.results = []

    def run_test(self, test_request: TestRequest) -> dict:
        # Выполнение
        result = self.executor.execute(test_request)

        # Валидация
        result.success = self.validator.validate(result.response)

        # Отчет
        report = self.report_generator.generate(result)

        self.results.append(result)
        return {
            'result': result,
            'report': report,
            'valid': result.success
        }

    # Легко добавить новые методы без изменения существующего кода (OCP)
    def run_test_suite(self, requests: list[TestRequest]):
        return [self.run_test(req) for req in requests]


# ===== ИСПОЛЬЗОВАНИЕ С РАЗНЫМИ КОНФИГУРАЦИЯМИ =====

# Production конфигурация
production_framework = APITestFramework(
    base_url="https://api.example.com",
    http_client=RequestsHttpClient(),
    authenticator=TokenAuthenticator("real-token"),
    validator=CompositeValidator([
        StatusCodeValidator(),
        JsonSchemaValidator({"type": "object"})
    ]),
    report_generator=JsonReportGenerator()
)

# Test конфигурация
test_framework = APITestFramework(
    base_url="https://test-api.example.com",
    http_client=MockHttpClient(),
    authenticator=MockAuthenticator(),
    validator=StatusCodeValidator(),
    report_generator=HtmlReportGenerator()
)

# Конфигурация для нагрузочного тестирования
load_framework = APITestFramework(
    base_url="https://api.example.com",
    http_client=AsyncHttpClient(),  # Новая реализация без изменения фреймворка
    authenticator=BasicAuthenticator(),
    validator=StatusCodeValidator(),
    report_generator=CsvReportGenerator()  # Новый генератор без изменения фреймворка
)
```

- [Содержание](/CONTENTS.md#содержание)

---

# **Метапрограммирование**

[Содержание](/CONTENTS.md#содержание)

## **Junior Level**

Метапрограммирование — это искусство написания программ, которые анализируют, генерируют или изменяют другие программы (
включая самих себя) во время выполнения. Если обычный код оперирует данными (числами, строками, объектами), то
метапрограммирование оперирует **кодом как данными**.

Представьте себе фабрику, которая не производит товары, а проектирует и собирает другие фабрики. Метапрограммирование в
Python — это и есть такая «фабрика фабрик», дающая вам инструменты для управления структурой и поведением кода на более
высоком, абстрактном уровне.

Простейшие формы метапрограммирования:

* **Декораторы** (`@decorator`): Это «обёртки», которые меняют поведение функции или класса, не трогая их исходный код.
  Например, `@staticmethod` или `@property` изменяют способ вызова метода.
* **Динамическое создание классов**: С помощью встроенной функции `type()` можно создать новый класс прямо в процессе
  выполнения программы, сгенерировав его имя, атрибуты и методы «на лету».
* **Изменение объектов**: В Python можно добавить новый метод или атрибут к уже существующему объекту после его
  создания. Эта гибкость — фундаментальное свойство языка, открывающее двери для метапрограммирования.

Метапрограммирование позволяет создавать элегантные абстракции, автоматизировать рутинный код (
например, генерацию геттеров/сеттеров), внедрять сквозную логику (логирование, проверку прав) и строить мощные
фреймворки (такие как ORM Django или система валидации Pydantic), где структура кода динамически определяется на основе
моделей или конфигураций.

[Содержание](/CONTENTS.md#содержание)

## **Middle Level**

Метапрограммирование в Python — это не единая техника, а целый арсенал инструментов разного уровня воздействия: от
точечной модификации функций до управления самой природой создания классов. Их можно представить как матрешку: каждый
следующий инструмент работает на более глубоком уровне абстракции.

### **1. Декораторы: Модификация поведения «снаружи»**

Декоратор — это функция высшего порядка, принимающая в качестве аргумента другую функцию (или класс) и возвращающая
новую, модифицированную версию. Синтаксис `@` — это лишь удобная запись.

* **Суть**: Декоратор действует как «обёртка» или «плагин», добавляющий дополнительную логику *до* или *после* вызова
  исходной функции, не изменяя её ядра.
* **Эволюция**: Декораторы могут быть вложенными, принимать собственные аргументы (`@retry(attempts=3)`) и применяться к
  методам класса. Они стали стандартным способом реализации аспектно-ориентированного программирования в Python для
  задач кеширования, логирования, аутентификации.

### **2. Дескрипторы: Управление доступом к атрибутам**

Дескрипторы — это объекты, реализующие протокол с методами `__get__`, `__set__` и `__delete__`. Когда вы обращаетесь к
атрибуту объекта, Python проверяет, не является ли этот атрибут дескриптором, и если да, то вызывает соответствующий
метод.

* **Суть**: Дескрипторы перехватывают операции чтения, записи или удаления атрибута, позволяя вам внедрить свою логику (
  валидацию, ленивые вычисления, логирование доступа).
* **Где встречается**: Вся система `@property`, `@classmethod`, `@staticmethod`, а также механизм `__slots__` построены
  на дескрипторах. Это мощный инструмент для создания умных атрибутов, поведение которых вы можете полностью
  контролировать.

### **3. Метаклассы: Контроль над созданием классов**

Если класс — это «чертёж» для создания объектов, то метакласс — это «чертёж» для создания классов. По умолчанию все
классы создаются метаклассом `type`.

* **Суть**: Создав собственный метакласс (наследовав от `type`), вы можете перехватить момент создания класса (до
  появления первого его экземпляра). В этот момент можно проанализировать, модифицировать или валидировать атрибуты и
  методы будущего класса, зарегистрировать его в реестре или автоматически добавить новые методы.
* **Применение**: ORM-фреймворки (например, Django) используют метаклассы для трансформации объявлений моделей
  `class User(models.Model)` в сложные объекты с доступом к базе данных. Это инструмент для глубокой, архитектурной
  магии, когда требуется, чтобы классы вели себя особым, нестандартным образом с самого рождения.

### **Сопутствующие мощные (и опасные) техники**

* **Интроспекция**: Возможность программы исследовать свою собственную структуру во время выполнения. Функции `dir()`,
  `getattr()`, `hasattr()`, а также модуль `inspect` позволяют «заглянуть внутрь» объектов, узнать их методы, аргументы,
  исходный код. Это основа для многих продвинутых инструментов: систем автоматического обнаружения тестов, фреймворков
  dependency injection, интерактивных дебаггеров и автодокументирования.
* **Monkey Patching (Обучение обезьян)**: Динамическое изменение модулей или классов *после* их загрузки в память, во
  время выполнения программы. Позволяет «исправлять» поведение стороннего кода, добавлять фичи или, что наиболее часто,
  подменять реальные объекты на **моки (mock-объекты)** в целях тестирования (как это делает библиотека
  `unittest.mock`). Это крайне мощный, но и рискованный приём, так как может привести к трудноотлавливаемым побочным
  эффектам, если делать это без чёткого понимания области видимости изменений.
* **Динамическое выполнение кода (`eval`/`exec`)**: Функции `eval()` (вычисляет выражение) и `exec()` (выполняет блок
  кода) интерпретируют строки как инструкции Python. Это самый радикальный вид метапрограммирования, позволяющий
  исполнять код, сгенерированный самой программой. **Крайне опасен** при использовании с непроверенными
  пользовательскими данными (уязвимость инъекции кода). Применяется во внутренних DSL (предметно-ориентированных
  языках), сложных системах конфигурации или шаблонизаторах, где безопасность входных данных гарантирована.

### **Иерархия и синергия**

Эти инструменты образуют иерархию по глубине воздействия:

1. **Декораторы** меняют уже готовые функции/классы.
2. **Дескрипторы** управляют доступом к отдельным атрибутам внутри класса.
3. **Метаклассы** определяют саму природу и процесс создания классов.

При этом они часто работают вместе: метакласс может использовать дескрипторы для создания «умных» атрибутов в новом
классе, а декоратор — применять к методам этого класса. Понимание этой экосистемы открывает путь к созданию
выразительных, эффективных и элегантных абстракций, которые делают Python таким мощным языком для построения сложных
фреймворков.

[Содержание](/CONTENTS.md#содержание)

## **Senior Level**

## Метаклассы в CPython — PyType_Type

Метапрограммирование в CPython реализуется через **PyType_Type** — тип, который создает все классы.
`class A(metaclass=MyMeta):` → `MyMeta.__new__(name, bases, dct)` вызывается на C-уровне.

```c
// Objects/typeobject.c: PyType_Type — метакласс всех типов
PyTypeObject PyType_Type = {
    PyVarObject_HEAD_INIT(&PyType_Type, 0)  // Сам себя инициализирует!
    "type",                                 // tp_name = "type"
    sizeof(PyHeapTypeObject),               // tp_basicsize для heap-типов
    0,                                      // tp_itemsize
    0,                                      // tp_dealloc (не удаляется)
    0,                                      // tp_vectorcall_offset
    0,                                      // tp_getattr
    0,                                      // tp_setattr
    0,                                      // tp_as_async
    type_repr,                              // tp_repr(self) → "<class 'int'>"
    0,                                      // tp_as_number
    0,                                      // tp_as_sequence
    0,                                      // tp_as_mapping
    type_hash,                              // tp_hash(type) → hash(tp_name)
    type_call,                              // tp_call(type, args, kwargs) ← КЛЮЧЕВОЕ!
    0,                                      // tp_str
    type_getattro,                          // tp_getattro(type, name)
    type_setattro,                          // tp_setattro(type, name, value)
    0,                                      // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
    Py_TPFLAGS_BASETYPE | Py_TPFLAGS_TYPE_SUBCLASS,  // Флаги метакласса
    type_doc,                               // tp_doc
    0,                                      // tp_traverse
    0,                                      // tp_clear
    type_richcompare,                       // tp_richcompare(type1, type2)
    0,                                      // tp_weaklistoffset
    type_mro,                               // tp_mro() → MRO список
    type_get_getattr,                       // tp_getattro слоты
    type_get_setattr,                       // tp_setattro слоты
    0,                                      // tp_as_async
    type_new,                               // tp_new(type, args, kwargs) ← СОЗДАНИЕ КЛАССА!
};
```

`PyType_Type` — это **"тип типов"**. Когда пишешь `class A:`, CPython вызывает
`PyType_Type.tp_call()` → `type_new()` → создает `PyTypeObject* A`. Метакласс `MyMeta` перехватывает этот вызов:
`MyMeta.tp_new()` вместо `type_new()`. **Все классы — объекты типа `type`**.

## type_call() — точка входа метапрограммирования

`type(args)` → `type_call(type, args, kwargs)` → цепочка `__call__` → `__new__` → `__init__`.

```c
// Objects/typeobject.c: type_call() — обработка class A(): 
static PyObject *
type_call(PyTypeObject *type, PyObject *args, PyObject *kwds) {
    PyThreadState *tstate = _PyThreadState_GET();  // Текущее состояние потока
    
    if (!PyArg_UnpackTuple(args, "type", 1, 3,      // args = (name, bases, dct)
                           &PyTuple_GET_ITEM(args, 0), &type->tp_bases, 
                           &type->tp_dict))         // Распаковка аргументов
        return NULL;
        
    // 1. Вызываем tp_prepare() метакласса (namespace preparation)
    if (type->tp_flags & Py_TPFLAGS_HEAPTYPE) {
        PyObject *prepare = _PyDict_GetItemIdWithError(  // Ищем __prepare__
            lookup_tp_dict(type), &_Py_ID(__prepare__));
        if (prepare && prepare != Py_None) {
            args = PyTuple_Pack(3, Py_NewRef(type),     // Вызываем __prepare__
                                Py_NewRef(type->tp_bases), 
                                Py_NewRef(type->tp_dict));
            PyObject *prepared = PyObject_CallObject(prepare, args);
            Py_DECREF(args);
            if (prepared == NULL) return NULL;
            type->tp_dict = prepared;  // Заменяем dct на результат
        }
    }
    
    // 2. Создаем класс: type_new()
    PyObject *obj = type_new(type, args, kwds);    // КРИТИЧЕСКАЯ ТОЧКА!
    return obj;
}
```

`class A():` → Python компилятор генерирует `(name="A", bases=(), dct={})` →
`type_call(PyType_Type, args)` → `type_new()` создает `PyTypeObject* A`. Если метакласс — сначала
`__prepare__(metaclass, name, bases)` готовит namespace (обычно dict), потом `__new__` создает класс.

## type_new() — фабрика классов CPython

`type_new(metaclass, name, bases, dct)` — сердце метапрограммирования. Создает `PyHeapTypeObject`.

```c
// Objects/typeobject.c: type_new() — создание PyTypeObject
static PyObject *
type_new(PyTypeObject *metaclass, PyObject *args, PyObject *kwds) {
    // Проверяем аргументы: type(name, bases, dct)
    PyObject *name, *bases, *dict;
    if (!PyArg_UnpackTuple(args, "", 1, 3, &name, &bases, &dict))
        return NULL;
        
    // 1. Создаем базовую PyHeapTypeObject
    PyHeapTypeObject *type = (PyHeapTypeObject *)metaclass->tp_alloc(metaclass, 0);
    if (type == NULL) return NULL;
    
    // 2. Инициализируем PyObject_HEAD
    Py_SET_TYPE(type, metaclass);              // ob_type = metaclass
    type->ht_name = name;                      // __name__ = "A"
    Py_INCREF(name);
    type->ht_qualname = name;                  // __qualname__ = "A"
    Py_INCREF(name);
    
    // 3. Устанавливаем bases и вычисляем MRO
    type->ht_bases = bases;                    // __bases__ = bases
    Py_INCREF(bases);
    set_tp_bases((PyTypeObject *)type, bases, 1);
    
    // 4. Копируем атрибуты из dct
    if (type_ready((PyTypeObject *)type) < 0) { // PyType_Ready() — MRO + слоты!
        Py_DECREF(type);
        return NULL;
    }
    
    // 5. Вызываем __init__ метакласса (опционально)
    if (PyDict_Contains(lookup_tp_dict(metaclass), &_Py_ID(__init__))) {
        if (metaclass->tp_init((PyObject *)type, args, kwds) < 0) {
            Py_DECREF(type);
            return NULL;
        }
    }
    
    return (PyObject *)type;  // Новый класс готов!
}
```

`MyMeta.__new__("A", (), {})` → выделяется память под `PyHeapTypeObject` (расширенный
PyTypeObject) → копируются name/bases/dct → `PyType_Ready()` вычисляет MRO и слоты → `__init__` метакласса (если есть).
**Результат — полноценный PyTypeObject**.

## PyType_Ready() — финальная подготовка метакласса

Вычисляет MRO, наследует слоты, проверяет конфликты `__slots__`, кэширует атрибуты.

```c
// Objects/typeobject.c: PyType_Ready() — готовим класс к использованию
static int
type_ready(PyTypeObject *type) {
    BEGIN_TYPE_LOCK();                         // Блокируем все типы
    
    // 1. Проверяем, не готов ли уже
    if (type->tp_flags & Py_TPFLAGS_READY) {
        END_TYPE_LOCK();
        return 0;
    }
    start_readying(type);                      // Помечаем "готовится"
    
    // 2. Вычисляем базовый класс (первый из tp_bases)
    PyObject *bases = lookup_tp_bases(type);
    if (PyTuple_GET_SIZE(bases) > 0) {
        type->tp_base = (PyTypeObject *)PyTuple_GET_ITEM(bases, 0);
    }
    
    // 3. Строим MRO (C3-линеаризация)
    if (type->tp_mro == NULL) {
        type->tp_mro = mro_internal(type);     // Рекурсивно по bases
        if (type->tp_mro == NULL) goto error;
    }
    
    // 4. Наследуем слоты методов (tp_call, tp_new и т.д.)
    inherit_special(type);                     // Копируем из родителей
    resolve_slots_inheritable(type);           // Разрешаем конфликты
    
    // 5. Обрабатываем __slots__ (фиксированные атрибуты)
    if (collect_methods(type) < 0) goto error; // Слоты в tp_getset
    
    // 6. Устанавливаем флаги и версию кэша
    type_add_flags(type, Py_TPFLAGS_READY);
    assign_version_tag(_PyInterpreterState_GET(), type);  // tp_version_tag
    
    stop_readying(type);
    END_TYPE_LOCK();
    return 0;
    
error:
    stop_readying(type);
    type_clear(type);  // Откат изменений
    END_TYPE_LOCK();
    return -1;
}
```

После `__new__` метакласса CPython вызывает `PyType_Ready()`:

1) строит MRO (очередь родителей)
2) копирует методы из родителей
3) обрабатывает `__slots__`
4) вычисляет смещения атрибутов
5) помечает "готов". **Только после этого класс можно использовать**

## Разрешение метаклассов — сложный алгоритм

При `class C(A, metaclass=M):` CPython решает, какой метакласс использовать.

```c
// Objects/typeobject.c: find_metaclass() — выбор метакласса
static PyObject *
find_metaclass(PyThreadState *tstate, PyObject *bases, PyObject *metaclass, 
               PyObject **metaclass_override) {
    // 1. Ищем metaclass= в bases
    for (Py_ssize_t i = 0; i < PyTuple_GET_SIZE(bases); i++) {
        PyObject *base = PyTuple_GET_ITEM(bases, i);
        PyObject *base_meta = lookup_tp_dict(_PyType_CAST(base));
        PyObject *base_m = _PyDict_GetItemId(base_meta, &_Py_ID(__class__));
        if (base_m != metaclass && PyType_Check(base_m)) {
            Py_SETREF(metaclass, base_m);      // Берем метакласс базы
        }
    }
    
    // 2. Проверяем совместимость MRO
    Py_ssize_t n = PyTuple_GET_SIZE(bases);
    for (Py_ssize_t i = 0; i < n; i++) {
        PyTypeObject *b = _PyType_CAST(PyTuple_GET_ITEM(bases, i));
        PyObject *mro = lookup_tp_mro(b);
        Py_ssize_t nmro = PyTuple_GET_SIZE(mro);
        for (Py_ssize_t j = 0; j < nmro; j++) {
            PyObject *base_m = PyTuple_GET_ITEM(mro, j);
            if (base_m == metaclass) continue;
            if (!PyType_Check(base_m)) continue;
            PyObject *bm_meta = lookup_tp_dict((PyTypeObject *)base_m);
            PyObject *bm_m = _PyDict_GetItemId(bm_meta, &_Py_ID(__class__));
            if (bm_m != metaclass && PyType_IsSubtype((PyTypeObject *)bm_m, 
                                                      metaclass)) {
                PyErr_SetString(PyExc_TypeError, 
                    "metaclass conflict: super() cannot be used");
                return NULL;
            }
        }
    }
    *metaclass_override = metaclass;
    return Py_NewRef(metaclass);
}
```

`class C(A, metaclass=M):` → берет метакласс из `A.__class__`, если он есть. Проверяет *
*совместимость MRO**: все метаклассы в MRO родителей должны быть **супертипами** `M`. Иначе
`TypeError: metaclass conflict`. **ABCMeta + type** работают благодаря иерархии метаклассов.

## Сравнение метапрограммирования уровней

| Уровень         | C-реализация                    | Python-реализация                           |
|-----------------|---------------------------------|---------------------------------------------|
| **__prepare__** | `type_call()` ищет в tp_dict    | `metaclass.__prepare__(name, bases)`        |
| **__new__**     | `type_new()` + `PyType_Ready()` | `metaclass.__new__(name, bases, dct)`       |
| **__init__**    | После `PyType_Ready()`          | `metaclass.__init__(cls, name, bases, dct)` |
| **Кэш**         | `tp_version_tag` инвалидация    | Автоматически через MRO                     |
| **MRO**         | `mro_internal()` C3             | Через `type.mro()`                          |

Метаклассы — **мощный хук** в создание классов. CPython реализует их через слоты `PyType_Type`, делая **любой класс
изменяемым на лету**.

- [Содержание](/CONTENTS.md#содержание)

---

# **Миксины**

[Содержание](/CONTENTS.md#содержание)

## **Junior Level**

Миксины (mixins) — это специальные классы в Python, предназначенные для добавления конкретной функциональности к другим
классам через множественное наследование. Если представить основной класс как основное блюдо, то миксины — это специи
или добавки, которые придают ему дополнительные свойства и возможности.

Миксины не предназначены для самостоятельного использования — они не являются полноценными объектами, а служат для "
подмешивания" методов и атрибутов к другим классам. Например, можно создать миксин `LoggingMixin`, который добавляет
методы логирования, и использовать его в разных классах, где нужна эта функциональность.

Для QA инженера миксины полезны при создании тестовых фреймворков и утилит: можно вынести общую функциональность (
например, работу с базой данных, генерацию тестовых данных, создание отчетов) в миксины и переиспользовать их в разных
тестовых классах.

[Содержание](/CONTENTS.md#содержание)

## **Middle Level**

Технически миксины — это обычные классы Python, которые следуют определенным соглашениям при использовании в
множественном наследовании.

1. **Синтаксис и использование:**
    - Миксины включаются в цепочку наследования перед основным классом.
    - Обычно имеют суффикс `Mixin` в названии для ясности.
    - Не вызывают `super().__init__()` в своем `__init__`, если не предназначены для участия в MRO (Method Resolution
      Order) инициализации.

2. **Метод разрешения порядка (MRO):**
    - При множественном наследовании Python использует алгоритм C3 для определения порядка поиска методов.
    - Миксины должны быть спроектированы так, чтобы не конфликтовать с методами основных классов и других миксинов.
    - Важно правильно располагать миксины в списке наследования: обычно миксины идут слева перед основными классами.

3. **Особенности проектирования:**
    - **Одна ответственность:** Каждый миксин должен добавлять одну четкую функциональность.
    - **Независимость:** Миксины должны быть максимально независимы от деталей реализации классов, к которым они
      подмешиваются.
    - **Гибкость:** Миксины могут определять абстрактные методы (`@abstractmethod`), которые должны быть реализованы в
      основном классе.

4. **Для AQA:**
    - **Тестовые утилиты:** Создание миксинов для общих операций: `DatabaseMixin` (для работы с БД), `APIClientMixin` (
      для HTTP-запросов), `ScreenshotMixin` (для создания скриншотов при падении теста).
    - **Расширение Page Object:** Добавление функциональности к Page Object через миксины (например, `ModalDialogMixin`
      для работы с модальными окнами).
    - **Кастомизация тестовых классов:** В `unittest.TestCase` можно использовать миксины для добавления методов
      подготовки данных, ассертов.

5. **Примеры в экосистеме Python:**
    - Django использует миксины для CBV (Class-Based Views).
    - DRF (Django REST Framework) активно использует миксины для ViewSets.
    - В тестировании: `unittest.TestCase` можно расширять миксинами.

[Содержание](/CONTENTS.md#содержание)

## **Senior Level**

## Миксины в CPython — множественное наследование + MRO

Миксины в CPython — это **обычные классы в множественном наследовании**, обрабатываемые через **C3 MRO** (Method
Resolution Order). Нет специальной поддержки — миксины работают как любой `class A(Base, Mixin1, Mixin2):`.

```c
// Objects/typeobject.c: mro_internal() — C3 алгоритм для миксинов
static PyObject *
mro_internal(PyTypeObject *type) {
    PyObject *bases = lookup_tp_bases(type);   // Кортеж баз: (Base, Mixin1, Mixin2)
    Py_ssize_t nbase = PyTuple_GET_SIZE(bases); // Кол-во родителей
    
    if (nbase == 0) {                          // Нет родителей → только type + object
        return mro_build([type, object]);
    }
    
    PyObject *result = NULL;                   // Результирующий MRO
    PyObject *sequences = PyTuple_New(nbase + 1); // Список MRO родителей
    PyTuple_SET_ITEM(sequences, 0, Py_NewRef((PyObject *)type)); // 1-й: сам класс
    
    // 2. Собираем MRO всех родителей (рекурсивно)
    for (Py_ssize_t i = 0; i < nbase; i++) {
        PyTypeObject *base = PyTuple_GET_ITEM(bases, i); // Base, Mixin1...
        PyObject *parent_mro = lookup_tp_mro(base);       // Их MRO
        if (parent_mro == NULL) goto error;
        PyTuple_SET_ITEM(sequences, i+1, Py_NewRef(parent_mro));
    }
    
    // 3. C3 линеаризация: миксины вставляются слева направо
    result = c3_merge(sequences, linearization_error);  // Алгоритм C3
    Py_DECREF(sequences);
    return result;
    
error:
    Py_DECREF(sequences);
    return NULL;
}
```

**Простыми словами для тупых**: `class A(Base, LoggingMixin, ValidationMixin):` → CPython строит MRO:
`[A, Base, LoggingMixin, ValidationMixin, object]`. **C3 алгоритм** гарантирует: 1) миксины идут **по порядку слева
направо**, 2) **НЕ дублируются**, 3) сохраняют **свой MRO**. При `A().method()` ищет:
`A.method → Base.method → LoggingMixin.method → ValidationMixin.method`.

## PyType_Ready() — наследование слотов миксинов

При создании класса CPython **копирует слоты** (методы) из миксинов по MRO, **разрешая конфликты**.

```c
// Objects/typeobject.c: inherit_special() — копирование слотов из миксинов
static int
inherit_special(PyTypeObject *type) {
    PyObject *mro = lookup_tp_mro(type);       // MRO: [A, Base, LoggingMixin...]
    
    // Идем по MRO, копируем слоты (tp_call, tp_new, tp_init...)
    for (Py_ssize_t i = 0; i < PyTuple_GET_SIZE(mro); i++) {
        PyTypeObject *base = PyTuple_GET_ITEM(mro, i); // LoggingMixin, ValidationMixin...
        
        // Копируем inheritable слоты (tp_doc, tp_new, tp_init, tp_call)
        if (base->tp_new && !type->tp_new)
            type->tp_new = base->tp_new;       // Берем из миксина
            
        if (base->tp_init && !type->tp_init)
            type->tp_init = base->tp_init;
            
        if (base->tp_call && !type->tp_call)
            type->tp_call = base->tp_call;
            
        // Пропускаем non-inheritable: tp_repr, tp_hash (нужны все или ничего)
    }
    
    // Разрешаем конфликты: последний по MRO побеждает
    resolve_slot_conflicts(type);
    return 0;
}
```

Каждый миксин имеет **таблицу слотов** (vtable): `tp_call`, `tp_new`, `tp_repr`... CPython идет по MRO и **копирует
слоты** в итоговую таблицу класса. **Последний миксин по MRO** переопределяет предыдущие. `A().__call__()` →
`A.tp_call` (из последнего миксина с `tp_call`).

## Конфликты слотов миксинов — разрешение по MRO

Если миксины определяют **одинаковые слоты**, побеждает **последний по MRO**.

```c
// Objects/typeobject.c: resolve_slots_inheritable()
static void
resolve_slots_inheritable(PyTypeObject *type) {
    PyObject *mro = lookup_tp_mro(type);
    Py_ssize_t nmro = PyTuple_GET_SIZE(mro);
    
    // Для каждого inheritable слота (tp_new, tp_init...)
    for (int slot = 0; slot < PyType_SlotCount; slot++) {
        if (!slot_is_inheritable(slot)) continue;
        
        void *last_value = NULL;               // Последнее значение по MRO
        
        // Ищем по MRO справа налево (последний побеждает)
        for (Py_ssize_t i = nmro - 1; i >= 0; i--) {
            PyTypeObject *base = PyTuple_GET_ITEM(mro, i);
            void *slot_value = *(void**)((char*)base + slot_offset[slot]);
            
            if (slot_value != NULL) {          // Найден непустой слот
                last_value = slot_value;       // Запоминаем последний
                break;
            }
        }
        
        // Записываем победивший слот
        if (last_value)
            *(void**)((char*)type + slot_offset[slot]) = last_value;
    }
}
```

`LoggingMixin.tp_repr`, `ValidationMixin.tp_repr` → **ValidationMixin** (правее в `bases`) дает финальный `tp_repr`. *
*MRO решает ВСЕ конфликты**: атрибуты, методы, слоты. Миксины должны быть **"тонкими"** (1 ответственность), иначе MRO
становится непредсказуемым.

## __slots__ в миксинах — запрещено множественное наследование

Миксины с `__slots__` **конфликтуют** из-за фиксированных смещений памяти.

```c
// Objects/typeobject.c: check_slots_multiple_bases()
static int
check_multiple_inheritance_slots(PyTypeObject *type) {
    PyObject *bases = lookup_tp_bases(type);   // (Base, LoggingSlotsMixin)
    Py_ssize_t nbase = PyTuple_GET_SIZE(bases);
    
    Py_ssize_t dictoffset = type->tp_dictoffset;  // Смещение __dict__
    
    // Считаем миксины с __slots__
    int slots_count = 0;
    for (Py_ssize_t i = 0; i < nbase; i++) {
        PyTypeObject *base = PyTuple_GET_ITEM(bases, i);
        if (base->tp_dictoffset != 0) {        // Есть __slots__
            slots_count++;
            if (base->tp_dictoffset != dictoffset) {
                PyErr_SetString(PyExc_TypeError,
                    "multiple bases with __slots__ have incompatible slots");
                return -1;                     // Конфликт смещений!
            }
        }
    }
    
    if (slots_count > 1) {
        PyErr_SetString(PyExc_TypeError,
            "can't derive from multiple bases with __slots__");
        return -1;
    }
    return 0;
}
```

`__slots__ = ['x']` → фиксирует `x` на `offsetof(PyObject_HEAD, x)`. Два миксина с `__slots__` → **разные смещения** →
дескрипторы "смотрят не туда". **Правило**: **только 1 родитель** с `__slots__`. Миксины должны использовать **обычные
атрибуты** или **композицию**.

## Кэш атрибутов миксинов — tp_version_tag

Поиск `A().method` кэшируется по `tp_version_tag`. Изменение миксинов **инвалидирует** весь поддерево.

```c
// Objects/typeobject.c: type_modified_unlocked() при изменении миксина
void PyType_Modified(PyTypeObject *mixin) {
    BEGIN_TYPE_LOCK();                         // Блокируем типы
    type_modified_unlocked(mixin);             // Рекурсивно по подклассам
    END_TYPE_LOCK();
}

static void
type_modified_unlocked(PyTypeObject *type) {
    ASSERT_TYPE_LOCK_HELD();
    
    // 1. Инвалидируем КЭШ этого типа
    set_version_unlocked(type, 0);             // tp_version_tag = 0
    
    // 2. Рекурсивно инвалидируем ПОДКЛАССЫ (использующие миксин!)
    PyObject *subclasses = lookup_tp_subclasses(type);
    if (subclasses) {
        Py_ssize_t pos = 0;
        PyObject *ref;
        while (PyDict_Next(subclasses, &pos, NULL, &ref)) {
            PyTypeObject *subclass = type_from_ref(ref);
            if (subclass) {
                type_modified_unlocked(subclass);  // A, B, C... все!
                Py_DECREF(subclass);
            }
        }
    }
}
```

Изменил `LoggingMixin.method()` → **ВСЕ классы** `class X(..., LoggingMixin):` получают `tp_version_tag=0` → **полная
инвалидация кэша**. `X().method` каждый раз ищет **заново** по MRO. **Дорого**, поэтому миксины **статичны**.

## super() в миксинах — MRO цепочка

`super().method()` в миксинах следует **MRO**, пропуская самого себя.

```c
// Objects/superobject.c: super_get() + метод разрешения
static PyObject *
super_descr_get(PyWrapperDescrObject *wrapper, PyObject *self, PyObject *instance) {
    PyTypeObject *type = wrapper->d_type;      // Класс миксина
    PyObject *mro = lookup_tp_mro(type);       // MRO миксина
    
    // Находим следующий класс ПОСЛЕ текущего в MRO
    Py_ssize_t i;
    for (i = 0; i < PyTuple_GET_SIZE(mro); i++) {
        if (PyTuple_GET_ITEM(mro, i) == (PyObject *)type) {
            break;                             // Найден LoggingMixin
        }
    }
    PyTypeObject *next_type = PyTuple_GET_ITEM(mro, i+1); // Следующий!
    
    // Создаем super(next_type, instance)
    return _PySuper_Create(next_type, instance);
}
```

В `LoggingMixin.method()` `super().method()` → **следующий** класс в MRO получает вызов. **Цепочка**:
`A.method() → LoggingMixin.method() → super() → ValidationMixin.method() → Base.method()`. **Правильный порядок** без
дублирования.

## Сравнение миксинов под капотом

| Аспект                 | Миксин (MI + MRO)       | Композиция            |
|------------------------|-------------------------|-----------------------|
| **Поиск методов**      | Авто по MRO             | `self.mixin.method()` |
| **Слоты**              | Копирование + конфликты | Отсутствуют           |
| **__slots__**          | Только 1 родитель       | Полная свобода        |
| **Изменения**          | Инвалидация поддерева   | Локально              |
| **super()**            | Автоматическая цепочка  | Ручная                |
| **Производительность** | Кэш + MRO поиск         | Прямой вызов          |

**Миксины** = **множественное наследование с дисциплиной**: слева направо, 1 ответственность, без `__slots__`. CPython
обрабатывает их через **универсальный MRO + слоты**, без специального кода.

- [Содержание](/CONTENTS.md#содержание)

---

# Делегирование

[Содержание](/CONTENTS.md#содержание)

## **Junior Level**

[Содержание](/CONTENTS.md#содержание)

## **Middle Level**

[Содержание](/CONTENTS.md#содержание)

## **Senior Level**

- [Содержание](/CONTENTS.md#содержание)

---

# Фабричные методы и абстрактные фабрики

[Содержание](/CONTENTS.md#содержание)

## **Junior Level**

[Содержание](/CONTENTS.md#содержание)

## **Middle Level**

[Содержание](/CONTENTS.md#содержание)

## **Senior Level**

- [Содержание](/CONTENTS.md#содержание)

---

# Адаптеры и мосты

[Содержание](/CONTENTS.md#содержание)

## **Junior Level**

[Содержание](/CONTENTS.md#содержание)

## **Middle Level**

[Содержание](/CONTENTS.md#содержание)

## **Senior Level**

- [Содержание](/CONTENTS.md#содержание)

---

# Наблюдатель (Observer)

[Содержание](/CONTENTS.md#содержание)

## **Junior Level**

[Содержание](/CONTENTS.md#содержание)

## **Middle Level**

[Содержание](/CONTENTS.md#содержание)

## **Senior Level**

- [Содержание](/CONTENTS.md#содержание)

---

# Стратегия (Strategy)

[Содержание](/CONTENTS.md#содержание)

## **Junior Level**

[Содержание](/CONTENTS.md#содержание)

## **Middle Level**

[Содержание](/CONTENTS.md#содержание)

## **Senior Level**

- [Содержание](/CONTENTS.md#содержание)

---

# Шаблонный метод (Template Method)

[Содержание](/CONTENTS.md#содержание)

## **Junior Level**

[Содержание](/CONTENTS.md#содержание)

## **Middle Level**

[Содержание](/CONTENTS.md#содержание)

## **Senior Level**

- [Содержание](/CONTENTS.md#содержание)
