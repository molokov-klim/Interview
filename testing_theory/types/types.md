# **Виды тестирования**

## **Junior Level*

Виды тестирования — это различные подходы и методы проверки программного обеспечения, каждый из которых решает
конкретные задачи и имеет свою область применения. Основные виды:

1. **Функциональное тестирование** — проверяет, что система работает в соответствии с требованиями (что она делает).
2. **Нефункциональное тестирование** — проверяет, как система работает (производительность, безопасность, надежность).
3. **Модульное тестирование (Unit)** — тестирование отдельных компонентов кода (функций, классов) в изоляции.
4. **Интеграционное тестирование** — проверка взаимодействия между компонентами, модулями или системами.
5. **Системное тестирование (End-to-End)** — тестирование полного рабочего потока приложения от начала до конца.
6. **Регрессионное тестирование** — проверка, что новые изменения не сломали существующую функциональность.
7. **Дымовое тестирование (Smoke)** — быстрая проверка основных функций системы после сборки.
8. **Приемочное тестирование (Acceptance)** — проверка соответствия системы бизнес-требованиям.

Для QA инженера понимание этих видов помогает выбирать правильные подходы для разных ситуаций: что тестировать
автоматически, а что вручную, как распределять ресурсы и строить стратегию тестирования.

## **Middle Level**

С технической точки зрения каждый вид тестирования в Python-экосистеме реализуется через конкретные инструменты и
практики:

1. **Функциональное тестирование:**
    - **API-тестирование:** Использование `requests`, `httpx`, `aiohttp` для HTTP-запросов. Фреймворки: `pytest` с
      плагинами `pytest-httpx`, `pytest-asyncio`.
    - **UI-тестирование:** `Selenium WebDriver`, `Playwright`, `Cypress` через Python-биндинги. Паттерн Page Object для
      структурирования кода.
    - **Тестирование бизнес-логики:** Модульные и интеграционные тесты с использованием моков (`unittest.mock`) и
      стабов.

2. **Нефункциональное тестирование:**
    - **Нагрузочное тестирование:** `locust` (кодовая нагрузка), `k6` (через subprocess), `JMeter` (через
      `jmeter-python`).
    - **Тестирование безопасности:** Статические анализаторы (`bandit`, `safety`), динамические (`OWASP ZAP` API),
      проверка зависимостей (`dependabot`, `renovate`).
    - **Тестирование доступности (a11y):** `axe-core` через `selenium` или `playwright`.

3. **Модульное тестирование (Unit):**
    - **Изоляция:** Использование `unittest.mock.patch`, `MagicMock`, `AsyncMock` для подмены зависимостей.
    - **Параметризация:** `@pytest.mark.parametrize` для тестирования с разными входными данными.
    - **Property-based тестирование:** `hypothesis` для генерации тестовых данных и проверки инвариантов.

4. **Интеграционное тестирование:**
    - **Тестирование с БД:** Использование тестовых БД (SQLite in-memory), транзакций с откатом, фикстур для данных.
    - **Тестирование микросервисов:** `docker-compose` для поднятия зависимостей, `testcontainers` для управления
      контейнерами из кода.
    - **Контрактное тестирование:** `pact-python` для проверки совместимости между потребителем и поставщиком API.

5. **Регрессионное тестирование:**
    - **Тест-сьюты:** Организация тестов по тегам (`@pytest.mark.regression`) для выборочного запуска.
    - **Анализ покрытия:** `pytest-cov` для отслеживания покрытия измененного кода.

6. **Приемочное тестирование:**
    - **BDD-подход:** `behave`, `pytest-bdd` для тестирования на основе пользовательских сценариев (Gherkin).
    - **Автоматизация сценариев:** Комбинация API и UI-тестов для проверки полных пользовательских сценариев.

7. **Тестирование в CI/CD:**
    - **Стратификация тестов:** Разделение на быстрые (unit) и медленные (UI, нагрузочные) с разными триггерами запуска.
    - **Параллельный запуск:** `pytest-xdist` для ускорения выполнения.

## **Senior Level**

# **Единая классификация видов тестирования**

Вместо хаотичного списка лучше представлять тестирование как многомерный куб. Один и тот же тест может быть одновременно
**системным**, **функциональным**, **автоматизированным** и **регрессионным**.

Ниже — структурированное разделение по ключевым измерениям (Dimensions).

***

## **1. По объекту тестирования (Что проверяем?)**

Это самое главное деление: проверяем мы бизнес-функции или качество реализации.

### **1.1 Функциональное тестирование (Functional)**

Отвечает на вопрос: **«Что система делает?»**.
Мы проверяем, решает ли программа задачи пользователя.

* **Функциональное (Functional):** Проверка бизнес-сценариев. Работает ли логин? Считается ли скидка в корзине?
* **Взаимодействия (Interoperability):** Может ли наша система общаться с другими (например, корректно ли мы шлем данные
  в 1С или платежный шлюз).

**Внутри функционального выделяют подходы:**

* **Позитивное:** «Счастливый путь» (Happy Path). Вводим корректные данные, ожидаем успех.
* **Негативное:** Вводим мусор, спецсимволы, null. Проверяем, что система не падает, а вежливо сообщает об ошибке.

### **1.2 Нефункциональное тестирование (Non-functional)**

Отвечает на вопрос: **«Как система работает?»**.
Функция может работать, но если страница грузится 30 секунд — это баг.

* **Производительности (Performance):** Общее понятие скорости и ресурсов.
    * *Нагрузочное (Load):* Как ведет себя система при **штатной** ожидаемой нагрузке.
    * *Стрессовое (Stress):* Найти точку отказа. Даем нагрузку выше максимума, пока сервер не упадет (или не
      восстановится).
    * *Стабильности/Надежности (Stability/Soak/Endurance):* Тест на выносливость. Работаем под средней нагрузкой долго (
      24+ часа), ищем утечки памяти.
    * *Объемное (Volume):* Как система работает с огромной базой данных (миллионы записей).
    * *Масштабируемости (Scalability):* Если добавить железа (CPU/RAM), вырастет ли производительность пропорционально?
* **Безопасности (Security):** Проверка на уязвимости (SQL-инъекции, XSS), разграничение прав доступа (может ли юзер
  видеть админку) и конфиденциальность.
* **Удобства использования (Usability/UX):** Насколько удобно и понятно пользователю. Это про интуитивность интерфейса,
  а не только про красоту.
* **Доступности (Accessibility/a11y):** Могут ли сайтом пользоваться люди с ограничениями (скринридеры, цветовая
  слепота).
* **Совместимости (Compatibility):**
    * *Кроссбраузерное:* Chrome, Firefox, Safari.
    * *Кроссплатформенное:* iOS vs Android, Windows vs Linux.
* **Локализации (Localization/L10n):** Проверка перевода, форматов дат, валют и направления текста (RTL).
* **Установки и конфигурирования (Installation & Configuration):** Как софт ставится, обновляется и удаляется.

***

## **2. По уровню детализации (Пирамида тестирования)**

На каком уровне архитектуры мы находимся.

1. **Модульное (Unit):** Самый низкий уровень. Проверяем отдельную функцию или класс в изоляции. Делают разработчики.
   Быстро, дешево.
2. **Интеграционное (Integration):** Проверка стыков. Как два модуля (или сервис + база данных) общаются друг с другом.
3. **Системное (System / E2E):** Проверка системы целиком, как черный ящик. Максимально близко к действиям реального
   пользователя.
4. **Приемочное (Acceptance):** Финальный этап. Заказчик (или PM) смотрит и говорит: «Да, это то, что я заказывал».

***

## **3. По знанию системы (Доступ к коду)**

* **Черный ящик (Black Box):** Мы не видим код. Знаем только вход (требования) и выход. Мы — как пользователь.
* **Белый ящик (White Box):** Мы видим код, знаем структуру БД, алгоритмы. Пишем тесты, чтобы покрыть конкретные ветки
  кода (Statement/Branch coverage).
* **Серый ящик (Grey Box):** Мы работаем как пользователь (через UI/API), но можем заглянуть в БД или логи, чтобы
  проверить, правильно ли записались данные.

***

## **4. По хронологии и изменениям (Когда запускаем?)**

* **Дымовое (Smoke):** «Включается ли вообще?». Быстрая проверка критического функционала после сборки. Если дым идет —
  дальше не тестируем.
* **Санитарное (Sanity):** Проверка **конкретной** области после исправлений. Убеждаемся, что *именно этот* баг починили
  и смежные функции работают. Узконаправленно.
* **Регрессионное (Regression):** Проверка **всей** старой функциональности после внесения изменений. Убеждаемся, что
  новый код не сломал старый.
* **Подтверждающее (Re-testing):** Просто перепроверка баг-репорта. Был баг -> разраб исправил -> мы проверили (
  Re-test).

***

## **5. По степени автоматизации**

* **Ручное (Manual):** Человек кликает мышкой. Незаменимо для UX и исследовательского тестирования.
* **Автоматизированное (Automated):** Скрипты выполняют проверки. Идеально для регресса и нагрузки.
* **Полуавтоматизированное:** Человек запускает скрипты, которые генерируют данные, но решение «Правильно/Неправильно»
  принимает сам.

***

## **6. По степени формализации**

* **Сценарное (Scripted):** Строго по тест-кейсам. Шаг влево, шаг вправо — расстрел.
* **Исследовательское (Exploratory):** Тестировщик одновременно изучает систему, придумывает тесты и выполняет их.
  Требует опыта и интуиции.
* **Ad-hoc (Интуитивное):** «Метод тыка». Бессистемное тестирование без подготовки. Иногда помогает найти самые странные
  баги.

***

# **Техническая реализация (Python Context)**

Как Senior QA Automation, вы должны знать не только *названия* видов, но и *инструменты* для них.

### **1. Функциональное тестирование**

* **API:** Основной рабочий инструмент.
    * *Libs:* `requests` (синхронно), `aiohttp`/`httpx` (асинхронно).
    * *Framework:* `pytest` — стандарт индустрии.
    * *Schema validation:* `Pydantic` или `jsonschema` (валидировать контракты ответов).
* **UI (E2E):**
    * *Tools:* `Selenium WebDriver` (классика), `Playwright` (современный, быстрый, стабильный).
    * *Pattern:* Page Object Model (POM) — обязательно для разделения локаторов и логики теста.
* **Mobile (Android/iOS):**
    * *Tool:* `Appium` (клиент на Python). Знание `ADB` и `uiautomator2`.

### **2. Нефункциональное тестирование**

* **Load (Нагрузка):**
    * `Locust`: Пишется на чистом Python. Отлично подходит для проверки API под нагрузкой.
    * `K6`: (JS/Go), но можно запускать и анализировать через Python-обвязки.
* **Security (Безопасность):**
    * Статический анализ зависимостей: `safety` (проверка requirements.txt на дыры).
    * Сканнеры: `OWASP ZAP` (можно управлять через API).

### **3. Unit & Integration (Белый ящик)**

* **Mocking:** `unittest.mock` (Mock, MagicMock, patch). Умение изолировать тест от внешнего API или БД.
* **Database:** Использование фикстур (`pytest fixtures`) для подготовки и очистки тестовых данных в БД (SQLAlchemy/Raw
  SQL).
* **Coverage:** `pytest-cov` — посмотреть, какой процент кода задет тестами.

### **4. CI/CD & Infrastructure**

* **Docker:** Запуск тестов в изолированных контейнерах (`testcontainers-python`).
* **Allure:** Генерация красивых отчетов, понятных менеджменту.
* **GitHub Actions/GitLab CI:** Настройка пайплайнов (запуск смоуков на PR, регресса на релиз).

[Содержание](/CONTENTS.md#содержание)