# **Kubernetes**

## **Junior Level*

Kubernetes (K8s) — это система для автоматизации развертывания, масштабирования и управления контейнеризированными
приложениями. Представьте, что у вас есть много контейнеров (как изолированных пакетов с вашим приложением), и вам нужно
управлять ими на множестве серверов. Kubernetes берет на себя эту задачу: он сам решает, где запускать контейнеры, как
распределять между ними нагрузку, как перезапускать их при сбоях и как обновлять без простоев.

Для QA инженера Kubernetes важен по нескольким причинам:

1. **Тестовые окружения:** Можно быстро создавать изолированные окружения для тестирования, которые точно повторяют
   продакшен.
2. **Масштабирование тестов:** Запускать тысячи тестов параллельно, используя возможности Kubernetes по управлению
   ресурсами.
3. **Инфраструктура для тестов:** Сами тестовые фреймворки и системы отчетности можно развертывать в Kubernetes как
   микросервисы.
4. **Тестирование в реалистичных условиях:** Тестировать приложение в той же среде, где оно будет работать.

## **Middle Level**

С технической точки зрения, Kubernetes состоит из нескольких ключевых компонентов, которые взаимодействуют через API.

1. **Архитектура кластера:**
    - **Control Plane (Master):** Управляющая нода, содержащая API Server, Scheduler, Controller Manager, etcd (
      хранилище конфигурации).
    - **Worker Nodes:** Ноды, на которых запускаются контейнеры. Каждая содержит kubelet (агент), kube-proxy (сетевой
      прокси) и container runtime (например, Docker).

2. **Основные объекты Kubernetes:**
    - **Pod:** Минимальная единица развертывания. Это один или несколько контейнеров, которые разделяют сеть и
      хранилище.
    - **Deployment:** Описывает желаемое состояние приложения и управляет обновлением и откатом версий.
    - **Service:** Абстракция для доступа к группе подов (обычно через балансировку нагрузки).
    - **ConfigMap и Secret:** Для управления конфигурацией и секретами.
    - **Namespace:** Виртуальный кластер внутри физического, для изоляции ресурсов.

3. **Для AQA:**
    - **Тестовые среды:** Использование Namespaces для изоляции тестовых окружений. Можно создать namespace для каждого
      тестового прогона.
    - **Запуск тестов в Pod'ах:** Тесты могут запускаться в отдельных Pod'ах как Job или CronJob. Это позволяет легко
      масштабировать и управлять выполнением тестов.
    - **Доступ к приложению:** Использование Services для доступа к тестируемому приложению, развернутому в кластере.
    - **Конфигурация тестов:** Использование ConfigMaps для передачи конфигурации тестов (например, URL приложения,
      учетные данные).

4. **Инструменты:**
    - **kubectl:** CLI для управления кластером.
    - **Helm:** Менеджер пакетов для Kubernetes, упрощающий развертывание сложных приложений.
    - **Minikube и Kind:** Инструменты для запуска локального кластера Kubernetes на машине разработчика.

## **Senior Level**

### **1. Что такое Kubernetes по сути**

Kubernetes — это не просто “оркестратор контейнеров”.  
Это **распределённая система управления состоянием**.  
Ты описываешь *желаемое состояние* в виде YAML-манифестов: “в кластере должно быть 3 копии сервиса X”.  
Дальше всё работает по принципу **control loop (петли управления)**:

1. Ты создаёшь или изменяешь объект — YAML попадает в **API Server**.
2. **etcd** хранит текущее состояние кластера (это как база истины).
3. **Controller Manager** периодически читает etcd и сравнивает: “Ага, пользователь хочет 3 Pod’а, а запущено 2. Надо
   создать ещё один.”
4. **Scheduler** решает, где разместить новый Pod.

Вся логика — это бесконечное выравнивание «требуемого» и «реального». Это философия declarative infra.  
Когда тест QA‑окружения “упал” или Pod умер — Kubernetes не “знает причину”, ему всё равно. Он просто видит расхождение
и возвращает нужное количество экземпляров.

***

### **2. Как Kubernetes мыслит "внутри"**

У Kubernetes нет “особого режима для staging или тестов”.  
Всё в нём — это ресурсы: Pod, Deployment, Service, CRD.  
По сути, кластер — это **огромная REST API**, где каждый ресурс — просто JSON-запись в etcd.

Когда ты делаешь `kubectl apply -f deployment.yaml`, клиент шлёт PATCH в API Server, а сервер обновляет CRD‑объект в
etcd.  
Контроллер (например, ReplicaSet Controller) получает ивент ("deployment изменился"), проверяет состояние, и совершает
действия (создаёт, апдейтит или удаляет поды).

***

### **3. Как это влияет на работу QA-инженера**

Представь, что тебе нужно проводить тесты в “живых” окружениях, где код в каждом PR должен разворачиваться как
mini‑production.  
Традиционно это боль, потому что вручную поддерживать десятки окружений невозможно.  
Kubernetes решает это за счёт своей **декларативности и изоляции через Namespace**.

Пример:

1. В CI пайплайне после создания Pull Request генерируется уникальный namespace, например `qa-pr-1234`.
2. Helm-чарт деплоит туда приложение при помощи Deployment + Service + Ingress.
3. QA-тест запускается как `Job`, внутри которого тест-фреймворк (pytest или robot) стучится к
   `app.qa-pr-1234.svc.cluster.local`.
4. После завершения CI всё очищается: namespace просто удаляется — и Kubernetes сам чистит все связанные ресурсы.

**Ты не управляешь окружениями — ты их описываешь.**

***

### **4. Scheduler и реальная магия автоматики**

Scheduler — это ядро интеллектуальности Kubernetes.  
Он решает, где запустить Pod, основываясь на доступных ресурсах, taint/toleration, affinity/anti-affinity и приоритетах.

Для QA‑нагрузок это важно, потому что можно описать, где именно должны жить твои тестовые контейнеры. Например:

```yaml
affinity:
  nodeAffinity:
    requiredDuringSchedulingIgnoredDuringExecution:
      nodeSelectorTerms:
        - matchExpressions:
            - key: "role"
              operator: In
              values:
                - "qa-runner"
```

Это гарантирует, что тесты не утащат CPU у продакшена.  
А ещё Kubernetes умеет **preemption** — “вытеснение” менее приоритетных Pod’ов. Например, если кластер забит, тест‑Job
можно выкинуть первым, сохранив стабильный прод.

***

### **5. Взгляд на Kubernetes как платформу для автоматизации тестов**

На уровне Senior Kubernetes воспринимается не как “где запустить тест”, а как **платформа для распределённого исполнения
и самоисцеления**.

Можно использовать его как “фреймворк для тестовых распределённых систем”.  
Пример — запуск тестов как Kubernetes Custom Resource:

```yaml
apiVersion: qa.company.io/v1
kind: TestRun
metadata:
  name: regression-suite
spec:
  repo: git@github.com:team/backend
  branch: feature/login_fix
  parallelism: 20
  env: staging
```

Дальше твой кастомный контроллер (на Python, с `kubernetes` SDK) берёт это описание, деплоит нужные Pod’ы и следит за
статусом.  
Контроллер просто повторяет паттерн Kubernetes: “desired → actual”.  
Так QA-система становится частью экосистемы Kubernetes, а не надстройкой сверху.

[Содержание](/CONTENTS.md#содержание)