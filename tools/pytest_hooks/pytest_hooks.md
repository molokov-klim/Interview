# **Pytest hooks**

## **Junior Level*

Pytest hooks (хуки) — это специальные функции, которые позволяют расширять и кастомизировать поведение pytest на разных
этапах выполнения тестов. Если представить pytest как кинотеатр, то хуки — это моменты, когда можно вставить свою
рекламу или изменить сценарий: перед началом сеанса, во время показа или после его завершения.

Хуки позволяют плагинам (включая ваши собственные) вмешиваться в процесс тестирования: изменять список тестов, добавлять
дополнительную обработку перед или после каждого теста, модифицировать отчеты, интегрироваться с внешними системами. Для
QA инженера понимание хуков открывает возможность создания кастомных плагинов для специфичных нужд проекта: интеграция с
системой отчетности, подготовка тестового окружения, сбор дополнительных метрик.

## **Middle Level**

Технически, хуки — это часть архитектуры pytest, построенной на библиотеке `pluggy`. Это система точек расширения, где
каждая точка соответствует определенному этапу жизненного цикла тестов.

1. **Система плагинов и pluggy:**
    - Pytest сам является набором встроенных плагинов, которые регистрируют и используют хуки.
    - `pluggy` — это отдельная библиотека, реализующая механизм «хук-спецификаций» и «хук-имплементаций». Она управляет
      обнаружением, регистрацией и вызовом хуков.

2. **Типы хуков:**
    - **Хуки настройки/завершения:** `pytest_configure`, `pytest_unconfigure`. Вызываются при инициализации и завершении
      сессии.
    - **Хуки сбора тестов:** `pytest_collection_modifyitems`, `pytest_collection_finish`. Позволяют фильтровать,
      переупорядочивать или модифицировать собранные тесты.
    - **Хуки выполнения тестов:** `pytest_runtest_setup`, `pytest_runtest_call`, `pytest_runtest_teardown`. Вызываются
      соответственно перед тестом, во время выполнения теста и после.
    - **Хуки отчетов:** `pytest_runtest_makereport`, `pytest_terminal_summary`. Позволяют создавать кастомные отчеты и
      выводить информацию в терминал.
    - **Хуки вызова:** `pytest_internalerror`, `pytest_keyboard_interrupt`. Обработка внутренних ошибок и прерываний.

3. **Реализация хуков:**
    - Хуки реализуются в плагинах (отдельных модулях или классах) как функции с именами, соответствующими спецификациям.
    - Плагин регистрирует свои хуки автоматически при загрузке (через entry points) или вручную через `pytest.addhooks`.
    - Хуки могут иметь параметры, которые pytest передает в них (например, `session`, `item`, `report`).

4. **Примеры использования для AQA:**
    - **Автоматическая маркировка тестов:** Хук `pytest_collection_modifyitems` может анализировать имена тестов и
      автоматически помечать их как `@pytest.mark.slow` или `@pytest.mark.integration`.
    - **Динамическое добавление тестов:** Хук `pytest_generate_tests` позволяет генерировать параметризованные тесты на
      основе внешних данных.
    - **Кастомная отчетность:** Хук `pytest_runtest_makereport` позволяет добавлять в отчет дополнительную информацию (
      скриншоты, логи, метрики производительности).
    - **Интеграция с внешними системами:** Хуки `pytest_sessionstart` и `pytest_sessionfinish` могут отправлять
      уведомления в Slack, JIRA или обновлять дашборды.

## **Senior Level**

## **Архитектурное погружение в систему плагинов и хуков**

### **1. Pluggy: сердце расширяемости Pytest**

**Pluggy** — это независимая библиотека для создания систем плагинов, которую pytest использует как фундамент. Понимание
её работы критически для создания сложных плагинов и кастомизации поведения pytest.

**Ключевые компоненты pluggy:**

```
# Концептуальная схема
┌─────────────────────────────────────────────┐
│          Pytest Core (встроенные плагины)   │
├─────────────────────────────────────────────┤
│         Система хуков через pluggy          │
│  ┌─────────────┐  ┌─────────────┐           │
│  │ HookSpec    │  │ HookImpl    │           │
│  │ (контракт)  │  │ (реализация)│           │
│  └─────────────┘  └─────────────┘           │
│          │             │                    │
│          └─────┬───────┘                    │
│                ▼                            │
│        HookCaller (диспетчер)               │
│        с ordered_hookimpls                  │
└─────────────────────────────────────────────┘
```

**HookSpec (спецификация хука)** — определяет интерфейс: какие параметры хук принимает, что возвращает. Это контракт,
который должны соблюдать все реализации.

**HookImpl (реализация хука)** — конкретная функция плагина, которая реализует логику хука. Может иметь модификаторы:

- `tryfirst=True` — выполнится раньше других
- `trylast=True` — выполнится позже других
- `hookwrapper=True` — становится обёрткой (wrapper)

**HookCaller** — объект, который управляет вызовом всех HookImpl для конкретного хука. Хранит их в порядке выполнения.

### **2. Порядок выполнения хуков и приоритеты**

Когда pytest вызывает хук (например, `pytest_runtest_setup`), HookCaller выполняет все зарегистрированные реализации в
строгом порядке:

```
1. Реализации с tryfirst=True (в порядке регистрации)
2. Обычные реализации (без tryfirst/trylast)
3. Реализации с trylast=True (в порядке регистрации)
4. Hook wrappers (обёртки) — особый случай
```

**Hook wrappers (обёртки)** — это генераторные функции, которые могут выполнять код до и после основного выполнения
хука:

```python
@pytest.hookimpl(hookwrapper=True)
def pytest_runtest_setup(item):
    # Код ДО выполнения остальных реализаций
    start_time = time.time()

    # yield передаёт управление другим реализациям
    outcome = yield  # Получаем результат выполнения "внутренних" хуков

    # Код ПОСЛЕ выполнения остальных реализаций
    duration = time.time() - start_time

    # Можно модифицировать результат
    if outcome.excinfo:
        logger.error(f"Test setup failed after {duration}s")
    elif duration > 5.0:
        logger.warning(f"Slow setup: {duration}s")
```

### **3. Внутренние объекты Pytest: Config и Item**

**Config объект** (`pytest.Config`) — это центральный реестр, который:

- Содержит все зарегистрированные плагины
- Хранит состояние сессии тестирования
- Предоставляет доступ к менеджеру плагинов через `config.pluginmanager`
- Может использоваться плагинами для обмена данными через `config.myplugin_data`

**Item объект** — представляет конкретный тест (функцию или метод). Каждый Item имеет:

- `_request` — объект с контекстом выполнения (включая разрешённые фикстуры)
- `user_properties` — словарь для хранения пользовательских данных
- Методы для управления состоянием теста

**Динамическая работа с Item в хуках:**

```python
def pytest_runtest_setup(item):
    # Добавляем пользовательские метаданные
    item.user_properties.append(("test_module", item.module.__name__))

    # Модифицируем имя теста для отчёта
    if hasattr(item, "_metadata"):
        item._metadata["custom_name"] = f"{item.name}_modified"
```

### **4. Динамическая регистрация и расширение системы**

Плагины могут не только реализовывать существующие хуки, но и расширять систему, добавляя новые:

```python
class MyPlugin:
    @pytest.hookspec
    def pytest_my_custom_hook(self, config, data):
        """Новый хук, который могут реализовывать другие плагины"""
        pass

    def pytest_addhooks(self, pluginmanager):
        # Регистрируем спецификацию нового хука
        pluginmanager.add_hookspecs(MyPlugin)


class AnotherPlugin:
    @pytest.hookimpl
    def pytest_my_custom_hook(self, config, data):
        # Реализация нового хука
        return process_data(data)
```

**Важно:** динамическая регистрация требует глубокого понимания порядка инициализации плагинов, чтобы избежать
конфликтов.

### **5. Внутренние механизмы выполнения: от байткода до фреймов**

**PluginManager и регистрация хуков:**

Когда плагин регистрируется через `pluginmanager.register()`, происходит:

1. Сканирование всех атрибутов плагина
2. Поиск функций с атрибутом `pytest_impl` (добавляется декоратором `@pytest.hookimpl`)
3. Создание объектов `HookImpl` с информацией о реализации
4. Добавление в соответствующий `HookCaller`

**Выполнение хуков (multicall):**

При вызове хука (`config.hook.pytest_runtest_setup(item=item)`) происходит:

```python
# Упрощённая схема multicall
def _multicall(hook_impls, kwargs):
    results = []

    for hook_impl in hook_impls:
        if hook_impl.hookwrapper:
            # Для wrapper-хуков
            gen = hook_impl.function(**kwargs)
            outcome = next(gen)  # Выполняем код до yield
            try:
                # Рекурсивно вызываем остальные хуки
                inner_results = _multicall(next_impls, kwargs)
                gen.send(inner_results)  # Выполняем код после yield
            except Exception:
                gen.throw(*sys.exc_info())
        else:
            # Для обычных хуков
            result = hook_impl.function(**kwargs)
            results.append(result)

    return results
```

**CPython-уровень:** Каждый вызов хука создаёт новый фрейм выполнения (`PyFrameObject`), который CPython интерпретатор
обрабатывает в своем цикле байт-кода.

### **6. Обёрточные хуки (wrapper hooks) и Outcome**

Обёрточные хуки используют механизм генераторов Python для перехвата выполнения:

```
Порядок выполнения для wrapper хука:
1. next(wrapper_gen) → код ДО yield
2. Выполняются все не-wrapper реализации
3. wrapper_gen.send(results) → код ПОСЛЕ yield
4. Исключения можно обработать через outcome.excinfo
```

### **7. Валидация и контракты через HookSpec**

Спецификации хуков не только документируют интерфейс, но и выполняют валидацию:

```python
# В hookspec.py
@pytest.hookspec
def pytest_runtest_setup(item):
    """Вызывается перед выполнением теста.
    
    :param item: тестовый элемент (Item)
    """
    pass

# При регистрации реализации проверяется:
# 1. Соответствие сигнатуры
# 2. Наличие обязательных параметров
# 3. Совместимость возвращаемых типов (если используются аннотации)
```

### **8. Производительность и оптимизация**

**Накладные расходы системы хуков:**

- ~100-500 наносекунд на простой хук
- ~1-5 микросекунд на хук с несколькими реализациями
- ~10-50 микросекунд на wrapper-хуки

**Оптимизации:**

- Кэширование разрешённых фикстур
- Ленивая загрузка плагинов
- Минимизация количества wrapper-хуков в критичных путях

### **9. Продвинутые сценарии использования**

**Динамическое создание тестов на основе внешних данных:**

```python
def pytest_generate_tests(metafunc):
    """Генерация тестовых случаев динамически"""
    if "api_endpoint" in metafunc.fixturenames:
        endpoints = fetch_endpoints_from_config()
        metafunc.parametrize("api_endpoint", endpoints)


# Или через коллекцию:
def pytest_collection_modifyitems(config, items):
    """Фильтрация и модификация тестов перед выполнением"""
    if config.getoption("--only-smoke"):
        items[:] = [item for item in items
                    if hasattr(item, "smoke") and item.smoke]
```

**Интеграция с распределёнными системами:**

```python
class DistributedTestPlugin:
    def __init__(self):
        self.test_queue = []
        self.results = {}

    def pytest_collection_modifyitems(self, config, items):
        # Распределяем тесты по worker-нодам
        for i, item in enumerate(items):
            worker_id = i % config.option.num_workers
            self.assign_test_to_worker(item, worker_id)

    def pytest_runtest_protocol(self, item, nextitem):
        # Управляем выполнением теста в распределённой среде
        if not self.is_my_worker(item):
            return True  # Пропускаем тест на этой ноде

        # Выполняем тест локально
        return None  # Продолжаем стандартный протокол
```

### **10. Отладка и диагностика**

**Инструменты для отладки системы плагинов:**

- `pytest --trace-config` — показывает загрузку плагинов
- `pytest --debug` — выводит внутреннюю отладочную информацию
- Кастомные плагины для трассировки вызовов хуков:

```python
class HookTracerPlugin:
    def __init__(self):
        self.hook_calls = []

    @pytest.hookimpl(hookwrapper=True)
    def pytest_runtest_call(self, item):
        start = time.perf_counter()
        outcome = yield
        duration = time.perf_counter() - start
        self.hook_calls.append({
            "hook": "pytest_runtest_call",
            "item": item.name,
            "duration": duration,
            "success": outcome.excinfo is None
        })
```

**Итог для Senior уровня:** Понимание внутренней архитектуры pytest и pluggy позволяет не только создавать сложные
плагины, но и предсказывать поведение системы в нестандартных сценариях, оптимизировать производительность и
интегрировать pytest с любыми внешними системами, от CI/CD пайплайнов до распределённых вычислительных кластеров.

- [Содержание](/CONTENTS.md#содержание)