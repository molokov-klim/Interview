OBJECTIVE:
- Проверь информацию на истинность

DATA:
-
# **Типы данных**

## **Junior Level**

В Python, как и в любом языке программирования, данные бывают разных видов или «типов». Это базовые кирпичики, с
которыми работает программа. Их можно разделить на две большие категории: изменяемые и неизменяемые.

Простые, или «скалярные» типы — это числа (целые, вещественные, комплексные), строки текста и логические значения (
`True`/`False`). Важное свойство строк и чисел — их **нельзя изменить после создания**. Если ты пишешь `x = "hello"`, а
потом `x = "world"`, ты не меняешь строку "hello", а создаешь новую и даешь ей то же имя `x`.

Более сложные, «коллекционные» типы — это списки, кортежи, словари и множества. Они нужны для хранения набора других
значений. Здесь ключевое различие: **список можно изменить** (добавить или удалить элемент), а **кортеж — нет**. Словарь
хранит данные в парах «ключ-значение», и его тоже можно изменять.

## **Middle Level**

1. **Классификация по мутабельности (изменяемости):**

* **Изменяемые (mutable):** `list`, `dict`, `set`, `bytearray`, пользовательские классы (по умолчанию). Содержимое
  таких объектов можно менять. При передаче в функцию передается ссылка на тот же самый объект, поэтому изменения,
  сделанные внутри функции, видны снаружи.
* **Неизменяемые (immutable):** `int`, `float`, `complex`, `str`, `bytes`, `tuple`, `frozenset`, `bool`, `NoneType`.
  Экземпляр такого типа после создания не может быть изменен. Любая операция, выглядящая как изменение, на деле
  создает новый объект. Это имеет глубокие последствия для хэшируемости (объекты этих типов обычно хэшируемы),
  использования в качестве ключей словаря и поведения при передаче в функции (передается ссылка на объект, но так
  как объект нельзя изменить, создается иллюзия передачи «по значению»).

2. **Устройство объектов:** В Python всё является объектом. Каждый объект имеет три обязательных атрибута: *
   *идентификатор** (уникальный числовой адрес в памяти, возвращаемый `id()`), **тип** (определяющий возможные операции,
   возвращаемый `type()`) и **значение**. Для неизменяемых типов идентификатор и значение жестко связаны. Для
   изменяемых — объект может менять значение, сохраняя идентификатор.

3. **Специфика типов:**

* `None` — синглтон, объект, обозначающий отсутствие значения. `id(None)` всегда одинаков.
* Булевы значения `True` и `False` — также синглтоны и являются подклассами `int`.
* `tuple` — неизменяем, но если содержит изменяемые элементы (например, списки), то эти внутренние элементы менять
  можно. Это делает кортеж «условно хэшируемым».
* `dict` начиная с Python 3.7 гарантирует сохранение порядка вставки, а с 3.6 это было особенностью реализации
  CPython.
* `set` и `frozenset` хранят только уникальные, хэшируемые элементы. Их внутренняя реализация близка к словарю, где
  есть только ключи.

Сравнение `[1,2,3] == [1,2,3]` дает `True`, но `id()` у этих списков разный.

## **Senior Level**

1. **Всё есть `PyObject`:** В исходном коде CPython (`Include/object.h`) лежит фундамент — структура `PyObject`. Это
   базовый «контейнер» для любого типа данных.

```c
typedef struct _object {
    Py_ssize_t ob_refcnt;  // Счетчик ссылок — основа механизма GC
    PyTypeObject *ob_type; // Указатель на структуру типа
    } PyObject;
```

Каждый объект в Python начинается с этих двух полей. `ob_refcnt` — счетчик ссылок для сборщика мусора. `ob_type` —
указатель на другой объект — его тип, который сам является объектом (`PyTypeObject`). Добавление новых полей
происходит путем «расширения» этой структуры. Например, `PyLongObject` (целое число) добавляет поле для хранения
цифр.

2. **Неизменяемость и интернирование (interning):** Это не просто договоренность, а оптимизация на уровне
   интерпретатора.

* **Маленькие целые числа:** Диапазон обычно от -5 до 256. Эти объекты создаются при запуске интерпретатора и
  хранятся в специальном массиве. Операция `a = 10; b = 10` приведет к тому, что `a` и `b` будут указывать на **один
  и тот же** объект в памяти (`id(a) == id(b)`). Проверка делается макросом `PyLong_FromLong`.
* **Строки (interned strings):** Если строка состоит только из символов ASCII, букв, цифр и подчеркивания, и не
  выглядит как число, она также может быть интернирована. Это особенно важно для имен переменных, атрибутов. Python
  делает это автоматически, но можно принудительно интернировать строку через `sys.intern()`. Это ускоряет сравнение
  строк (достаточно сравнить указатели, `a is b`) и экономит память в случае множества одинаковых строк (например,
  при парсинге больших XML/JSON в тестах).

3. **Мутабельность и байткод:** Рассмотрим операцию `my_list.append(x)`. Байткод инструкция `LIST_APPEND` работает
   непосредственно с внутренним C-массивом структуры `PyListObject`. Объект списка (`list`) хранит указатель (
   `**ob_item`) на этот массив указателей на `PyObject` и его текущую длину (`ob_size`). `LIST_APPEND` увеличивает
   `ob_size`, при необходимости перераспределяет память для `ob_item` (сложность amortized O(1)) и помещает в новый слот
   ссылку на `x`, увеличивая `ob_refcnt` у объекта `x`. Никакого нового `list` не создается, `id(my_list)` остается
   прежним.

4. **Словарь: краеугольный камень языка.** `dict` — не просто тип, это фундаментальная структура, используемая
   повсеместно: пространства имен модулей, атрибуты объектов, передача аргументов в функции (`**kwargs`) реализованы
   через словари. Его внутренности — это хэш-таблица (массив `PyDictKeyEntry`). Ключевая хитрость в том, как разрешаются
   коллизии (метод открытой адресации). При удалении многих элементов словарь может оставаться разреженным, что ведет к
   утечкам памяти. Для AQA это означает, что долгоживущие объекты с большими изменяющимися словарями (например, кэши в
   тестируемом приложении) требуют мониторинга памяти. Словари также резко замедляются при атаках хэш-коллизиями, что
   может быть вектором DoS-атаки — это важно для security-тестирования.

5. **`tuple` vs `list`: Не просто мутабельность.** `tuple` из-за своей неизменности аллоцируется одной непрерывной
   областью памяти. Его `ob_item` — это встроенный массив указателей фиксированного размера. `list` же имеет буфер с
   «запасом» (`allocated`), чтобы не переаллоцировать память при каждом `append`. Сравнение `is` для кортежей,
   содержащих только неизменяемые элементы, может давать `True` благодаря механизму кэширования (`tupleobject.c`):
   Python может переиспользовать только что созданный кортеж, если он пуст или состоит из одного элемента.

6. **Типизация для AQA:** На этом уровне мы понимаем, что система типов Python — динамическая, но строгая (strong).
   «Утиная типизация» реализуется через механизм поиска атрибутов в `__dict__` объекта и далее по MRO (Method Resolution
   Order). Паттерн `isinstance(obj, abc.ABC)` или `hasattr(obj, '__len__')` на байткод-уровне сводится к проверкам
   `PyObject_IsInstance` и `PyObject_HasAttr`, которые проходят по цепочке классов. Для Senior AQA критично понимать эти
   механизмы при тестировании полиморфных компонентов, мокинге и создании сложных фикстур, имитирующих определенные
   интерфейсы.

- [Содержание](#содержание)

---

